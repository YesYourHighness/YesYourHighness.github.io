<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32X32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16X16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CZCOOL+XiaoWei:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/orange/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="引言： redis：一个非关系型高性能键值对数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://yoursite.com/2020/01/11/Redis/Redis/index.html">
<meta property="og:site_name" content="Hynis">
<meta property="og:description" content="引言： redis：一个非关系型高性能键值对数据库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827162458198.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827170121523.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210811193928235.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210823092749357.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829160053093.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829164359348.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829170946602.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827183749301.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827184500617.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827190636594.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827192922183.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827192952173.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210827193136348.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210828204837179.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210828205427565.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210828210222147.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210828211207985.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210828211559390.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210828212414013.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210828213035116.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829151152890.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829150559213.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829150014119.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829201020913.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829202110035.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829202821202.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210829205759671.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20240725104602761.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210830084706183.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210830095244062.png">
<meta property="article:published_time" content="2020-01-11T08:19:36.000Z">
<meta property="article:modified_time" content="2025-07-31T18:09:08.769Z">
<meta property="article:author" content="Hynis">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.yesmylord.cn//image-20210827162458198.png">


<link rel="canonical" href="http://yoursite.com/2020/01/11/Redis/Redis/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2020/01/11/Redis/Redis/","path":"2020/01/11/Redis/Redis/","title":"Redis"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Redis | Hynis</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hynis</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">156</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">91</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">213</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">

<!-- 网易云外链-->
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1439739102&auto=1&height=66"></iframe>
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>



      <div class="sidebar-panel-container">

        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93"><span class="nav-number">1.</span> <span class="nav-text">Redis核心内容总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#NOSQL"><span class="nav-number">2.</span> <span class="nav-text">NOSQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.0.1.</span> <span class="nav-text">关系型数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93-NOSQL"><span class="nav-number">2.0.2.</span> <span class="nav-text">非关系型数据库(NOSQL)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NOSQL%E4%B8%8E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">2.0.3.</span> <span class="nav-text">NOSQL与关系型数据库的比较</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">3.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E8%AF%86Redis"><span class="nav-number">3.1.</span> <span class="nav-text">初识Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E5%A4%A7%E7%BB%B4%E5%BA%A6%E3%80%81%E4%B8%89%E5%A4%A7%E4%B8%BB%E7%BA%BF"><span class="nav-number">3.2.</span> <span class="nav-text">两大维度、三大主线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.</span> <span class="nav-text">redis不同数据的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.1.</span> <span class="nav-text">redis数据库操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.2.</span> <span class="nav-text">redis的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.3.</span> <span class="nav-text">字符串类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">Redis中的字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">Redis字符串的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.4.</span> <span class="nav-text">哈希类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.5.</span> <span class="nav-text">列表类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E4%B8%AD%E7%9A%84list"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">Redis中的list</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E5%88%97%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">Redis列表的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.6.</span> <span class="nav-text">集合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.7.</span> <span class="nav-text">Redis集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.7.1.</span> <span class="nav-text">Redis集合的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.8.</span> <span class="nav-text">有序集合类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88Zset"><span class="nav-number">3.3.8.1.</span> <span class="nav-text">Redis有序集合Zset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">3.3.8.2.</span> <span class="nav-text">Redis有序集合的应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.4.</span> <span class="nav-text">Redis底层数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SDS%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.4.1.</span> <span class="nav-text">SDS简单动态字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">3.4.2.</span> <span class="nav-text">压缩列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">3.4.3.</span> <span class="nav-text">双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">3.4.4.</span> <span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="nav-number">3.4.5.</span> <span class="nav-text">有序数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">3.4.6.</span> <span class="nav-text">跳表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88SortedSet%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%9F"><span class="nav-number">3.4.7.</span> <span class="nav-text">为什么SortedSet用跳表？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.5.</span> <span class="nav-text">深入Redis数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%A0%E5%86%85%E5%AD%98%E7%9A%84String"><span class="nav-number">3.5.1.</span> <span class="nav-text">占内存的String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">3.5.2.</span> <span class="nav-text">使用压缩列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">3.6.</span> <span class="nav-text">全局哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%95%B0%E6%8D%AE%E5%BA%93Redis"><span class="nav-number">3.7.</span> <span class="nav-text">单线程数据库Redis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="nav-number">3.8.</span> <span class="nav-text">多路复用机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.9.</span> <span class="nav-text">AOF详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-number">3.9.1.</span> <span class="nav-text">三种写回策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="nav-number">3.9.2.</span> <span class="nav-text">AOF重写机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.10.</span> <span class="nav-text">RDB详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E5%BF%AB%E7%85%A7"><span class="nav-number">3.10.1.</span> <span class="nav-text">RDB快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">3.10.2.</span> <span class="nav-text">RDB的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis4-0%E6%B7%B7%E5%90%88AOF%E4%B8%8ERDB"><span class="nav-number">3.10.3.</span> <span class="nav-text">Redis4.0混合AOF与RDB</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">3.11.</span> <span class="nav-text">Redis主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.11.1.</span> <span class="nav-text">主从库模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%90%8C%E6%AD%A5"><span class="nav-number">3.11.2.</span> <span class="nav-text">第一次同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E7%BA%A7%E8%81%94%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.11.3.</span> <span class="nav-text">主从级联模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E9%97%AA%E6%96%AD%E4%B8%8Erepl-backlog-buffer%E7%BC%93%E5%AD%98"><span class="nav-number">3.11.4.</span> <span class="nav-text">网络闪断与repl_backlog_buffer缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">3.12.</span> <span class="nav-text">哨兵机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A8%E5%85%B5"><span class="nav-number">3.12.1.</span> <span class="nav-text">哨兵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E2%80%94%E2%80%94%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF"><span class="nav-number">3.12.2.</span> <span class="nav-text">监控——主观下线与客观下线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E4%B8%BB%E2%80%94%E2%80%94%E9%80%89%E6%8B%A9%E6%96%B0%E4%B8%BB%E5%BA%93"><span class="nav-number">3.12.3.</span> <span class="nav-text">选主——选择新主库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%9F%A5%E2%80%94%E2%80%94%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%9C%BA%E5%88%B6"><span class="nav-number">3.12.4.</span> <span class="nav-text">通知——发布&#x2F;订阅机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E7%BC%93%E5%AD%98"><span class="nav-number">4.</span> <span class="nav-text">Redis缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">4.1.</span> <span class="nav-text">缓存处理请求的两种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">Redis的缓存类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">Redis的缓存淘汰机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%AD%E7%9A%84LRU%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">Redis中的LRU算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.</span> <span class="nav-text">缓存一致性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">4.6.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">4.7.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">4.8.</span> <span class="nav-text">缓存穿透</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">4.8.1.</span> <span class="nav-text">布隆过滤器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E6%80%BB%E7%BB%93"><span class="nav-number">4.9.</span> <span class="nav-text">缓存异常总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93"><span class="nav-number">4.10.</span> <span class="nav-text">缓存污染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%AD%E7%9A%84LFU%E7%AE%97%E6%B3%95"><span class="nav-number">4.11.</span> <span class="nav-text">Redis中的LFU算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%83%ADkey%E9%97%AE%E9%A2%98"><span class="nav-number">4.12.</span> <span class="nav-text">热key问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%A7key%E9%97%AE%E9%A2%98"><span class="nav-number">4.13.</span> <span class="nav-text">大key问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">Redis分布式锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text">相关链接</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hynis"
      src="http://img.yesmylord.cn//1644852537960.jpg">
  <p class="site-author-name" itemprop="name">Hynis</p>
  <div class="site-description" itemprop="description">A blog about IT knowledge</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">213</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YesYourHighness" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YesYourHighness" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1046467756@qq.com" title="E-Mail → mailto:1046467756@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zouper.cn/" title="https:&#x2F;&#x2F;zouper.cn" rel="noopener" target="_blank">一杯好茶</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.klenkiven.xyz/" title="https:&#x2F;&#x2F;www.klenkiven.xyz&#x2F;" rel="noopener" target="_blank">KlenKiven</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hourunmeng.github.io/" title="https:&#x2F;&#x2F;hourunmeng.github.io&#x2F;" rel="noopener" target="_blank">润萌</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://flashxin.github.io/" title="https:&#x2F;&#x2F;flashxin.github.io&#x2F;" rel="noopener" target="_blank">flashxin</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/YesYourHighness" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/11/Redis/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.yesmylord.cn//1644852537960.jpg">
      <meta itemprop="name" content="Hynis">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hynis">
      <meta itemprop="description" content="A blog about IT knowledge">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Redis | Hynis">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-11 16:19:36" itemprop="dateCreated datePublished" datetime="2020-01-11T16:19:36+08:00">2020-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-01 02:09:08" itemprop="dateModified" datetime="2025-08-01T02:09:08+08:00">2025-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>
引言：
redis：一个非关系型高性能键值对数据库
</center>

<span id="more"></span>

<h1 id="Redis核心内容总结"><a href="#Redis核心内容总结" class="headerlink" title="Redis核心内容总结"></a>Redis核心内容总结</h1><ol>
<li>支持的数据结构有：字符串、列表、字典（哈希）、集合、有序集合</li>
<li>字符串的底层数据结构：<strong>SDS简单动态字符串</strong>（三个字段：<strong>指针</strong>、<strong>free</strong>剩余的空间大小、<strong>len</strong>长度）</li>
<li>使用SDS替代C原本字符串的优点：<ul>
<li><strong>获取字符串长度为O(1)级别（</strong>C中需要遍历一遍O(n)）</li>
<li>实现了<strong>空间预分配</strong>（扩大时会扩的更大一点）、<strong>惰性空间释放</strong>（缩小时不会立即缩小）</li>
<li><strong>二进制安全</strong>（使用len来判断字符串结尾，而不是C中的使用<code>/0</code>来判断）</li>
</ul>
</li>
<li><strong>列表</strong>的底层数据结构：数据少用<strong>压缩列表</strong>；数据多用<strong>双向链表</strong></li>
<li>什么时候用<strong>压缩列表</strong>？满足两个条件：<ul>
<li>每个数据的长度<strong>不超过64</strong></li>
<li>数据总个数<strong>不超过512</strong></li>
</ul>
</li>
<li><strong>哈希</strong>的底层数据结构：数据少用<strong>压缩列表</strong>；数据<strong>多用散列表</strong></li>
<li>散列表的使用细节：<ul>
<li>解决哈希冲突：<strong>拉链法</strong></li>
<li>维护一个<strong>装载因子</strong>：装载因子大于1.0，就翻2倍左右；小于0.1，就缩小2倍左右</li>
</ul>
</li>
<li><strong>集合</strong>的底层数据结构：数据少用<strong>有序数组</strong>；数据多用<strong>散列表</strong></li>
<li>什么时候用有序数组？满足两个条件：<ul>
<li>存储的数据<strong>全为数字</strong></li>
<li>总个数<strong>不超过512</strong></li>
</ul>
</li>
<li>有序集合的底层数据结构：数据少用<strong>压缩列表</strong>；数据多用<strong>跳表</strong></li>
<li>跳表的实现细节：<ul>
<li>给链表隔一个元素建一个索引，在给索引隔一个建一个索引，直到最顶层建了两个索引为止</li>
<li>插入、删除、查询都很快</li>
<li>**时间复杂度：O(log n)**（再细一点，如果是隔一个建立一个索引，那么时间复杂度是O(3 log n)）</li>
<li>通过一个<strong>随机函数</strong>来保持平衡（随机函数的选择很重要，但是不需要深究）</li>
</ul>
</li>
<li><strong>为什么使用跳表而不是红黑树</strong>？两个原因：<ul>
<li>跳表实现相对来说<strong>简单</strong></li>
<li>红黑树的<strong>范围查询</strong>性能没有跳表好</li>
</ul>
</li>
<li>数据的持久化：<ul>
<li><strong>RDB</strong>：默认的方式，隔一段时间，就将当前redis库内的所有元素写入磁盘</li>
<li><strong>AOF</strong>：日志记录的方式</li>
</ul>
</li>
<li>各类数据结构的应用场景：<ul>
<li>字符串：可以<strong>统计网站人数</strong>、可以实现分布式锁（用<code>setnx</code>）</li>
<li>列表：可以实现栈、实现队列、<strong>实现消息队列</strong></li>
<li>哈希：可以实现一个<strong>购物车</strong></li>
<li>集合：可以实现社交领域发现<strong>共同好友</strong>、发现用户共同兴趣等</li>
<li>有序集合：可以实现一个直播的<strong>动态排行榜</strong></li>
</ul>
</li>
</ol>
<h1 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h1><p>随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题</p>
<p>redis作为非关系型数据库的一员，在web2.0的交互中展露枝头</p>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>例如：</p>
<ul>
<li>Oracle</li>
<li>MySQL</li>
</ul>
<p>是指采用了<strong>关系模型来组织数据</strong>的数据库，其以行和列的形式存储数据，以便于用户理解，关系型数据库这一系列的行和列被称为表，一组表组成了数据库。</p>
<p>特点：</p>
<ol>
<li>数据之间有关联关系</li>
<li>数据存储在硬盘的文件上</li>
<li>表现为一个个的表格</li>
</ol>
<h3 id="非关系型数据库-NOSQL"><a href="#非关系型数据库-NOSQL" class="headerlink" title="非关系型数据库(NOSQL)"></a>非关系型数据库(NOSQL)</h3><p>例如：</p>
<ul>
<li>redis</li>
<li>hbase</li>
<li>mongdb</li>
</ul>
<p>区别于关系数据库，它们<strong>不保证关系数据的ACID特性</strong>。（ACID指关系型数据库的原子性，一致性，隔离性，持久性）相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</p>
<p>但是一个共同的特点都是去掉关系数据库的关系型特性。<br>NoSQL有如下优点：<strong>易扩展，NoSQL数据库种类繁多</strong></p>
<p>特点：</p>
<ol>
<li>数据之间没有关系</li>
<li>数据存储在内存中</li>
<li>表现为<code>key:value</code>的形式</li>
</ol>
<h3 id="NOSQL与关系型数据库的比较"><a href="#NOSQL与关系型数据库的比较" class="headerlink" title="NOSQL与关系型数据库的比较"></a>NOSQL与关系型数据库的比较</h3><p>优点：</p>
<ol>
<li>成本：NOSQL数据库简单易部署，基本都是开源软件，相比关系型数据库成本低廉</li>
<li>查询速度：NOSQL存储在缓存当中，查询速度非常快</li>
<li>存储格式为：<code>key:value</code>形式，文档形式，图片形式等，所以可以基础类型以及对象或是集合等格式，而关系型数据库只能存储基础类型</li>
</ol>
<p>缺点：</p>
<ol>
<li>维护的工具和资料有限：因为NOSQL属于新的技术，而关系型数据库已经有十几年的技术</li>
<li>不提供对SQL的支持：不支持SQL这样的工业标准，将产生一定用户的学习和使用成本，例如redis与hbase差别很大，而Oracle与mysql差别就很小</li>
<li><strong>不提供关系型数据库对事务的处理</strong></li>
</ol>
<p>我们一般将数据存储在关系型数据库中，在NOSQL数据库中备份存储关系型数据库的数据</p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="初识Redis"><a href="#初识Redis" class="headerlink" title="初识Redis"></a>初识Redis</h2><blockquote>
<p>Redis：<strong>Remote Dictionary Server 远程字典服务</strong></p>
<p>redis是一款高性能的NOSQL系列的非关系型数据库</p>
</blockquote>
<p>redis是用<strong>c语言</strong>开发的<strong>高性能键值对数据库</strong></p>
<p>常见的应用场景：</p>
<ol>
<li><strong>缓存</strong>（数据查询，短连接，新闻内容，商品内容等等）</li>
<li>聊天室的在线好友列表</li>
<li>任务队列（秒杀、抢购、12306等）</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理</li>
<li>分布式集群架构中的session分离</li>
</ol>
<h2 id="两大维度、三大主线"><a href="#两大维度、三大主线" class="headerlink" title="两大维度、三大主线"></a>两大维度、三大主线</h2><p>三大主线：<strong>高性能、高可靠、高可扩展</strong></p>
<p>两大维度：<strong>应用维度、系统维度</strong></p>
<p><img src="http://img.yesmylord.cn//image-20210827162458198.png" alt="Redis与三高"></p>
<h2 id="redis不同数据的操作"><a href="#redis不同数据的操作" class="headerlink" title="redis不同数据的操作"></a>redis不同数据的操作</h2><p>本节是关于Redis的命令操作</p>
<h3 id="redis数据库操作"><a href="#redis数据库操作" class="headerlink" title="redis数据库操作"></a>redis数据库操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ping //测试一个连接是否还可用，如果不加任何内容返回pong，加了内容返回它本身</span><br><span class="line">select [index] // 切换数据库[1-15]</span><br><span class="line">dbsize //查看当前数据库大小</span><br><span class="line">keys * // 查看所有的key</span><br><span class="line">flushdb // 清除当前数据库</span><br><span class="line">flushall // 清除全部数据库的内容</span><br><span class="line">exist key // 是否存在这个key</span><br><span class="line">expire key [n] // 设置过期时间(默认为秒)</span><br><span class="line">ttl key // 查看key的过期时间</span><br><span class="line">type key //查看当前key的类型</span><br></pre></td></tr></table></figure>

<h3 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h3><p>支持的五大数据结构：</p>
<ol>
<li>字符串类型 <code>string</code></li>
<li>哈希类型 <code>hash</code></li>
<li>列表类型 <code>list</code></li>
<li>集合类型 <code>set</code></li>
<li>有序集合类型 <code>sortedset</code> (Zset)</li>
</ol>
<p>另外还能存储几种特殊数据结构：</p>
<ol>
<li>HyperLogLogs：省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数的页面实时UV、在线用户数，共同好友数等</li>
<li>Bitmap：两个状态的，都可以使用 Bitmap，比如登录未登录、性别</li>
<li>geospatial ：推算地理位置的信息: 两地之间的距离, 方圆几里的人；底层是Zset，有序列表</li>
<li>stream：用于消息队列和发布/订阅模式</li>
</ol>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><h4 id="Redis中的字符串"><a href="#Redis中的字符串" class="headerlink" title="Redis中的字符串"></a>Redis中的字符串</h4><ul>
<li><code>string</code>类型是<strong>二进制安全</strong>的，意思是 <code>Redis</code> 的 <code>string</code> 可以包含任何数据（图片、对象等等）</li>
<li>key最大可以是512Mb</li>
</ul>
<p>基本的操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set key value // 存储</span><br><span class="line">get key //查找</span><br><span class="line">del key //删除</span><br></pre></td></tr></table></figure>

<p>追加与长度获取</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">append key xxx // 给一个key追加字符串</span><br><span class="line">strlen key // 查看这个key的长度</span><br></pre></td></tr></table></figure>

<p>自增与自减（可以使用这个来进行计数，比如统计系统在线人数）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">incr key // 给一个key的值+1（必须是数值）</span><br><span class="line">decr key // 给一个key的值-1</span><br><span class="line">incrby key n // 步长为n +n</span><br><span class="line">decrby key n // 步长为n -n</span><br></pre></td></tr></table></figure>

<p>获取子串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getrange key [start] [end] //返回子串[start,end]，如果end是-1，代表末尾</span><br><span class="line">setrange key [index] [newStr] // 将从index开始用newStr替换原来的字符串</span><br></pre></td></tr></table></figure>

<p>ex与nx（setnx可以实现分布式锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setex key [second] [value] // 设置值附带过期时间</span><br><span class="line">setnx key value// 如果不存在此key，则设置；存在则不设置（分布式设置乐观锁）</span><br></pre></td></tr></table></figure>
<p>批量操作（<strong>原子操作</strong>，但注意，Redis单线程，如果一次传输数据太多，会导致Redis阻塞或者网络拥塞）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mset key1 value1 k2 v2 k3 v3 // 批量创建</span><br><span class="line">mget k1 k2 k3 k4 //批量获取</span><br><span class="line">msetnx // 不存在则设置也支持批量</span><br></pre></td></tr></table></figure>

<p>存放对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset user:1:name zhangsan user:1:age 3 // mset 对象:&#123;id&#125;:field value</span><br></pre></td></tr></table></figure>

<p>getset</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getset //设置新值，返回旧值</span><br></pre></td></tr></table></figure>

<p>总结：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/xrq730/p/8944539.html">表格来自于</a></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
<th><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>SET</td>
<td>（1）将字符串值Value关联到Key（2）Key<strong>已关联则覆盖</strong>，无视类型（3）<strong>原本Key带有生存时间TTL，那么TTL被清除</strong></td>
<td>SET key value [EX seconds] [PX milliseconds] [NX|XX]</td>
</tr>
<tr>
<td>GET</td>
<td>（1）返回key关联的字符串值（2）<strong>Key不存在返回nil</strong>（3）Key存储的<strong>不是字符串，返回错误</strong>，因为GET只用于处理字符串</td>
<td>GET key</td>
</tr>
<tr>
<td>MSET</td>
<td>（1）同时设置一个或多个Key-Value键值对（2）某个给定Key已经存在，那么MSET新值会覆盖旧值（3）如果上面的覆盖不是希望的，那么使用MSETNX命令，所有Key都不存在才会进行覆盖（4）<strong>MSET是一个原子性操作</strong>，所有Key都会在同一时间被设置，不会存在有些更新有些没更新的情况</td>
<td>MSET key value [key value …]</td>
</tr>
<tr>
<td>MGET</td>
<td>（1）返回一个或多个给定Key对应的Value（2）某个Key不存在那么这个Key返回nil</td>
<td>MGET key [key …]</td>
</tr>
<tr>
<td>SETEX</td>
<td>（1）将Value关联到Key（2）设置Key生存时间为seconds，单位为秒（3）如果Key对应的Value已经存在，则覆盖旧值（4）SET也可以设置失效时间，但是不同在于SETNX是一个原子操作，即关联值与设置生存时间同一时间完成</td>
<td>SETEX key seconds value</td>
</tr>
<tr>
<td>SETNX</td>
<td>（1）将Key的值设置为Value，当且仅当Key不存在（2）若给定的Key已经存在，SEXNX不做任何动作</td>
<td>SETNX key value</td>
</tr>
</tbody></table>
<h4 id="Redis字符串的应用"><a href="#Redis字符串的应用" class="headerlink" title="Redis字符串的应用"></a>Redis字符串的应用</h4><p>应用场景：</p>
<p>Redis单线程，不需要考虑并发</p>
<ul>
<li><code>setnx</code>来设置分布式锁</li>
<li><code>incrby</code>进行计数、统计网站人数</li>
</ul>
<h3 id="哈希类型"><a href="#哈希类型" class="headerlink" title="哈希类型"></a>哈希类型</h3><p>以Java来理解，Redis的哈希类型就是<code>Map&lt;String, Map&lt;String, Object&gt;&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hset key field value <span class="comment">// 存储</span></span><br><span class="line">hget key field <span class="comment">//获取对应的value</span></span><br><span class="line">hgetall key  <span class="comment">//获取所有的键和值</span></span><br><span class="line">hdel key field <span class="comment">//删除</span></span><br></pre></td></tr></table></figure>
<p>redis-cli示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//设置</span><br><span class="line">127.0.0.1:6379&gt; hset person name zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset person user lisi</span><br><span class="line">(integer) 1</span><br><span class="line">//获取</span><br><span class="line">127.0.0.1:6379&gt; hget person name</span><br><span class="line">&quot;zhangsan&quot;</span><br><span class="line">127.0.0.1:6379&gt; hget person user</span><br><span class="line">&quot;lisi&quot;</span><br><span class="line">//获取所有</span><br><span class="line">127.0.0.1:6379&gt; hgetall person</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;user&quot;</span><br><span class="line">4) &quot;lisi&quot;</span><br><span class="line">//删除</span><br><span class="line">127.0.0.1:6379&gt; del person name</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; del person user</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hgetall person</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure>

<h3 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h3><h4 id="Redis中的list"><a href="#Redis中的list" class="headerlink" title="Redis中的list"></a>Redis中的list</h4><p>redis内的列表是一个<strong>横向的列表</strong>，可以<strong>添加到左边或者右边</strong></p>
<p>redis列表是一个有序的列表，而且可以重复</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加</span></span><br><span class="line">lpush key value <span class="comment">//将元素加入列表左边</span></span><br><span class="line">rpush key value <span class="comment">//将元素加入列表右边</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">lrange key start end <span class="comment">//范围获取,从0开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">lpop key <span class="comment">//删除列表最左边的元素，并将元素返回</span></span><br><span class="line">rpop key <span class="comment">//删除列表最右边的元素，并将元素返回</span></span><br></pre></td></tr></table></figure>
<p>redis-cli示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//添加到list</span><br><span class="line">127.0.0.1:6379&gt;  lpush list a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush list b</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; rpush list c</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 //end为-1代表查找所有</span><br><span class="line">1) &quot;b&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;c&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop list</span><br><span class="line">&quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpop list</span><br><span class="line">&quot;c&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Redis列表的应用"><a href="#Redis列表的应用" class="headerlink" title="Redis列表的应用"></a>Redis列表的应用</h4><p>Redis的列表特点：有左右、有序、可重复</p>
<ul>
<li>实现栈（<code>lpush</code>、<code>lpop</code>）</li>
<li>实现队列（<code>lpush</code>、<code>rpop</code>）</li>
<li>实现消息队列（<code>lpush</code>、<code>brpop</code>）</li>
</ul>
<blockquote>
<p><code>brpop</code>命令：移出并获取列表的最后一个元素， 如果列表<strong>没有元素会阻塞列表</strong>直到等待超时或发现可弹出元素为止。</p>
</blockquote>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><h3 id="Redis集合类型"><a href="#Redis集合类型" class="headerlink" title="Redis集合类型"></a>Redis集合类型</h3><p>特点：</p>
<ul>
<li><p>不允许重复</p>
</li>
<li><p>无序</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//存储</span><br><span class="line">sadd key value</span><br><span class="line">//获取</span><br><span class="line">smembers key</span><br><span class="line">//删除</span><br><span class="line">srem key</span><br></pre></td></tr></table></figure>
<p>redis示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> 127.0.0.1:6379&gt; sadd myset a b c d e f g</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;g&quot;</span><br><span class="line">4) &quot;c&quot;</span><br><span class="line">5) &quot;a&quot;</span><br><span class="line">6) &quot;e&quot;</span><br><span class="line">7) &quot;f&quot;</span><br><span class="line">127.0.0.1:6379&gt; srem myset g</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a a b b</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">4) &quot;e&quot;</span><br><span class="line">5) &quot;b&quot;</span><br><span class="line">6) &quot;f&quot;</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Redis集合的应用"><a href="#Redis集合的应用" class="headerlink" title="Redis集合的应用"></a>Redis集合的应用</h4><p>可以利用集合的并、交特性，在社交领域，可以求共同好友、发现用户共同兴趣等</p>
<h3 id="有序集合类型"><a href="#有序集合类型" class="headerlink" title="有序集合类型"></a>有序集合类型</h3><h4 id="Redis有序集合Zset"><a href="#Redis有序集合Zset" class="headerlink" title="Redis有序集合Zset"></a>Redis有序集合Zset</h4><p>特点：</p>
<ul>
<li>不允许重复</li>
<li>有序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//存储,存储数据以及数据对应的值</span><br><span class="line">zadd key score value </span><br><span class="line">//获取</span><br><span class="line">zrange key start end</span><br><span class="line">//删除 </span><br><span class="line">zrem key value</span><br></pre></td></tr></table></figure>
<p>redis示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  zadd mysort 60 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange mysort</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;zrange&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;zhangsan&quot;</span><br><span class="line">3) &quot;wangwu&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1 withscores//带上withscore会显示分数</span><br><span class="line">1) &quot;lisi&quot;</span><br><span class="line">2) &quot;50&quot;</span><br><span class="line">3) &quot;zhangsan&quot;</span><br><span class="line">4) &quot;60&quot;</span><br><span class="line">5) &quot;wangwu&quot;</span><br><span class="line">6) &quot;80&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Redis有序集合的应用"><a href="#Redis有序集合的应用" class="headerlink" title="Redis有序集合的应用"></a>Redis有序集合的应用</h4><p>可以做排行榜、也可以用于社交领域</p>
<h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><p>Redis的底层数据结构，支持了上一节五大基本结构的使用</p>
<p><img src="http://img.yesmylord.cn//image-20210827170121523.png" alt="redis底层数据结构"></p>
<ul>
<li>String：简单动态字符串（注意：<strong>String也有第二个数据结构</strong>：当你<strong>保存的是一个64位有符号整数时，String会保存为一个8字节的Long类型整数</strong>，这也叫int编码方式）</li>
<li>List：压缩列表；双向链表</li>
<li>Hash：压缩列表；散列表</li>
<li>Set：整数数组；散列表</li>
<li>Sorted Set：压缩列表；跳表</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJECT ENCODING [key] # 此命令可以查看底层的数据结构 </span><br></pre></td></tr></table></figure>

<h3 id="SDS简单动态字符串"><a href="#SDS简单动态字符串" class="headerlink" title="SDS简单动态字符串"></a>SDS简单动态字符串</h3><p>使用自己构建的名为<strong>SDS(Simple  dynamic string)简单动态字符串</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> len; <span class="comment">//记录字符串长度</span></span><br><span class="line">     <span class="type">int</span> <span class="built_in">free</span>; <span class="comment">// 记录未使用的字节数</span></span><br><span class="line">     <span class="type">char</span> buf[];<span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如此的结构，极大的提高了性能：</p>
<p><img src="http://img.yesmylord.cn//image-20210811193928235.png" alt="SDS结构示意"></p>
<ol>
<li><strong>O(1)级别获取字符串长度</strong>；在C中，需要进行遍历，为O(n)</li>
<li><strong>杜绝缓冲区溢出</strong>；C中，进行strcat等字符串操作，如果没有分配足够长度空间，容易导致缓冲区溢出；而对于SDS数据类型，字符串修改会首先根据len属性检查内存是否符合要求</li>
<li>减少修改字符串的内存重新分配次数；SDS可以进行<strong>空间预分配</strong>与<strong>惰性空间释放</strong><ul>
<li>空间预分配：当字符串扩展时，会扩展更大的空间</li>
<li>惰性释放：当字符串缩小，会增大<code>free</code>的值，但是空间不一定会跟着变化</li>
</ul>
</li>
<li><strong>二进制安全</strong>：C中使用<code>/0</code>空字符作为字符串结束位，但是对于图片等二进制文件，内容可能有空字符，因此SDS用<code>len</code>来判断字符串是否结束</li>
<li>兼容部分C字符串函数：使用C语言实现，可以兼容部分C的API</li>
</ol>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><blockquote>
<p>压缩列表：</p>
<p>​        通过一片连续的内存空间来存储数据（类似于C的数组）</p>
<p>​        但是和数组的区别是，存放的数据大小允许不同</p>
</blockquote>
<p>压缩列表的特点：</p>
<ul>
<li>压缩列表在表头有三个字段 <code>zlbytes</code>、<code>zltail </code>和 <code>zllen</code>，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 <code>zlend</code>，表示列表结束。</li>
<li>如果我们要查找定位<strong>第一个元素和最后一个元素</strong>，可以通过表头三个字段 的长度直接定位，**复杂度是 O(1)**。</li>
<li>而查找<strong>其他元素</strong>时，就没有这么高效了，只能逐个查找，此时的复杂度就是 <strong>O(N)</strong> 了。</li>
</ul>
<p>优点：</p>
<ol>
<li>允许存储不同类型的数据</li>
<li>节省空间</li>
</ol>
<blockquote>
<p><strong>Redis什么时候使用压缩列表的实现？</strong></p>
</blockquote>
<p>在<strong>数据量小</strong>的时候才会使用，需要同时满足：</p>
<ol>
<li>保存的<strong>单个数据小于64字节</strong></li>
<li>列表中的<strong>数据总个数小于512个</strong></li>
</ol>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><blockquote>
<p>双向循环链表：</p>
<p>​        Redis的list结构体额外定义一个list的结构体</p>
</blockquote>
<p>链表节点：（这与基本的双向列表一样）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">       <span class="comment">//前置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">       <span class="comment">//后置节点</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">       <span class="comment">//节点的值</span></span><br><span class="line">       <span class="type">void</span> *value;  </span><br><span class="line">&#125;listNode</span><br></pre></td></tr></table></figure>

<p><strong>双向链表</strong>：（额外定义list的结构体）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">     <span class="comment">//表头节点</span></span><br><span class="line">     listNode *head;</span><br><span class="line">     <span class="comment">//表尾节点</span></span><br><span class="line">     listNode *tail;</span><br><span class="line">     <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">     <span class="comment">//节点值复制函数</span></span><br><span class="line">     <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值释放函数</span></span><br><span class="line">     <span class="type">void</span> (*<span class="built_in">free</span>) (<span class="type">void</span> *ptr);</span><br><span class="line">     <span class="comment">//节点值对比函数</span></span><br><span class="line">     <span class="type">int</span> (*match) (<span class="type">void</span> *ptr,<span class="type">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>双端：双向链表，获取头尾元素均为O(1)</li>
<li>无环：头尾均指向NULL</li>
<li>带链表长度计数器：获取链表长度为O(1)</li>
<li>多态：链表节点使用<code>void*</code>指针，可以保存不同元素</li>
</ul>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p><strong>散列表</strong></p>
<p>哈希算法：Redis 使用 <strong>MurmurHash2</strong>这种运行速度快、随机性好的哈希算法作为哈希函数</p>
<p>哈希冲突解决：<strong>拉链法</strong></p>
<p>当<strong>数据动态增加之后，散列表的装载因子会不停地变大</strong>。为了避免散列表性能的下降：</p>
<p><code>装载因子 = 已存储元素数量 / 哈希表大小</code></p>
<ul>
<li><p>当<strong>装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右</strong></p>
</li>
<li><p>为了节省内存，当<strong>装载因子小于 0.1 的时候，Redis 就会触发缩容， 缩小为字典中数据个数的大约 2 倍大小</strong></p>
</li>
</ul>
<p>（2倍左右，是估计值！）</p>
<h3 id="有序数组"><a href="#有序数组" class="headerlink" title="有序数组"></a>有序数组</h3><blockquote>
<p><strong>什么时候使用有序数组</strong>？</p>
</blockquote>
<ul>
<li>存储的<strong>数据都是整数</strong></li>
<li>存储的<strong>数据元素个数不超过512个</strong></li>
</ul>
<p>在集合中如果不满足这些，就用<strong>散列表</strong>实现集合</p>
<blockquote>
<p>整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么 Redis 还会把它 们作为底层数据结构呢？</p>
</blockquote>
<p>虽然没有什么时间复杂度的优势，但是胜在其使用数组，有两个特点：</p>
<ul>
<li>节省空间</li>
<li>没有内存碎片</li>
</ul>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><blockquote>
<p>跳表：一个链表，为了提高它的查询速度，隔一个设置一个索引，用来加快查找，为了加快索引的搜索，再对索引隔一个设置一个索引</p>
<p>每一层索引都是一个链表，这样构成的数据结构就是跳表</p>
</blockquote>
<p><img src="http://img.yesmylord.cn//image-20210823092749357.png" alt="跳表"></p>
<p>特点：</p>
<ol>
<li>由很多层结构组成；</li>
<li>每一层都是一个有序的链表，排列顺序为由高层到底层，都<strong>至少包含两个链表节点</strong></li>
<li>最底层的链表包含了所有的元素；</li>
<li>如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；</li>
<li>链表中的<strong>每个节点都包含两个指针</strong><ul>
<li>一个指向<strong>同一层</strong>的下一个链表节点</li>
<li>另一个指向<strong>下一层</strong>的同一个链表节点；</li>
</ul>
</li>
<li>插入、删除、查询都很快</li>
<li>通过随机函数来维护自平衡</li>
</ol>
<blockquote>
<p>有多快？</p>
</blockquote>
<p>如果总共有 n个 节点</p>
<p>那么会建立log2N的高度的节点</p>
<p>查询一个数据的时间复杂度为<code>O(m*log n)</code></p>
<p>m 是多少？ m=3，<strong>因为每一层最多遍历三个节点</strong>（因为索引是隔一个抽一个建立起来的）</p>
<blockquote>
<p>如何维护自平衡？通过一个<strong>随机函数</strong></p>
</blockquote>
<p>比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<p>随机函数的选择比较重要，这也比较复杂，我们无需研究。</p>
<blockquote>
<p>为什么选跳表不用红黑树？</p>
</blockquote>
<ol>
<li><strong>按照区间来查找</strong>数据这个操作，红黑树的效率没有跳表高（虽然增删查的时间复杂度一样）</li>
<li><strong>跳表更容易实现</strong>（相比较而言简单）</li>
</ol>
<h3 id="为什么SortedSet用跳表？"><a href="#为什么SortedSet用跳表？" class="headerlink" title="为什么SortedSet用跳表？"></a>为什么SortedSet用跳表？</h3><p>跳表的数据结构可以看做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 存放跳转的索引</span></span><br><span class="line">    <span class="keyword">private</span> Node[] forwards = <span class="keyword">new</span> <span class="title class_">Node</span>[MAX_LEVEL];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxLevel</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跳表式依赖于<strong>概率算法</strong>的：比如现在要新加入一个节点，需要决定该节点的<strong>层级</strong></p>
<p>理论上来讲，一级索引应该占50%，二级索引占25%，三级索引占12.5%等等以此类推</p>
<p>决定当前节点层级是通过随机来决定的，晋升的概率为1/2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">PROB</span> <span class="operator">=</span> <span class="number">0.5</span> f;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果随机数大于0.5，就允许晋升</span></span><br><span class="line">    <span class="keyword">while</span> (Math.random() &gt; PROB &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于有序Set来说，一般需要支持的操作有：</p>
<ol>
<li>增</li>
<li>删</li>
<li>查一个数据</li>
<li>查区间数据</li>
</ol>
<p>红黑树与跳表比较来说，对于前三个操作基本一致，但是查区间数据会慢一些，且实现要比跳表难一些。</p>
<blockquote>
<p>为什么跳表范围查询比红黑树快？</p>
</blockquote>
<p>红黑树是老老实实一级一级查的，但是跳表是顺序和跳跃的结合，这使得跳表可以快速跳跃到目标区间的起点，而一旦找到起点后，可以直接顺序遍历底层链表。</p>
<h2 id="深入Redis数据结构"><a href="#深入Redis数据结构" class="headerlink" title="深入Redis数据结构"></a>深入Redis数据结构</h2><h3 id="占内存的String"><a href="#占内存的String" class="headerlink" title="占内存的String"></a>占内存的String</h3><p>前面说了String的底层，由SDS构成，但其实，String类有很深的门道，这节我们来说一下</p>
<hr>
<p>String有三种编码方式：</p>
<ul>
<li><code>int</code>编码：在<strong>保存64位有符号整数时</strong></li>
<li><code>embstr</code>编码：在保存的字符串<strong>小于44字节时</strong></li>
<li><code>raw</code>编码：<strong>大于44字节时</strong></li>
</ul>
<p>下图是RedisObejct的示意图</p>
<p><img src="http://img.yesmylord.cn//image-20210829160053093.png" alt="三种编码在内存中的示意图"></p>
<p>可见，三种编码方式，在内存中的实现是不一样的，int编码的数据就直接在指针里放着，节省内存；<code>embstr</code>的SDS在内存中与<code>RedisObejct</code>紧挨着（这样可以避免内存碎片）</p>
<hr>
<p>这里额外补充一下：</p>
<ul>
<li><p>RedisObejct是记录数据是什么类型的结构体，由两部分组成，<strong>元数据与类型指针</strong></p>
</li>
<li><p>对于全局哈希表，它的每一项都是一个DictEntry结构体，这个结构体存放三个数据（下一节）：key、value、next</p>
</li>
</ul>
<p>内存结构是这么存的：</p>
<p><img src="http://img.yesmylord.cn//image-20210829164359348.png" alt="存储结构"></p>
<blockquote>
<p>假如我们用String保存2个10位的数，会消耗多少内存呢？</p>
</blockquote>
<p>由于存10的数字，所以会直接占用指针的8个字节，元数据用8个字节，共有两个会占用32字节；</p>
<p>DictEntry占24字节，但是Redis 使用的内存分配库 jemalloc只会分配2的幂次的大小，所以分配32字节</p>
<p>所以占用了64字节，但是有效的信息，只有16字节，<strong>所以说String的开销很大！</strong>利用率不高</p>
<h3 id="使用压缩列表"><a href="#使用压缩列表" class="headerlink" title="使用压缩列表"></a>使用压缩列表</h3><p>String消耗内存很多，当存的数据只是简单的数字时，越多String消耗的空间越大，但实际上根本没有利用多少</p>
<p>压缩列表就是一个很节省内存的例子</p>
<hr>
<p>压缩列表在表头有三个字段 <code>zlbytes</code>、<code>zltail </code>和 <code>zllen</code>，分别表示列表长度、列表尾的偏移量和列表中的<code> entry</code> 个数；压缩列表在表尾还有一个 <code>zlend</code>，表示列表结束</p>
<p>压缩列表的每一个<code>entry</code>，由四个部分构成：<code>prev_len</code>、<code>encoding</code>、<code>len</code>、<code>content</code></p>
<ul>
<li><code>prev_len</code>：表示前一个entry的长度，只有两种取值情况，要么占1B、要么占5B<ul>
<li>如果上一个entry小于254字节，那么就取1B；否则取5B</li>
</ul>
</li>
<li><code>encoding</code>：编码方式，1B</li>
<li><code>len</code>：表示自身长度，占4B</li>
<li><code>content</code>：保存实际数据</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210829170946602.png" alt="压缩列表结构"></p>
<p>用一个RedisObejct，就可以存一堆数，这可比存一个数就要一个RedisObejct的String要省内存多了</p>
<blockquote>
<p><strong>Redis什么时候使用压缩列表的实现？</strong></p>
</blockquote>
<p>在<strong>数据量小</strong>的时候才会使用，需要同时满足：</p>
<ol>
<li>保存的<strong>单个数据小于64字节</strong></li>
<li>列表中的<strong>数据总个数小于512个</strong></li>
</ol>
<p>这两个参数都可以调节</p>
<h2 id="全局哈希表"><a href="#全局哈希表" class="headerlink" title="全局哈希表"></a>全局哈希表</h2><p>Redis使用了<strong>两个全局哈希表</strong></p>
<blockquote>
<p>全局哈希表：如图，value为一个一个节点，节点才会去存真正的数据类型</p>
</blockquote>
<p><img src="http://img.yesmylord.cn//image-20210827183749301.png" alt="全局哈希表"></p>
<p>这个全局的哈希表中，每一项是一个<strong>dictEntry节点</strong>，这个dictEntry结构体包含三个部分（图中只画了两个）：key、value、next（指向下一个dictEntry）</p>
<p>那么这里有几个问题，带着问题来思考</p>
<blockquote>
<p>全局哈希表如何解决哈希碰撞？</p>
</blockquote>
<p>是使用拉链法来解决哈希冲突的</p>
<blockquote>
<p>如果拉链变的十分长，导致查询速度下降，那么Redis是怎么保证高性能呢？</p>
</blockquote>
<p>​        当Redis发现存放的数据达到一定程度，就会进行<code>rehash</code>，使用两个哈希表来进行交替，这样即使在rehash过程中，也不会无法进行服务</p>
<blockquote>
<p>rehash的过程</p>
</blockquote>
<ol>
<li>给哈希表2分配更大的空间（比如是哈希表1的两倍）</li>
<li>将哈希表1的数据<strong>重新映射</strong>并拷贝到哈希表2中</li>
<li>释放哈希表1的空间</li>
</ol>
<p>如果哈希表2再满了，那么再次重复这个过程</p>
<blockquote>
<p>渐进式rehash</p>
</blockquote>
<p>如果真的采用上面的rehash过程，那么在2步过程中，由于copy浪费的时间，将导致redis不能进行服务</p>
<p>所以Redis是<strong>渐进式rehash</strong>的（即每次的请求，都捎带着copy一个桶上的索引）</p>
<p><img src="http://img.yesmylord.cn//image-20210827184500617.png" alt="渐进式rehash"></p>
<p>可以保证在copy过程中，也能继续保持服务</p>
<h2 id="单线程数据库Redis"><a href="#单线程数据库Redis" class="headerlink" title="单线程数据库Redis"></a>单线程数据库Redis</h2><blockquote>
<p>Redis是单线程的吗？</p>
</blockquote>
<p>严格意义上来说，Redis不是单线程的；</p>
<p>常说的Redis是单线程，是指其提供的<strong>网络IO 和 键值对读写是由一个线程</strong>来完成的</p>
<blockquote>
<p>为什么使用单线程？</p>
</blockquote>
<p>多线程其实并不会快很多，对于一些共享数据，多线程需要加锁进行操作，这种情况下，多线程的性能不会比单线程高，只会让设计上更加复杂</p>
<blockquote>
<p>为什么使用单线程，Redis还这么快？</p>
</blockquote>
<p>几方面原因：</p>
<ul>
<li>处理方面：redis是单线程的，单线程无需考虑并发操作，无需加锁</li>
<li>内存方面：redis的底层数据结构比较快，比如跳表</li>
<li>持久化方面：有AOF这种快速的日志机制。</li>
<li>网络方面：使用epoll网络编程模型</li>
</ul>
<h2 id="多路复用机制"><a href="#多路复用机制" class="headerlink" title="多路复用机制"></a>多路复用机制</h2><p>以一个Redis的GET请求为例，基本的IO模型如图</p>
<p><img src="http://img.yesmylord.cn//image-20210827190636594.png" alt="基本IO模型"></p>
<p>整个过程如下</p>
<ol>
<li>Redis要先监听客户端请求（bind/listen）</li>
<li><strong>建立连接（accept）</strong></li>
<li><strong>读取请求（recv）</strong></li>
<li>解析客户端发送的请求（parse）</li>
<li>从数据库获取数据（get）</li>
<li>返回发送给客户端（send）</li>
</ol>
<p>其中2与3是阻塞点</p>
<p>（2：redis监听到连接请求，但是一直未能成功连接，导致其他客户端无法与redis连接；3：读取的数据如果一直没有到达，也会造成阻塞）</p>
<blockquote>
<p>如何解决基本的网络IO带来的阻塞？</p>
</blockquote>
<p>Socket网络模型支持<strong>非阻塞模式</strong></p>
<blockquote>
<p>非阻塞：即在遇到阻塞后，不在原地等待，而是先去执行其他操作，隔段时间再来观察是否还阻塞</p>
</blockquote>
<p>Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上：</p>
<table>
<thead>
<tr>
<th>调用方法</th>
<th>返回套接字类型</th>
<th>非阻塞模式</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><code>socket()</code></td>
<td>主动套接字</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>listen()</code></td>
<td>监听套接字</td>
<td>可设置</td>
<td><code>accept()</code>非阻塞</td>
</tr>
<tr>
<td><code>accept()</code></td>
<td>已连接套接字</td>
<td>可设置</td>
<td><code>send()/recv()</code>非阻塞</td>
</tr>
</tbody></table>
<ol>
<li><p><code>socket()</code>方法会返回主动套接字</p>
</li>
<li><p>然后调用 <code>listen() </code>方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求</p>
</li>
<li><p>调用 <code>accept()</code> 方法接收到达的客户端连接，并返回已连接套接字</p>
</li>
</ol>
<p>因为可以设置非阻塞，所以Redis在<code>accept()</code>或<code>recv()</code>迟迟没有得到反映，就可以先进行其他操作</p>
<hr>
<p>虽然Redis可以不继续等待，但是总得有机制在监听套接字上等待，这就用到了Linux的<strong>IO多路复用机制</strong></p>
<blockquote>
<p>多路复用机制：</p>
<p>​        IO 多路复用机制是指<strong>一个线程处理多个 IO 流</strong>，就是我们经常听到的 <strong>select/epoll 机制</strong></p>
</blockquote>
<blockquote>
<p>select/epoll 机制：可以快速看一下这篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35433716/article/details/85345907?ops_request_misc=&request_id=&biz_id=102&utm_term=epoll%20&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-85345907.nonecase&spm=1018.2226.3001.4187">blog</a>，图画的非常nice，一眼就懂了</p>
</blockquote>
<p>这里贴一下图，图源在上面已经说了</p>
<ul>
<li><strong>select</strong>：<ul>
<li>处理所有的fd，进行挨个询问</li>
<li><strong>水平触发</strong>：如果不处理，下次会继续通知</li>
</ul>
</li>
<li><strong>epoll</strong>：<ul>
<li>所只处理那些就绪的fd</li>
<li>支持<strong>水平触发</strong>与<strong>边缘触发</strong>：只通知一次，如果我没有处理，只有到下次状态发生实际变化才会通知</li>
</ul>
</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210827192922183.png" alt="select"></p>
<p><img src="http://img.yesmylord.cn//image-20210827192952173.png" alt="epoll"></p>
<p>Redis中的高性能IO模型</p>
<p><img src="http://img.yesmylord.cn//image-20210827193136348.png" alt="图源自极客时间"></p>
<blockquote>
<p>回调机制：</p>
<p>​        select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数</p>
</blockquote>
<p>​        这些事件会被放进一个<strong>事件队列</strong>，Redis 单线程对该事件队列不断进行处理。</p>
<p>​        这样一来， Redis <strong>无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费</strong>。</p>
<h2 id="AOF详解"><a href="#AOF详解" class="headerlink" title="AOF详解"></a>AOF详解</h2><p>redis是一个内存数据库，储存在内存当中，关闭后数据会丢失，但是Redis提供了两种持久化方式：RDB、AOF</p>
<hr>
<blockquote>
<p>AOF (Append Only File)： 日志记录的方式，可以记录每一条命令的操作，可以每一次命令操作后，持久化数据</p>
</blockquote>
<p>AOF日志的工作比较特殊，不同于传统的WAL，<strong>他是先执行操作，再写数据</strong></p>
<blockquote>
<p>为什么AOF日志要先执行操作，后写入日志呢？</p>
</blockquote>
<p>好处有两个：</p>
<ol>
<li><strong>避免检查语法错误</strong>：因为只有执行成功，才会被写入日志</li>
<li>命令执行后再写，<strong>不会阻塞当前的操作</strong></li>
</ol>
<p>不过有两个潜在的风险：</p>
<ol>
<li>如果操作执行完，宕机，会导致日志上并没有记录（数据会丢失，不再可以使用日志进行恢复）</li>
<li>虽然避免了阻塞当前操作，但可能会阻塞下一个操作（因为写日志是需要操作磁盘的！）</li>
</ol>
<p>如果我们可以找好时机写入磁盘，那么这两个风险会好一点：Redis提供了三种写回策略</p>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>AOF 机制给我们提供了三个选择，也就是 AOF 配置项 <code>appendfsync</code> 的三个可选值：</p>
<ul>
<li><code>Always</code>：每一个操作都写回日志</li>
<li><code>Everysec</code>：每秒写回，先写在缓冲区，每隔一秒写回一次</li>
<li><code>No</code>：先写在缓冲区，操作系统控制何时写回</li>
</ul>
<table>
<thead>
<tr>
<th>配置项</th>
<th>写回时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>同步写回</td>
<td>可靠性好，数据基本不丢失</td>
<td>影响性能</td>
</tr>
<tr>
<td>Everysec</td>
<td>每秒写回</td>
<td>性能适中</td>
<td>宕机丢失1s数据</td>
</tr>
<tr>
<td>No</td>
<td>操作系统控制写回</td>
<td>性能好</td>
<td>宕机丢失数据较多</td>
</tr>
</tbody></table>
<p>不管哪一种写回方式，随着日志越写越多，终究会导致性能问题，所以AOF还提供了重写机制</p>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><blockquote>
<p>重写：就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件</p>
</blockquote>
<p>这个文件会比原来的小很多，因为<strong>它只记录结果！</strong></p>
<p><img src="http://img.yesmylord.cn//image-20210828204837179.png" alt="重写机制"></p>
<p>并且 和AOF 日志由主线程写回不同，<strong>重写过程是由后台线程 <code>bgrewriteaof</code> 来完成的</strong></p>
<p>重写的过程：一个拷贝、两个日志</p>
<p>​        一个拷贝：主线程fork出后台线程<code>bgrewriteaof</code>（<strong>注意：fork这一操作的过程是阻塞了主线程的！</strong>）</p>
<p>​        fork操作会把主线程的内存<strong>拷贝一份</strong>给 <code>bgrewriteaof</code> 子进程，这里面就包含了数据库的最新数据（也就是说，<strong>如果主线程的内存越大，这个拷贝的时间也会越长</strong>）</p>
<p>两个日志：</p>
<ul>
<li>正常使用的AOF日志</li>
<li>AOF重写日志</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210828205427565.png" alt="重写过程"></p>
<h2 id="RDB详解"><a href="#RDB详解" class="headerlink" title="RDB详解"></a>RDB详解</h2><p>另一种Redis的持久化方式</p>
<blockquote>
<p>RDB (Redis DataBase) ： <strong>默认方式</strong>，不需要进行配置，默认就使用这种机制，一定时间间隔，检测key的变化情况，然后持久化存储</p>
</blockquote>
<p>类似于快照，会将当前内存所处的状态，生成一个<strong>RDB文件</strong></p>
<p>和AOF比，<strong>RDB 记录的是某一时刻的数据</strong>，<strong>并不是操作</strong></p>
<p>所以，在做<strong>数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复</strong></p>
<h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 <code>save</code> 和 <code>bgsave</code>：</p>
<ul>
<li><code>save</code>：在主线程中执行，会导致阻塞； </li>
<li><code>bgsave</code>：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的<strong>默认配置</strong></li>
</ul>
<blockquote>
<p>在进行快照时，数据可以改变吗？</p>
</blockquote>
<p>可以改变，Redis采用COW（写时复制）的思想来实现备份时也可以服务</p>
<ul>
<li>如果是读操作：（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响</li>
<li>如果是写操作：（例如图中的键值对 C）， 那么，这块数据就会<strong>被复制一份，生成该数据的副本</strong>。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210828210222147.png" alt="COW"></p>
<h3 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h3><p>虽然RDB可以快速的进行恢复，而且也可以在备份时继续服务</p>
<p>但是隔多久进行一次快照并不好把控</p>
<ul>
<li>隔得时间短，影响性能</li>
<li>隔得时间长，如果宕机会丢失很多数据</li>
</ul>
<p>Redis提出了<strong>增量快照</strong></p>
<blockquote>
<p>增量快照：即在一次全量快照后，之后的更改只记录修改的部分</p>
</blockquote>
<h3 id="Redis4-0混合AOF与RDB"><a href="#Redis4-0混合AOF与RDB" class="headerlink" title="Redis4.0混合AOF与RDB"></a>Redis4.0混合AOF与RDB</h3><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。</p>
<p>简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作</p>
<p>这个方法<strong>既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势</strong></p>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>为了保证数据故障恢复时也可以进行服务（Redis为了可以提供服务操碎了心）Redis也有主从机制</p>
<h3 id="主从库模式"><a href="#主从库模式" class="headerlink" title="主从库模式"></a>主从库模式</h3><p>Redis主从库承担了不同的任务，采用<strong>读写分离</strong>的方式</p>
<ul>
<li>主库：负责读操作、<strong>写操作</strong></li>
<li>从库：<strong>只负责读操作</strong></li>
</ul>
<p>写操作只可以对主库进行</p>
<p><img src="http://img.yesmylord.cn//image-20210828211207985.png" alt="主从库"></p>
<blockquote>
<p>为什么要采用读写分离的方式？</p>
</blockquote>
<p>可以避免主从库之间进行数据协调，只需要让主库同步从库即可（如果都可以进行写操作，那么会很混乱）</p>
<h3 id="第一次同步"><a href="#第一次同步" class="headerlink" title="第一次同步"></a>第一次同步</h3><p>从库如何成为主库的从库？</p>
<p>一行代码即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实例2键入</span></span><br><span class="line">replicaof 172.16.19.3 6379</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实例2就变为了实例1的从库</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis 5.0之前用 slaveof命令</span></span><br></pre></td></tr></table></figure>

<p>第一次同步有三个阶段：</p>
<p><img src="http://img.yesmylord.cn//image-20210828211559390.png" alt="第一次同步过程"></p>
<ol>
<li><p>从库发起连接请求（<code>psync a b</code>包含两个参数，a为主库的<code>runId</code>，由于不知道主库<code>runID</code>，所以为<code>?</code>；b为复制进度，第一次复制为-1）；主库收到后，会使用<code>FULLRESYNC</code>命令，表示这是一次<strong>全量复制</strong></p>
</li>
<li><p>主库将所有数据同步（即一个RDB块）给从库。从库收到数据后，清除原本的数据，并在本地完成数据加载</p>
<p>（主库发送RDB后会在内存中用专门的 <code>replication buffer</code>，记录 收到新的写操作）</p>
</li>
<li><p>主库会把第二阶段执行过程中新收到的写命令，再发送给从库</p>
</li>
</ol>
<h3 id="主从级联模式"><a href="#主从级联模式" class="headerlink" title="主从级联模式"></a>主从级联模式</h3><p>如果主库频繁的从库创建RDB、发送RDB</p>
<p>这会影响主库的性能（因为fork会阻塞主线程，而且越大，fork所需要的时间会越长）</p>
<p>所以为了解决这个问题，有了<strong>主 - 从 - 从</strong>模式</p>
<p>即部署主从集群的时候，可以<strong>手动选择一个从库</strong>（比如选择内存资源配置 较高的从库），<strong>用于级联其他的从库</strong></p>
<p>这个从库就可以帮主库分担压力</p>
<p><img src="http://img.yesmylord.cn//image-20210828212414013.png" alt="主从从模式"></p>
<h3 id="网络闪断与repl-backlog-buffer缓存"><a href="#网络闪断与repl-backlog-buffer缓存" class="headerlink" title="网络闪断与repl_backlog_buffer缓存"></a>网络闪断与<code>repl_backlog_buffer</code>缓存</h3><blockquote>
<p>网络闪断：即网络不好，短短续续</p>
</blockquote>
<p>如果在Redis2.8版本之前，出现了网络闪断，在重新连接后，<strong>会重新进行一次全量复制</strong>，开销极大</p>
<p>Redis2.8版本之后，网络断了之后，主从库会采用<strong>增量复制</strong>的方式继续同步</p>
<p>​        当主从库断连后，主库会把断连期间收到的写操作命令，写入<code>replication buffer</code>，<strong>同时也会把这些操作命令也写入 <code>repl_backlog_buffer</code>这个缓冲区</strong></p>
<p><code>repl_backlog_buffer</code>是一个环形缓冲区，随着主库不断接收新的写操作，<strong>它在缓冲区中的写位置会逐步偏离起始位置</strong></p>
<p>这个缓存有两个指针：如图，分别为主库读的指针、从库读的指针</p>
<p><img src="http://img.yesmylord.cn//image-20210828213035116.png" alt="增量复制的实现"></p>
<p>连接恢复之后，从库首先会给主库发送 <code>psync </code>命令，并把自己当前的 <code>slave_repl_offset</code> 发给主库</p>
<p>主库会判断自己的 <code>master_repl_offset </code>和 <code>slave_repl_offset </code>之间的差距，只用把<code>master_repl_offset</code>和 <code>slave_repl_offset </code>之间的命令操作同步给从库就行</p>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p>主库提供了所有的写服务，如果主库挂掉，那么整个系统将陷入瘫痪</p>
<p>Redis使用哨兵机制，来解决这个问题</p>
<blockquote>
<p>Redis哨兵机制：在主库挂掉后，将从从库中选出一个作为新的主库</p>
</blockquote>
<h3 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h3><blockquote>
<p>哨兵：即运行在特殊模式下的Redis进程</p>
</blockquote>
<p>哨兵有三个任务：</p>
<ol>
<li><strong>监控</strong>：周期性的给主库发送PING，检测主库是否在运行</li>
<li><strong>选择主库</strong>：从众多的从库中筛选一个作为主库</li>
<li><strong>通知</strong>：把新主库的连接信息发送给从库</li>
</ol>
<p>其实这三个功能都是围绕着一个流程来进行的</p>
<h3 id="监控——主观下线与客观下线"><a href="#监控——主观下线与客观下线" class="headerlink" title="监控——主观下线与客观下线"></a>监控——主观下线与客观下线</h3><blockquote>
<p>哨兵如何判断一个主库已经挂掉了呢？</p>
</blockquote>
<p>哨兵会周期性给主库、从库发送PING请求，如果主从库没有在规定时间内回应：</p>
<ul>
<li>从库没有回应：标记为<strong>主观下线</strong></li>
<li>主库没有回应：有可能主库真的下线了（此时会进行主从切换），也有可能是哨兵误判了</li>
</ul>
<p>所以需要有<strong>很多哨兵</strong>来进行对主库是否下线的判断，这就称为<strong>哨兵集群</strong></p>
<p>所以，当多数的哨兵都认为主库已经下线，那么此时主库就会被认定为<strong>客观下线</strong></p>
<p><strong>客观下线的标准就是</strong>：当有 N 个哨兵实例时，最好要有 <code>N/2 + 1</code> 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”</p>
<hr>
<p>监控的具体流程：</p>
<ol>
<li>当一个哨兵判断主库主观下线后，就会给其他哨兵发送<code>is-master-down-by-addr</code></li>
<li>其他的哨兵会根据自己的判断，投出Y/N（即赞成票和不赞成票）</li>
<li>当赞成票大于<code>quorum</code>参数时，就会认为主库<strong>客观下线</strong></li>
</ol>
<p><img src="http://img.yesmylord.cn//image-20210829151152890.png" alt="哨兵投票仲裁"></p>
<blockquote>
<p>主库挂掉，哪一个哨兵来执行主从切换的任务呢？</p>
</blockquote>
<p>是由Leader来执行，leader也是由投票选举产生的：</p>
<p>在投票过程中，任何一个想成为 Leader 的哨兵，要满足<strong>两个条件</strong>：</p>
<ol>
<li>拿到<strong>半数以上的赞成票</strong></li>
<li>拿到的票数同时还需要大于等于哨兵配置文件中的 <code>quorum</code>值</li>
</ol>
<blockquote>
<p>哨兵是如何确定Leader投票是投是还是否呢？</p>
</blockquote>
<p>它会给<strong>第一个</strong>向它发送投票请求的哨兵<strong>回复 Y</strong>，给后续再发送投票请求的哨兵<strong>回复 N</strong></p>
<h3 id="选主——选择新主库"><a href="#选主——选择新主库" class="headerlink" title="选主——选择新主库"></a>选主——选择新主库</h3><blockquote>
<p>哨兵如何选择主库？</p>
</blockquote>
<p>整个过程分为两步：<strong>筛选 + 打分</strong></p>
<p>​        简单来说，我们在多个从库中，先按照<strong>一定的筛选条件</strong>，把不符合条件的从库去掉。然后，我们再按照<strong>一定的规则</strong>， 给剩下的从库逐个打分，将得分最高的从库选为新主库</p>
<p>（从库都在卷~）</p>
<p><strong>筛选条件</strong>：除了要检查从库的<strong>当前在线状态</strong>，还要判断它<strong>之前的网络连接状态</strong>（通过配置一个最大连接时长，默认如果发生断连的次数超过10次，就认为这个从库的网络状况不好，就被miss掉了）</p>
<p><strong>打分规则</strong>：别按照三个规则依次进行<strong>三轮打分</strong>，这三个规则分别是<strong>从库优先级</strong>、<strong>从库复制进度</strong>以及<strong>从库 ID 号</strong></p>
<p>三轮打分过程：</p>
<ol>
<li>优先级最高的从库得分高（不同的从库可以设置不同的优先级，一般给内存大的从库设定一个高的优先级）</li>
<li>和旧主库同步程度最近的从库得分高（通过<code>repl_backlog_buff</code>缓存中的指针，详情见上一节）</li>
<li>ID号小的从库得分高：默认的规定，在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库</li>
</ol>
<h3 id="通知——发布-订阅机制"><a href="#通知——发布-订阅机制" class="headerlink" title="通知——发布/订阅机制"></a>通知——发布/订阅机制</h3><blockquote>
<p>哨兵之间是如何进行交流的？</p>
</blockquote>
<p>要弄清楚这个问题，首先得知道如何设置一个哨兵：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要主库的ip、端口号</span></span><br></pre></td></tr></table></figure>

<p>此时哨兵之间是不知道彼此的</p>
<p>哨兵实例之间可以相互发现，要归功于 Redis 提供的 <strong>pub/sub 机制</strong>，也就是<strong>发布 / 订阅 机制</strong></p>
<blockquote>
<p>发布订阅机制：订阅了<strong>同一个频道</strong>的应用，可以通过发布的消息进行信息交换</p>
</blockquote>
<p>频道有很多：</p>
<p><img src="http://img.yesmylord.cn//image-20210829150559213.png" alt="Redis频道"></p>
<p>哨兵只要和主库建立起了连接，就可以在主库上<strong>发布消息</strong>了，比如说发布它自己的连接信息（IP 和端口）</p>
<p>同时，它也可以从主库上<strong>订阅消息</strong>，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p>
<p>举个例子，具体说明一下。</p>
<p>在下图中，哨兵 1 把自己的 IP（172.16.19.3）和端口 （26579）发布到“<code>__sentinel__:hello</code>”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。</p>
<p><img src="http://img.yesmylord.cn//image-20210829150014119.png" alt="发布/订阅"></p>
<blockquote>
<p>哨兵是如何知道从库的IP的？</p>
</blockquote>
<p><strong>哨兵向主库发送 <code>INFO</code> 命令</strong>，主库接受到这个命令后，就会把<strong>从库列表</strong>返回给哨兵</p>
<h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><h2 id="缓存处理请求的两种情况"><a href="#缓存处理请求的两种情况" class="headerlink" title="缓存处理请求的两种情况"></a>缓存处理请求的两种情况</h2><p>缓存接收请求后，无非两种情况：</p>
<ul>
<li><strong>缓存命中</strong>：缓存中有数据，可以直接读</li>
<li><strong>缓存缺失</strong>：缓存中没有数据，必须要去数据库中读取；而且读取完成后，还必须把这个数据再加载到缓存中</li>
</ul>
<p>注意：缓存缺失后，除了要访问数据库，还要把新的数据写到缓存内（缓存更新）</p>
<h2 id="Redis的缓存类型"><a href="#Redis的缓存类型" class="headerlink" title="Redis的缓存类型"></a>Redis的缓存类型</h2><p>Redis中缓存由两种类型，我们可以根据业务的不同来选择不同的缓存：</p>
<ul>
<li><strong>只读缓存</strong>：只读缓存只接受读请求，对于写请求直接交给数据库处理</li>
<li><strong>读写缓存</strong>：读写请求接收读、写请求</li>
</ul>
<p>只读缓存对于不同的请求：</p>
<ol>
<li>写请求：只读缓存会删除当前缓存</li>
<li>读请求：如果读不到，会发生缓存缺失，在读完数据库后进行缓存更新</li>
</ol>
<p><img src="http://img.yesmylord.cn//image-20210829201020913.png" alt="只读缓存"></p>
<p>读写缓存对于不同的请求的处理：</p>
<ol>
<li>读请求：与只读缓存一样</li>
<li>写请求：直接在缓存中进行更改</li>
</ol>
<p>在读写缓存中，由于写请求在缓存中就进行了处理，所以必须要写回磁盘，这时就有<strong>两种不同的写回磁盘的策略</strong>：</p>
<ul>
<li><strong>同步直写</strong>：服务器向缓存和数据库同时发起请求，缓存处理完成后，需要等待数据库也处理完成后，才会返回响应</li>
<li><strong>异步写回</strong>：缓存处理完数据后直接返回，而且数据只有在被淘汰出缓存时才会写回磁盘</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210829202110035.png" alt="同步直写&amp;异步写回"></p>
<table>
<thead>
<tr>
<th>对比</th>
<th>同步直写</th>
<th>异步写回</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>即使缓存发生故障，数据也不会丢失</td>
<td>访问快速</td>
</tr>
<tr>
<td>缺点</td>
<td>等待数据库，降低了缓存的访问性能</td>
<td>缓存发生故障会导致数据直接丢失</td>
</tr>
</tbody></table>
<h2 id="Redis的缓存淘汰机制"><a href="#Redis的缓存淘汰机制" class="headerlink" title="Redis的缓存淘汰机制"></a>Redis的缓存淘汰机制</h2><p>Redis有两种淘汰策略：</p>
<ol>
<li><strong>惰性删除</strong>：redis不主动删除过期键，而是处理每一个请求时，判断是否过期，如果过期就删除。</li>
<li><strong>定期删除</strong>：每隔一段时间（默认100ms）随机抽查一部分键，根据不同的策略淘汰键。</li>
</ol>
<p>Redis4.0定期删除有 8 种淘汰策略：</p>
<p><img src="http://img.yesmylord.cn//image-20210829202821202.png" alt="淘汰策略"></p>
<ul>
<li><code>noeviction</code>：不会淘汰数据，如果缓存满了，将不再提供服务（默认策略）</li>
<li><code>volatile</code>开头的淘汰策略：代表淘汰的选择源是<strong>所有有时间限制的数据</strong>，不会淘汰那些无时间限制的数据（即只淘汰那些设置EXPIRE的数据）</li>
<li><code>allkeys</code>开头的淘汰策略：淘汰的选择源是<strong>所有数据</strong></li>
<li><code>LRU</code>：基于LRU算法进行淘汰</li>
<li><code>LFU</code>：基于LFU算法进行淘汰</li>
<li><code>random</code>：随机进行淘汰</li>
<li><code>volatile-ttl</code>：淘汰最早的请求（通过TTL判断）</li>
</ul>
<blockquote>
<p>如何选择？</p>
</blockquote>
<ul>
<li><p>优先使用<code>allkeys-lru</code>策略：可以充分利用 LRU 这一经典缓存算法的优势，把最 近最常访问的数据留在缓存中</p>
</li>
<li><p>如果你的业务中有类似置顶的需求（比如置顶新闻、置顶视频）：可以使用 <code>volatile-lru</code> 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选</p>
</li>
</ul>
<blockquote>
<p>淘汰的数据如何处理？</p>
</blockquote>
<p>一般来讲，对于干净页直接删除，但是对于脏页要写回数据库后再删除。</p>
<p>但是在Redis中，不管干不干净，只要认定淘汰，就会直接删除</p>
<h2 id="Redis中的LRU算法"><a href="#Redis中的LRU算法" class="headerlink" title="Redis中的LRU算法"></a>Redis中的LRU算法</h2><p>由于LRU需要借助链表，而且涉及到了链表的很多断开、连接的操作</p>
<p>所以如果缓存中的数据很多，那么直接使用LRU算法，显然会造成很大负担</p>
<p>LRU算法就不介绍了，在Redis中的特殊处理，要说一下</p>
<hr>
<p>首先要知道Redis<strong>在<code>RedisObejct</code>中，保存了lru字段记录最近一次的访问时间戳</strong></p>
<ul>
<li><p>第一次LRU淘汰：<strong>随机选出N个数据</strong>，把他们作为一个<strong>候选集合</strong>，接下来，Redis会比较这N个数据的lru字段，将数值最小的（也就是好久没有访问的）淘汰</p>
</li>
<li><p>之后的每一次淘汰：<strong>挑选</strong>一些数据进入候选集合，<strong>挑选的标准是该数据的lru字段的值比候选集合里最小的lru还要小</strong>，然后淘汰lru字段最小的数据</p>
</li>
</ul>
<p>经过这样的特殊处理，Redis就既实现了LRU，也提高了缓存的性能</p>
<h2 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h2><p>由于Redis有两种缓存，所以缓存不一致问题，我们分开来讨论：</p>
<blockquote>
<p>对于读写缓存</p>
</blockquote>
<p>只能采用<strong>同步直写</strong>的方式避免，涉及到Redis的事务</p>
<blockquote>
<p>对于<strong>只读缓存</strong></p>
</blockquote>
<ul>
<li>新增数据时：数据在写入数据库后，加载到内存，<strong>不存在不一致问题</strong></li>
<li>删改数据时：只读缓存只接受读请求，所以如果你改了数据库中的数据，假设此时还没来得及删掉缓存中的数据，那么此时有请求来读，读到的将是旧的数据（<strong>存在不一致问题</strong>）</li>
</ul>
<p><strong>解决措施：删除缓存中的数据，并且将数据库中的数据修改</strong></p>
<hr>
<p>但是！这个解决措施并不一定能完全成功：（我们还需要保障措施保证这两步能完成！）</p>
<p>下面我们看删改数据时都会有哪些情况，可以导致数据不一致的发生</p>
<p>情况一：删改数据后，<strong>由于删缓存数据的操作失败而导致的缓存不一致</strong></p>
<p>情况二：删改数据后，<strong>由于多线程，还没来得及删缓存数据，而导致的缓存不一致</strong></p>
<p>如何解决？</p>
<p>对于情况一：采用<strong>重试机制</strong></p>
<p>对于情况二：采用<strong>延迟双删</strong></p>
<blockquote>
<p>重试机制</p>
</blockquote>
<p>可以<strong>把要删除的缓存值或者是要更新的数据库值暂存到消息队列中</strong>（例如使用 Kafka 消息队列）</p>
<p>当删除缓存数据操作失败后，可以从消息队列中重新读取这些值，然后再次进行删除或更新</p>
<p><img src="http://img.yesmylord.cn//image-20210829205759671.png" alt="重试机制"></p>
<blockquote>
<p>延迟双删</p>
</blockquote>
<p><strong>在线程 A 更新完数据库值以后</strong>，我们<strong>可以让它先 sleep 一小段时间</strong>，<strong>再进行一次缓存删除操作</strong></p>
<p>（线程 A sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间）</p>
<p>之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">伪代码</span></span><br><span class="line">redis.delKey(X)</span><br><span class="line">db.update(X)</span><br><span class="line">Thread.sleep(N)</span><br><span class="line">redis.delKey(X)# 第二次删除</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用延迟双删+消息队列方式解决缓存一致性会有什么弊端吗？</p>
</blockquote>
<ol>
<li>对业务代码的侵入比较大</li>
<li>延迟时间不好控制，时间短可能导致双删没有作用；时间太长可能会降低系统并发度</li>
</ol>
<p>因此可以使用<strong>异步缓存更新机制</strong>：使用canal订阅binlog日志文件，在有数据更新后触发缓存更新重试机制。</p>
<p><img src="http://img.yesmylord.cn//image-20240725104602761.png" alt="异步更新缓存"></p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><blockquote>
<p>缓存雪崩：指大量的应用请求无法在 Redis 缓存中进行处理，应用将大量请求发送到数据库层，导致数据库层的压力激增</p>
</blockquote>
<p>导致缓存雪崩的原因：</p>
<ol>
<li>缓存中有大量的数据同时过期</li>
<li>Redis缓存发生故障宕机</li>
</ol>
<p>解决措施：</p>
<p>对于情况1，有两种解决办法：</p>
<ol>
<li>避免给大量的数据设置相同的过期时间（可以给EXPIRE设置时间时加一个1-3分钟的随机值）</li>
<li><strong>服务降级</strong></li>
</ol>
<blockquote>
<p>服务降级：</p>
<p>对于非核心数据，暂停缓存服务，让其直接返回预定义的信息或者空值</p>
<p>对于核心数据，继续提供服务</p>
</blockquote>
<p>对于情况2，也有两种解决办法：</p>
<ol>
<li><strong>服务熔断或请求限流机制</strong></li>
<li>使用主从Redis集群，切换主库（比较好的办法）</li>
</ol>
<blockquote>
<p>服务熔断：</p>
<p>为了防止引发连锁的数据库雪崩，甚至是整个系统的崩溃，我们<strong>暂停业务应用对缓存系统的接口访问</strong></p>
</blockquote>
<p>服务熔断会终止所有的缓存服务，这当然是不好的</p>
<blockquote>
<p>请求限流机制：</p>
<p>在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请 求被发送到数据库</p>
</blockquote>
<p>比如请求入口前端允许每秒进入系统的请求是 1 万个，其中，9000 个请求都能在缓存系统中进行处理，只有 1000 个请求会被应用发送到数据库进行处理</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><blockquote>
<p>缓存击穿：针对某个访问<strong>非常频繁的热点数据</strong>的请求，无法在缓存中进行处理，导致访问该数据的大量请求，一下子都发送到了后端数据库</p>
</blockquote>
<p>解决办法：</p>
<p>热点数据不要设置过期时间，让其能对热点数据持续提供服务</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><blockquote>
<p>缓存穿透：要访问的数据<strong>既不在 Redis 缓存中，也不在数据库中</strong>，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据</p>
</blockquote>
<p>发生缓存穿透的原因：</p>
<ol>
<li><strong>业务层误操作</strong>：业务层不慎删除了缓存的数据和数据库的数据</li>
<li><strong>恶意攻击</strong>：专门访问数据库没有的数据</li>
</ol>
<p>解决措施：</p>
<ol>
<li><strong>缓存空值或缺省值</strong></li>
<li>使用<strong>布隆过滤器</strong>快速判断是否存在，减轻数据库压力</li>
<li>在<strong>前端的请求入口进行检测</strong>，把恶意的请求直接过滤掉</li>
</ol>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><blockquote>
<p>布隆过滤器：</p>
<p>是由初值都为0的<strong>bit数组</strong>与N个<strong>哈希函数</strong>组合，可以快速判断数据是否存在</p>
</blockquote>
<p>如果一个数据被写入数据库，那么需要在布隆过滤器上标记它的存在：</p>
<ol>
<li><p>使用N个哈希函数分别计算这个数据的哈希值，得到N个哈希值</p>
</li>
<li><p>将哈希值对bit数组的长度取模，得到每个哈希值在数组中的对应位置</p>
</li>
<li><p>将对应的bit位置为1</p>
</li>
</ol>
<p>如果想要查一个数据是否存在：</p>
<ol>
<li>同样使用N个哈希函数计算其哈希值</li>
<li>去对应位置查看bit数组对应位是否为1</li>
<li>只要有一个不为1，那么这个数据就不存在</li>
</ol>
<h2 id="缓存异常总结"><a href="#缓存异常总结" class="headerlink" title="缓存异常总结"></a>缓存异常总结</h2><p><img src="http://img.yesmylord.cn//image-20210830084706183.png" alt="三种缓存异常对比"></p>
<h2 id="缓存污染"><a href="#缓存污染" class="headerlink" title="缓存污染"></a>缓存污染</h2><blockquote>
<p>缓存污染：指缓存中存放了很多访问次数很少，甚至只会被访问一次的数据，白白占用缓存的空间</p>
</blockquote>
<p>如何解决缓存污染？</p>
<blockquote>
<p>LRU可以解决缓存污染问题吗？</p>
</blockquote>
<p>LRU的确可以有效的留存最近访问的数据，但是在出现<strong>扫描式单次查询操作时</strong>，LRU策略显得无能为力</p>
<blockquote>
<p>扫描式单词查询：应用<strong>对大量的数据进行一次全体读取</strong>，每个数据都会被读取，而且只会被读取一次。此时，<strong>因为这些被查询的数据刚刚被访 问过，所以 lru 字段值都很大</strong></p>
</blockquote>
<h2 id="Redis中的LFU算法"><a href="#Redis中的LFU算法" class="headerlink" title="Redis中的LFU算法"></a>Redis中的LFU算法</h2><p>LFU（least frequently used）可以看做LRU算法的一种优化，它会从两个值来判断将什么数据淘汰：</p>
<ol>
<li><strong>数据访问的时效性</strong>（即访问时间到当前时间的长度）</li>
<li><strong>数据被访问的次数</strong></li>
</ol>
<p>LFU判断依据：</p>
<p>​        LFU算法会<strong>先根据数据被访问的次数进行筛选</strong>，如果访问次数相同，那么才会去比较访问的时效性，将访问更久的数据淘汰。</p>
<p>这两个数据也存放在<code>RedisObejct</code>中，<code>RedisObejct</code>中的lru字段占用了3B（24b），将这个字段分开：</p>
<ul>
<li><strong>ldt值</strong>：lru字段的<strong>前16bit</strong>，表示数据的访问时间戳</li>
<li><strong>counter值</strong>：lru字段的<strong>后8bit</strong>，表示数据的访问次数</li>
</ul>
<p>注意：</p>
<p>counter的值并不是每访问一次就增加1</p>
<p>它的加1过程很复杂：</p>
<blockquote>
<p>counter计数规则是：</p>
<p>​        每当数据被访问一次时，首先，用计数器当前的值乘以配置项 <code>lfu_log_factor</code> 再加 1，再取其倒数，得到一个 <code>p</code> 值；</p>
<p>​        把这个 p 值和一个取值范围在（0，1）间的随机数<code>r</code>值比大小，只有<code>p</code>值大于 <code>r</code> 值时，计数器才加 1</p>
</blockquote>
<p>我们不需要记住这个计数规则，官方给我们一个<code>lfu_log_factor</code>值取不同数据时，counter值的变化情况：</p>
<p><img src="http://img.yesmylord.cn//image-20210830095244062.png" alt="counter值的变化情况"></p>
<p>可见，一般的项目，我们可以设置为10，就可以保证在1M点击的情况下也能保证区分度</p>
<hr>
<p>除此外，Redis还规定了counter的衰减机制：</p>
<blockquote>
<p>LFU 策略使用衰减因子配置项<code>lfu_decay_time</code> 来控制访问次数的衰减。</p>
<p>LFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。 </p>
<p>然后，LFU 策略再把这个差值除以 <code>lfu_decay_time</code> 值，所得的结果就是数据 counter 要衰减的值。</p>
</blockquote>
<h2 id="热key问题"><a href="#热key问题" class="headerlink" title="热key问题"></a>热key问题</h2><blockquote>
<p>热key指在缓存系统中，某些缓存key访问过于频繁，导致对于这些key需要额外进行性能处理的情况。</p>
</blockquote>
<p>一般处理热key问题的解决手段有三种：</p>
<ol>
<li><strong>缓存预热</strong>：在系统启动或者业务低峰，主动缓存热门数据</li>
<li><strong>一致性hash</strong>：使用哈希环，将键散列在整个环上，可以使请求更均匀的分布在各个redis节点。</li>
<li><strong>数据分片</strong>：按照业务某个键分片，拆分缓存在不同的缓存节点上，减轻单个节点的压力。</li>
</ol>
<p>但是在实际应用中，热key可能是可预知的，也可能不可预知：</p>
<ul>
<li>可预知的热key：比如秒杀活动。在发布商品时就需要进行分布式缓存、本地缓存预热</li>
<li>不可预知的热key：比如某个商品突然称为爆款。接入<strong>热点探测系统</strong>（定期上报key的查询次数，热点系统检测是否为热key），如果是热key立即建立本地缓存与缓存</li>
</ul>
<p>除此外，对于热key问题，即使有缓存手段也要做好兜底工作，做好<strong>限流熔断兜底</strong>。</p>
<blockquote>
<p>热key如何发现？</p>
</blockquote>
<p>1、在LFU算法下，可以使用<code>--hotkeys</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 --hotkeys</span><br></pre></td></tr></table></figure>

<p>该参数能够返回所有 key 的被访问次数</p>
<p>2、MONITOR命令</p>
<p>实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p>
<p>对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p>
<p>3、业务代码是否有日志？</p>
<h2 id="大key问题"><a href="#大key问题" class="headerlink" title="大key问题"></a>大key问题</h2><blockquote>
<p>怎么算是一个大key？</p>
</blockquote>
<ul>
<li>如果是String类型：value超过1MB</li>
<li>复合类型（List、Hash、Sort、Sorted Sort）：value元素超过5000个</li>
</ul>
<blockquote>
<p>大key带来的副作用：</p>
</blockquote>
<ul>
<li>占用内存大</li>
<li>处理大key的网络IO消耗大：比如一个key是1mb，qps是1000，那么每秒就有1GB的流量处理，一般的千兆宽带是扛不住这个压力的</li>
<li>del困难：删除大key时，阻塞的时间会比较长</li>
</ul>
<blockquote>
<p>如何发现大key？</p>
</blockquote>
<p>1、加<code>--bigkeys</code>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 --bigkeys -i 3</span><br><span class="line"><span class="comment"># 每3秒执行一次大key扫描</span></span><br></pre></td></tr></table></figure>

<p>这种方式会扫描所有的key，且只能找出每种数据结构 top 1 bigkey（占用内存最大的 String 数据类型，包含元素最多的复合数据类型）</p>
<p>实际上这种方式会调用scan命令进行执行</p>
<p>2、使用scan命令</p>
<p><code>SCAN</code> 命令在遍历大量数据时不会阻塞服务器，但是返回的数据可能不是实时的。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SCAN 0 MATCH user:* COUNT 100</span><br><span class="line"><span class="comment"># 从游标 0 开始扫描，匹配所有user:开头的键，并且最多返回100个</span></span><br></pre></td></tr></table></figure>

<p>3、借助开源工具，分析RDB文件（前提使用了RDB的方式）</p>
<p>4、借助平台的分析服务（阿里云Redis有bigkey实时分析）</p>
<blockquote>
<p>如何处理大key？</p>
</blockquote>
<ul>
<li><p><strong>手动清理</strong>：</p>
<ul>
<li>Redis 4.0+可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key</li>
<li>Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>
</ul>
</li>
<li><p><strong>分割</strong>：将一个bigkey分为多个小key，比如一个hash通过二次hash，拆分为多个hash</p>
</li>
<li><p><strong>采用合适的数据结构</strong>：例如，文件二进制数据不使用 String 保存、使用 HyperLogLog 统计页面 UV、Bitmap 保存状态信息（0/1）</p>
</li>
<li><p><strong>开启lazy-free</strong>： Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理</p>
</li>
</ul>
<h1 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h1><p>查看此篇：<a target="_blank" rel="noopener" href="https://www.yesmylord.cn/2022/02/14/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">redis分布式锁</a></p>
<h1 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ysocean/p/9080942.html">博客园</a></li>
<li>b站狂神说</li>
<li>Redis设计与实现</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35433716/article/details/85345907?ops_request_misc=&request_id=&biz_id=102&utm_term=epoll%20&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-85345907.nonecase&spm=1018.2226.3001.4187">csdn图解epoll</a></li>
<li>极客时间蒋德钧老师的redis课</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"><i class="fa fa-tag"></i> Redis</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/11/14/Linux/Linux%E6%9C%89%E8%B6%A3%E7%9A%84%E5%91%BD%E4%BB%A4/" rel="prev" title="Linux有趣的命令">
                  <i class="fa fa-chevron-left"></i> Linux有趣的命令
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/01/12/Maven/Maven/" rel="next" title="Maven">
                  Maven <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备 - 20007839号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hynis</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:59</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
