<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32X32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16X16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CZCOOL+XiaoWei:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/orange/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="引言：JUC实战">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC实战">
<meta property="og:url" content="http://yoursite.com/2021/09/04/JUC/JUC%E5%AE%9E%E6%88%98/index.html">
<meta property="og:site_name" content="Hynis">
<meta property="og:description" content="引言：JUC实战">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210904194900277.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210904204832937.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210905110614638.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210905113012054.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210905173310258.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210803204224306.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210906194144240.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210911164234074.png">
<meta property="article:published_time" content="2021-09-04T11:37:20.000Z">
<meta property="article:modified_time" content="2025-07-31T18:09:08.569Z">
<meta property="article:author" content="Hynis">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.yesmylord.cn//image-20210904194900277.png">


<link rel="canonical" href="http://yoursite.com/2021/09/04/JUC/JUC%E5%AE%9E%E6%88%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2021/09/04/JUC/JUC%E5%AE%9E%E6%88%98/","path":"2021/09/04/JUC/JUC实战/","title":"JUC实战"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JUC实战 | Hynis</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hynis</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">157</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">92</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">214</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">

<!-- 网易云外链-->
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1439739102&auto=1&height=66"></iframe>
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>



      <div class="sidebar-panel-container">

        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E5%AE%9E%E6%88%98"><span class="nav-number">1.</span> <span class="nav-text">JUC实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BE%88%E9%87%8D%E8%A6%81%E7%9A%84%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="nav-number">1.1.</span> <span class="nav-text">很重要的前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before%E5%8E%9F%E5%88%99"><span class="nav-number">1.1.1.</span> <span class="nav-text">happens before原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">锁模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">1.1.3.</span> <span class="nav-text">对象头</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">1.2.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%80%E6%8A%8A%E9%94%81%E4%BF%9D%E6%8A%A4%E4%B8%80%E4%B8%AA%E8%B5%84%E6%BA%90"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 一把锁保护一个资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%A4%9A%E6%8A%8A%E9%94%81%E4%BF%9D%E6%8A%A4%E5%A4%9A%E4%B8%AA%E6%B2%A1%E6%9C%89%E5%85%B3%E8%81%94%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 多把锁保护多个没有关联的资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%A4%9A%E6%8A%8A%E9%94%81%E4%BF%9D%E6%8A%A4%E5%A4%9A%E4%B8%AA%E6%9C%89%E5%85%B3%E8%81%94%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 多把锁保护多个有关联的资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.3.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.3.1.</span> <span class="nav-text">死锁产生的必要条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BF%9D%E6%8C%81%E6%9D%A1%E4%BB%B6%EF%BC%9A%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="nav-number">1.3.2.</span> <span class="nav-text">破坏请求和保持条件：有两种方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.3.3.</span> <span class="nav-text">破坏不可剥夺条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A0%B4%E5%9D%8F%E7%8E%AF%E8%B7%AF%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.3.4.</span> <span class="nav-text">破坏环路条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-notify-%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.</span> <span class="nav-text">wait-notify 等待通知机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized%E4%B8%8Ewait-notify%E9%85%8D%E5%90%88"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">Synchronized与wait-notify配合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E3%80%81%E6%B4%BB%E8%B7%83%E6%80%A7%E3%80%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">安全性、活跃性、性能问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">1.5.1.</span> <span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">活跃性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.3.</span> <span class="nav-text">性能问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%A8%8B"><span class="nav-number">1.6.</span> <span class="nav-text">管程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.7.</span> <span class="nav-text">Java线程的状态转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">1.8.</span> <span class="nav-text">Semaphore</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%B8%BA1%E2%80%94%E2%80%94%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">信号量为1——互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%B1%A0"><span class="nav-number">1.8.2.</span> <span class="nav-text">信号量实现一个对象池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock"><span class="nav-number">1.9.</span> <span class="nav-text">ReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98"><span class="nav-number">1.9.1.</span> <span class="nav-text">读写锁实现缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E9%99%8D%E7%BA%A7"><span class="nav-number">1.9.2.</span> <span class="nav-text">读写锁的升级与降级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StampedLock"><span class="nav-number">1.10.</span> <span class="nav-text">StampedLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock%E7%9A%84%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90"><span class="nav-number">1.10.1.</span> <span class="nav-text">StampedLock的官方例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock%E7%9A%84%E8%AF%BB%E5%86%99%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.10.2.</span> <span class="nav-text">StampedLock的读写模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock%E5%AF%B9%E6%AF%94ReentrantReadWriteLock"><span class="nav-number">1.10.3.</span> <span class="nav-text">StampedLock对比ReentrantReadWriteLock</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">1.11.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">1.12.</span> <span class="nav-text">CyclicBarrier</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E5%8A%A0%E8%BD%BDDemo"><span class="nav-number">1.12.1.</span> <span class="nav-text">任务加载Demo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FutureTask"><span class="nav-number">1.13.</span> <span class="nav-text">FutureTask</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A1%E8%8C%B6Demo"><span class="nav-number">1.13.1.</span> <span class="nav-text">泡茶Demo</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hynis"
      src="http://img.yesmylord.cn//1644852537960.jpg">
  <p class="site-author-name" itemprop="name">Hynis</p>
  <div class="site-description" itemprop="description">A blog about IT knowledge</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">214</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">92</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">157</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YesYourHighness" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YesYourHighness" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1046467756@qq.com" title="E-Mail → mailto:1046467756@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zouper.cn/" title="https:&#x2F;&#x2F;zouper.cn" rel="noopener" target="_blank">一杯好茶</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.klenkiven.xyz/" title="https:&#x2F;&#x2F;www.klenkiven.xyz&#x2F;" rel="noopener" target="_blank">KlenKiven</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hourunmeng.github.io/" title="https:&#x2F;&#x2F;hourunmeng.github.io&#x2F;" rel="noopener" target="_blank">润萌</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://flashxin.github.io/" title="https:&#x2F;&#x2F;flashxin.github.io&#x2F;" rel="noopener" target="_blank">flashxin</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/YesYourHighness" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/04/JUC/JUC%E5%AE%9E%E6%88%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.yesmylord.cn//1644852537960.jpg">
      <meta itemprop="name" content="Hynis">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hynis">
      <meta itemprop="description" content="A blog about IT knowledge">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JUC实战 | Hynis">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JUC实战
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-04 19:37:20" itemprop="dateCreated datePublished" datetime="2021-09-04T19:37:20+08:00">2021-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-01 02:09:08" itemprop="dateModified" datetime="2025-08-01T02:09:08+08:00">2025-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>
  引言：JUC实战
</center>

<span id="more"></span>

<h1 id="JUC实战"><a href="#JUC实战" class="headerlink" title="JUC实战"></a>JUC实战</h1><p>之前的JUC，感觉也只是入了门；</p>
<p>在大学不管是做项目、还是做课设，都没有涉及到多线程的开发。</p>
<p>所以这篇可以更深刻的理解，JUC的由来~</p>
<h2 id="很重要的前置知识"><a href="#很重要的前置知识" class="headerlink" title="很重要的前置知识"></a>很重要的前置知识</h2><p>并发编程主要就是三点：<strong>分工、同步、互斥</strong></p>
<p>并发编程要解决的问题（微观）：<strong>原子性、可见性、有序性</strong></p>
<p>并发编程要解决的问题（宏观）：<strong>安全性、活跃性、性能</strong></p>
<p>Java如何解决三个问题：<code>volatile</code>、<code>synchronized</code>、<code>final</code>、八项<code>Happens-Before</code>、锁</p>
<p><img src="http://img.yesmylord.cn//image-20210904194900277.png" alt="并发编程脑图"></p>
<h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens before原则"></a>happens before原则</h3><ol>
<li>程序顺序原则（线程内必须串行执行）</li>
<li>锁规则（解锁必须发生在上锁后）</li>
<li>volatile规则（强迫每次的读写都必须刷新到主内存，不能为了省事直接去工作内存读）</li>
<li>线程启动规则（线程的<code>start()</code>方法先于它的其他操作）</li>
<li>传递性（A先于B，B先于C，A必先于C）</li>
<li>线程终止规则</li>
<li>线程中断规则（线程的所有操作先于线程的终结）</li>
<li>对象终结规则（构造方法先于<code>finalize()</code>方法）</li>
</ol>
<p>这八个规则确定的内容，即使没有锁等同步操作，也可以按序执行</p>
<h3 id="锁模型"><a href="#锁模型" class="headerlink" title="锁模型"></a>锁模型</h3><blockquote>
<p>简易的锁模型</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock();</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">unlock();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>改进的锁模型：<strong>锁和锁要保护的资源是有对应关系的</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、 创建保护资源R的锁 LR</span></span><br><span class="line">lock(LR); <span class="comment">//2、上锁</span></span><br><span class="line"><span class="comment">// 3、 临界区操作R</span></span><br><span class="line">unlock(LR);<span class="comment">//4、释放锁</span></span><br></pre></td></tr></table></figure>

<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><blockquote>
<p>加锁的本质，<strong>就是在锁对象的对象头写入了当前线程的ID</strong>，获得了对Monitor对象的所有权</p>
</blockquote>
<p>对象的组成：三大部分</p>
<ul>
<li><strong>对象头</strong><ul>
<li><strong>Markword</strong>（8字节，64位JVM）</li>
<li><strong>类型指针</strong>（4字节，64位JVM）</li>
<li>数组长度（数组才有此字段）</li>
</ul>
</li>
<li>实例数据</li>
<li>字节填充</li>
</ul>
<p>Markword记录了三方面的信息：哈希值、GC信息、锁信息</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39908462/article/details/111656725">对象头的锁升级过程</a>（细品这篇博客，讲到了锁升级的过程）</p>
<p><img src="http://img.yesmylord.cn//image-20210904204832937.png" alt="32位JVM的对象头"></p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="1-一把锁保护一个资源"><a href="#1-一把锁保护一个资源" class="headerlink" title="1. 一把锁保护一个资源"></a>1. 一把锁保护一个资源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一把锁保护一个资源的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ALockProtectAResource</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对于long 和 double的读与写操作，JVM是分两步完成的，存在安全问题</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* syn修饰不同的位置有不同的作用：</span></span><br><span class="line"><span class="comment">    * 1. 修饰 普通的方法 锁住的是对象的实例 即 this</span></span><br><span class="line"><span class="comment">    * 2. 修饰 静态方法，锁住的是对应的Class对象</span></span><br><span class="line"><span class="comment">    * 3. 修饰 同步代码块，锁住的是传入的锁</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-多把锁保护多个没有关联的资源"><a href="#2-多把锁保护多个没有关联的资源" class="headerlink" title="2. 多把锁保护多个没有关联的资源"></a>2. 多把锁保护多个没有关联的资源</h3><p>场景：有<code>account</code>与<code>password</code>字段。</p>
<p>对于<code>account</code>可以取款，查账</p>
<p>对于<code>password</code>可以修改、查看密码</p>
<blockquote>
<p>为什么不用syn修饰方法呢？这样不也可以同步吗？</p>
</blockquote>
<p>是可以同步，但是发现没有，密码业务与账户业务没有关系。</p>
<p>如果给方法加了syn，就锁住了this，导致两个业务之间也变为互斥了！降低了我们系统的效率</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多把锁保护多个没关系的资源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocksProtectNoRelatedResource</span> &#123;</span><br><span class="line">    <span class="comment">// 密码相关</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockMyPass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 加上final，告诉编译器这是一个不可变对象，尽情的去优化吧</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">changePassword</span><span class="params">(String newPassword)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockMyPass)&#123;</span><br><span class="line">            password = newPassword;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">getPassword</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockMyPass)&#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 账户相关</span></span><br><span class="line">    <span class="keyword">private</span> Integer account;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lockMyMoney</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 加上final，告诉编译器这是一个不可变对象，尽情的去优化吧</span></span><br><span class="line">    Integer <span class="title function_">getAccount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockMyMoney)&#123;</span><br><span class="line">            <span class="keyword">return</span> account;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">takeMoney</span><span class="params">(Integer money)</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lockMyMoney)&#123;</span><br><span class="line">            account-=money;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-多把锁保护多个有关联的资源"><a href="#3-多把锁保护多个有关联的资源" class="headerlink" title="3. 多把锁保护多个有关联的资源"></a>3. 多把锁保护多个有关联的资源</h3><p>场景：转账业务</p>
<p>A的账户需要扣除钱，B的账户需要加上钱（这里A与B是两个资源，而且他们需要同时进行操作）</p>
<p>实现的核心就是，要保证同一个锁锁住临界区的操作</p>
<blockquote>
<p>实现一：错误的示范</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现一：这是有问题的实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">    <span class="comment">// 转账虽然加了syn，锁住了this，但是！我们操作的过程中还操作了B的账户！</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account1 target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">            <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">            target.balance += amt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现二：必须要传相同的锁</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现二：可以实现，但是有点问题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">    <span class="keyword">private</span> Object lock;</span><br><span class="line">    <span class="comment">// 构造时传入一个对象作为锁</span></span><br><span class="line">    Account2(Object lock)&#123;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account2 target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="comment">// 改变锁的对象，只要A与B两个人构造时传入相同的对象就可以了</span></span><br><span class="line">        <span class="comment">// 但是怕就怕两个人传入的锁不同</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                target.balance += amt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现三：直接用class对象当锁</p>
</blockquote>
<p>这种实现也有问题，就是性能不高；</p>
<p>A转B、C转D，这两个不需要互斥的操作在这种实现下也变得互斥了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现三</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account3 target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="comment">// 改变锁的对象，直接传Class对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (Account3.class)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                target.balance += amt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现四：使用N把锁，操作时必须同时取到</p>
</blockquote>
<p>对于这个场景：完全可以锁住<code>this</code>与<code>target</code>两个对象</p>
<p>但是存在<strong>死锁</strong>问题，设想，A在给B转账的同时，B也在给A转账（看代码中标有记号的位置）    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现四：使用两把锁，进行两次判断</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account4 target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">            <span class="comment">// #这里会死锁#：A执行到这里，B也执行到了这里</span></span><br><span class="line">            <span class="comment">// 由于A想拿B的this，B也想拿A的this，导致双方都不能继续进行下去</span></span><br><span class="line">            <span class="keyword">synchronized</span> (target)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                    target.balance += amt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>上一节的实现四，出现了死锁问题</p>
<p>死锁部分可以看我的另一篇<a target="_blank" rel="noopener" href="https://www.yesmylord.cn/2020/12/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%AD%BB%E9%94%81/#more">blog</a></p>
<h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ol>
<li><strong>互斥条件</strong>：进程对其所要求的资源进行排它性控制，即一次只有一个进程可以使用一个资源。</li>
<li><strong>请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求。</li>
<li><strong>不可剥夺条件</strong>：进程所获得的资源在未被释放之前，不能被其它进程强行剥夺。</li>
<li><strong>环路条件</strong>：在发生死锁时，必然存在一个进程资源的循环等待链</li>
</ol>
<p>其中互斥条件不能被破坏，其他三个都是可以破坏的</p>
<h3 id="破坏请求和保持条件：有两种方案"><a href="#破坏请求和保持条件：有两种方案" class="headerlink" title="破坏请求和保持条件：有两种方案"></a>破坏请求和保持条件：有两种方案</h3><p>1、可以将进程所需的所有资源一次性拿走（但是会导致资源浪费、饥饿问题产生）</p>
<p>2、只获得初期所需资源后，开始运行。运行过程逐步释放已分配、已用完的全部资源，再请求新的所需资源</p>
<p>对于转账这个业务，第二种方案不好实现，但是第一种方案还是可以实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现5，破坏请求和保持条件</span></span><br><span class="line"><span class="comment">// 额外的一个类，帮我们申请资源，防止死锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Allocater</span>&#123;</span><br><span class="line">    <span class="comment">// Allocater要保持单例模式，这里使用了饿汉式单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Allocater</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Allocater</span> <span class="variable">allocater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Allocater</span>();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Allocater <span class="title function_">getAllocater</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allocater;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 申请</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">apply</span><span class="params">(Object a, Object b)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(als.contains(a) || als.contains(b))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            als.add(a);</span><br><span class="line">            als.add(b);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object a, Object b)</span>&#123;</span><br><span class="line">        als.remove(a);</span><br><span class="line">        als.remove(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account5</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account5 target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="type">Allocater</span> <span class="variable">allocater</span> <span class="operator">=</span> Allocater.getAllocater();</span><br><span class="line">        <span class="keyword">while</span> (!allocater.apply(<span class="built_in">this</span>, target));</span><br><span class="line">        <span class="comment">// 死循环，保证可以拿到两个资源</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (target)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                        <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                        target.balance += amt;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            allocater.free(<span class="built_in">this</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="破坏不可剥夺条件"><a href="#破坏不可剥夺条件" class="headerlink" title="破坏不可剥夺条件"></a>破坏不可剥夺条件</h3><p>Syn做不到破坏此项，因为Syn锁的申请与释放是JVM帮助我们管理的</p>
<p>但是Java中的Lock可以做到这一件事情，下面再讲</p>
<h3 id="破坏环路条件"><a href="#破坏环路条件" class="headerlink" title="破坏环路条件"></a>破坏环路条件</h3><ul>
<li>做法：系统<strong>给每类资源赋予一个编号</strong>，每一个进程按编号递增的顺序请求资源，释放则相反</li>
<li>编号的原则：较为紧缺的资源给以一个较大的序号</li>
<li>优点：较前两种策略，资源利用率和系统吞吐量，都有显著的改善。</li>
<li>问题：<ul>
<li>限制了新设备类型的增加</li>
<li>发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费，如：某进程先用磁带机，后用打印机，但按系统规定，它应先申请打印机，后申请磁带机，致使打印机长期闲置</li>
<li>限制了用户简单、自由的编程</li>
</ul>
</li>
</ul>
<p>对于这个场景也很简单，给Account加一个id，用来排序</p>
<p>如果同时出现A转账B，B转账A的情况，由于id小的先申请，所以他们同时先申请同一个资源，不会出现环路，也就避免了死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现6，破坏环路条件，给资源排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account6</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Account6 target, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">        <span class="type">Account6</span> <span class="variable">first</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="type">Account6</span> <span class="variable">second</span> <span class="operator">=</span> target;</span><br><span class="line">        <span class="comment">// 序号小的先申请</span></span><br><span class="line">        <span class="keyword">if</span>(target.id &lt; <span class="built_in">this</span>.id)&#123;</span><br><span class="line">            first = target;</span><br><span class="line">            second = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (first)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (second)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">this</span>.balance &gt; amt) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.balance -= amt;</span><br><span class="line">                    target.balance += amt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="wait-notify-等待通知机制"><a href="#wait-notify-等待通知机制" class="headerlink" title="wait-notify 等待通知机制"></a>wait-notify 等待通知机制</h2><p>在上面我们解决死锁的时候，使用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!allocater.apply(<span class="built_in">this</span>, target));</span><br></pre></td></tr></table></figure>

<p>死循环，让CPU自旋，来保证拿到资源，但是这样太耗费CPU了</p>
<p>wait-notify等待通知是更优的一种方案</p>
<h4 id="Synchronized与wait-notify配合"><a href="#Synchronized与wait-notify配合" class="headerlink" title="Synchronized与wait-notify配合"></a>Synchronized与wait-notify配合</h4><p>首先来说明一下api吧：</p>
<p>他们都是<code>Obejct</code>类的方法</p>
<ul>
<li><code>wait()</code>：将当前线程移入等待队列</li>
<li><code>notify()</code>：<strong>随机唤醒</strong>一个等待队列中的一个线程</li>
<li><code>notifyAll()</code>：<strong>唤醒</strong>等待队列中的<strong>所有</strong>线程</li>
</ul>
<blockquote>
<p>注意：尽量使用<code>notifyAll</code>！好像<code>notify</code>只唤醒一个线程，是不是会更安全一点呢？但这只是你自己的想象</p>
</blockquote>
<p>假如这种情况：</p>
<p>有资源 A、B、C、D：</p>
<p>​        线程 1 申请到了 AB；线程 2 申请到了 CD；</p>
<p>​        此时线程 3 申 请 AB，会进入等待队列；</p>
<p>​        线程 4 申请 CD 也会进入等待队列；</p>
<p>现在我们再假设之后线程 1 归还了资源 AB</p>
<p>​        如果使用<code>notify()</code>来通知 等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还 是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。</p>
<p>​        所以尽量使用<code>notifyAll()</code></p>
<hr>
<p><img src="http://img.yesmylord.cn//image-20210905110614638.png" alt="wait-notify原理"></p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AllocaterNew</span> &#123;</span><br><span class="line">    <span class="comment">// Allocater要保持单例模式，这里使用了饿汉式单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">AllocaterNew</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">AllocaterNew</span> <span class="variable">allocater</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AllocaterNew</span>();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; als = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AllocaterNew <span class="title function_">getAllocater</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> allocater;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(Object a, Object b)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (als.contains(a) || als.contains(b)) &#123;</span><br><span class="line">            <span class="comment">// 不满足条件，进入等待队列</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        als.add(a);</span><br><span class="line">        als.add(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Object a, Object b)</span>&#123;</span><br><span class="line">        als.remove(a);</span><br><span class="line">        als.remove(b);</span><br><span class="line">        notifyAll();<span class="comment">// 唤醒所有线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="安全性、活跃性、性能问题"><a href="#安全性、活跃性、性能问题" class="headerlink" title="安全性、活跃性、性能问题"></a>安全性、活跃性、性能问题</h2><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>即要保证线程安全，就得保证原子性、有序性、可见性</p>
<blockquote>
<p>我们是不是每个对象都得分析它的三性？</p>
</blockquote>
<p>只有一种情况我们需要分析：即分析 <strong>可变的共享对象</strong> 的原子性、安全性、可见性即可</p>
<hr>
<p>此外有两个专业名词：</p>
<ul>
<li><strong>数据竞争</strong>：指的就是可变的共享对象被抢来抢去</li>
<li><strong>竞态条件</strong>：程序的执行结果依赖于线程的执行顺序</li>
</ul>
<h3 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h3><p>活跃性：其实也分了三个问题</p>
<ul>
<li>死锁：前面提到了</li>
<li>活锁</li>
<li>饥饿</li>
</ul>
<blockquote>
<p>什么是活锁？</p>
</blockquote>
<p>活锁就是，类似于线程之间都太客气了，互相谦让对方先使用资源</p>
<p>就和AB两个人进出同一个门一样，A靠右走让B，B靠左走让A，撞了上去</p>
<blockquote>
<p>活锁怎么解决？</p>
</blockquote>
<p>尝试<strong>等待一个随机的时间</strong>就可以了，简单但是很有效</p>
<blockquote>
<p>什么是饥饿？</p>
</blockquote>
<p>线程因无法访问所需资源而无法执行下去的情况</p>
<p>对于优先级低的线程，可能永远也得不到自己的资源，而无法执行</p>
<blockquote>
<p>饥饿怎么解决？</p>
</blockquote>
<p>有三种方案：</p>
<ol>
<li>保证资源充足</li>
<li>避免持有锁的线程长时间进行</li>
<li>公平的分配资源</li>
</ol>
<p>其中1与2是比较难以实现的，资源不可能充足、持有锁的线程也很难缩短</p>
<p>所以只有公平的分配资源，比较好实现（类似于Java的公平锁）</p>
<h3 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h3><p>如果随意的使用锁，会导致性能急剧的下降</p>
<blockquote>
<p>阿姆达尔定律：<code>S = 1 / ((1 - P) +  P / n )</code></p>
<p>n代表CPU核心线程数；</p>
<p>P代表并行百分比；</p>
<p>1-P代表串行百分比；</p>
</blockquote>
<p><img src="http://img.yesmylord.cn//image-20210905113012054.png" alt="阿姆达尔定律"></p>
<p>假设我们的串行率(1-P)为5%，那么无论我们cpu有多少核心（n为无穷大）</p>
<p>S最终也只能为 20%</p>
<p>也就是说，如果串行率为5%，不管我们如何提高性能，最高也只能提高20%</p>
<blockquote>
<p>如何提高性能？</p>
</blockquote>
<ul>
<li>使用无锁的数据结构与算法：比如ThreadLocal、CAS、COW、乐观锁</li>
<li>使用细粒度的锁：分段锁ConcurrentHashMap、读写锁ReadWriteLock</li>
</ul>
<blockquote>
<p>性能的指标：</p>
</blockquote>
<ol>
<li>吞吐量：单位时间内能处理的请求数</li>
<li>延迟：从发出请求到响应的时间</li>
<li>并发量：能同时处理的请求数量</li>
</ol>
<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><code>synchronized</code>的实现其实是<strong>MESA管程模型</strong>的简化版</p>
<p>而JUC包内，LOCK与Condition真正实现了MESA管程模型</p>
<blockquote>
<p>管程是什么？</p>
</blockquote>
<p>英文为Moniter、Java里面叫监视器（知道是啥了吧）</p>
<p>管程就是：<strong>管理共享变量以及对共享变量的操作过程</strong>，<strong>让他们支持并发</strong></p>
<blockquote>
<p>管程干了什么？</p>
</blockquote>
<p>管程通过N个队列来<strong>保证线程之间的互斥与同步</strong>，入队出队操作由其封装</p>
<p><img src="http://img.yesmylord.cn//image-20210905173310258.png" alt="MESA管程模型"></p>
<p>这种管程模型，条件可以有多个，但在Java的实现中，synchronized只有一个条件变量，也就是为什么说是简化版的<code>synchronized</code></p>
<blockquote>
<p>使用<code>wait</code>的正确姿势（这其实就是MESA模型规定的经典姿势）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">	wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>notify</code>如何使用？</p>
</blockquote>
<p>如果你能确定以下三点，就可以使用<code>notify</code>，如果不能请使用<code>notifyAll()</code></p>
<ol>
<li>所有线程都拥有相同的等待条件</li>
<li>等待线程被唤醒后执行相同的操作</li>
<li>只需要唤醒一个线程</li>
</ol>
<h2 id="Java线程的状态转换"><a href="#Java线程的状态转换" class="headerlink" title="Java线程的状态转换"></a>Java线程的状态转换</h2><p>这个图绘制的很好</p>
<p><img src="http://img.yesmylord.cn//image-20210803204224306.png" alt="Java线程方法与状态变化图"></p>
<p>注意：在OS层面，线程是有五个状态的（<strong>新建、就绪、运行、阻塞、终止</strong>）</p>
<p>但是JVM层面，将就绪与运行看做一个状态<code>RUNNABLE</code>（JVM不关心谁被调度了），而将阻塞分为三部分（<code>WAITING</code>、<code>TIMED_WAITING</code>、<code>BLOCKED</code>）</p>
<ul>
<li><p><code>NEW</code>进入<code>RUNNABLE</code>：执行<code>start</code>方法</p>
</li>
<li><p>在OS内部：</p>
<ul>
<li>就绪进入运行状态：获得时间片</li>
<li>运行进入就绪状态：<code>yield()</code>方法</li>
</ul>
</li>
<li><p><code>RUNNABLE</code>与<code>WAITING</code>之间的状态转换：各有三种方式</p>
<ul>
<li><code>wait()</code>、<code>join()</code>、<code>LockSupport.park()</code>（<code>LockSupport</code>是Java中实现Lock的基础）</li>
<li>状态反向：<code>notify()</code>、<code>notifyAll()</code>、<code>LockSupport.unpark(Thread thread)</code></li>
</ul>
</li>
<li><p><code>RUNNABLE</code>与<code>TIMED_WATING</code>状态的相互转换</p>
<ul>
<li>进入超时等待有五种方法<code>wait(long)</code>、 <code>join(long)</code> 、<code>sleep(long)</code>、<code>LockSupport.parkNanos(long)</code>、<code> LockSupport.parkUntil(long deadline)</code></li>
</ul>
</li>
<li><p><code>RUNNABLE</code>与<code>BLOCKED</code>的状态转换：</p>
<ul>
<li>只有一种方式：就是线程等待<code>synchronized</code>的锁</li>
</ul>
</li>
<li><p>进入<code>TERMINATED</code>状态</p>
<ul>
<li>可以通过<code>stop</code>，但是这个方法已经不推荐使用了（Stop会立即杀了线程，但是锁不一定会释放（只会释放隐式锁））</li>
<li>当线程 A 处于 <code>WAITING</code>、<code>TIMED_WAITING </code>状态时，如果其他线程调用线程 A 的 <code>interrupt()</code> 方法，会使线程 A 返回到 <code>RUNNABLE </code>状态，同时线程 A 的代码会触发 <code>InterruptedException</code> 异常，只要捕获这个异常我们就可以</li>
<li>当线程A处于<code>RUNNABLE</code>状态时，可以同步不断的调用<code>isInterrupt()</code>方法，来判断自己是不是被别人叫停了</li>
</ul>
</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>信号量，主要的<code>api</code>有：</p>
<ul>
<li><code>new Semaphore(int permits , [boolean fair])</code>：创建一个信号量，permits代表资源的数量，fair代表创建一个公平锁还是非公平锁，默认为非公平</li>
<li><code>acquire()</code>：会将资源数 -1。如果为0，那么会进入等待状态</li>
<li><code>release()</code>：将资源数 +1</li>
</ul>
<h3 id="信号量为1——互斥量"><a href="#信号量为1——互斥量" class="headerlink" title="信号量为1——互斥量"></a>信号量为1——互斥量</h3><p>当设值信号量为1，就是一个互斥量，和wait notify没有区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现加一操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreX</span> &#123;</span><br><span class="line">    <span class="comment">// 当设值为1，代表这是一个互斥信号量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">// acquire会将信号量的计数器-1</span></span><br><span class="line">            count ++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">            <span class="comment">// release会将信号量的计数器+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号量实现一个对象池"><a href="#信号量实现一个对象池" class="headerlink" title="信号量实现一个对象池"></a>信号量实现一个对象池</h3><p><strong>对象池</strong>，类似于字符串常量池、线程池等等（也可以叫<strong>限流器</strong>）</p>
<p>使用池化的思想，先把对象创建出来，然后使用List保存，具体代码如下    </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用信号量实现一个对象池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ObjPool</span>&lt;T, R&gt; &#123;</span><br><span class="line">    <span class="comment">// T 代表参数 R 代表返回值</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;T&gt; pool;</span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ObjPool</span><span class="params">(<span class="type">int</span> size, T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pool = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;(size);</span><br><span class="line">        <span class="comment">// 这里用了线程安全类Vector</span></span><br><span class="line">        <span class="comment">// 不能使用ArrayList，因为信号量允许多个线程进入临界区，可能会导致并发操作List导致错误</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            pool.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    R <span class="title function_">exec</span><span class="params">(Function&lt;T,R&gt; func)</span>&#123;</span><br><span class="line">        <span class="comment">// Function 接口用来根据一个类型的数据得到另一个类型的数据，</span></span><br><span class="line">        <span class="comment">// 前者称为前置条件，后者称为后置条件</span></span><br><span class="line">        <span class="comment">// 类似于 R apply(T t)</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();<span class="comment">// 获取资源</span></span><br><span class="line">            t = pool.remove(<span class="number">0</span>); <span class="comment">// 永远从队列头取</span></span><br><span class="line">            <span class="keyword">return</span> func.apply(t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            pool.add(t);<span class="comment">// 使用完要把资源还回来</span></span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ObjPool&lt;Long, String&gt; objPool = <span class="keyword">new</span> <span class="title class_">ObjPool</span>&lt;&gt;(<span class="number">10</span> ,<span class="number">2L</span>);</span><br><span class="line">        objPool.exec(t-&gt;&#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">            <span class="keyword">return</span> t.toString();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><blockquote>
<p>读写锁：遵从四个个原则</p>
<ol>
<li>允许<strong>多个线程同时读</strong>共享变量</li>
<li>只允许<strong>一个线程写</strong>共享变量</li>
<li><strong>写操作正在执行，那么不能读</strong></li>
<li><strong>读操作正在执行，那么不能写</strong>（悲观读）</li>
</ol>
</blockquote>
<p>使用到了实现了<code>ReadWriteLock</code>接口的<code>ReentrantReadWriteLock</code>：</p>
<p><code>ReadWriteLock</code>的API有：</p>
<ul>
<li><code>readLock()</code>获取读锁</li>
<li><code>writeLock()</code>获取写锁</li>
<li><code>lock()</code>上锁</li>
<li><code>unlock()</code>释放锁</li>
<li><code>tryLock()</code>：非阻塞的获取锁</li>
<li><code>lockInterruptibely()</code>：如果线程正在等待获取锁，那么这个线程可以响应中断（别的线程可以使用<code>interrupt()</code>中断其操作）<ul>
<li><code>newCondition()</code>：<strong>只有写锁支持生成条件</strong></li>
</ul>
</li>
</ul>
<p>注意：</p>
<p><code>tryLock()</code>和<code>lock()</code>的区别在于：</p>
<ul>
<li><code>tryLock()</code>只是”试图”获取锁, 如果锁不可用, <strong>不会导致当前线程等待, 当前线程仍然继续往下执行代码.</strong> （不会阻塞）</li>
<li><code>lock()</code>方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行.（阻塞）</li>
</ul>
<h3 id="读写锁实现缓存"><a href="#读写锁实现缓存" class="headerlink" title="读写锁实现缓存"></a>读写锁实现缓存</h3><p>下面的实现是一个按需加载的缓存，使用到了<code>ReadLock</code>与<code>WriteLock</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCache</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;K , V&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">rLock</span> <span class="operator">=</span> rwl.readLock();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">wLock</span> <span class="operator">=</span> rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按需加载Cache</span></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(K key)</span>&#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        rLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = cache.get(key);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            rLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(value != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明缓存内存在直接返回</span></span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明缓存内部没，要去数据库读</span></span><br><span class="line">        wLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = cache.get(key);</span><br><span class="line">            <span class="comment">// 再次检查，防止别的线程也修改数据库，进行没必要的修改</span></span><br><span class="line">            <span class="keyword">if</span>(value == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 省略去数据库查询的代码</span></span><br><span class="line">                value = getFromDataBase(key);</span><br><span class="line">                cache.put(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            wLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> V <span class="title function_">getFromDataBase</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="comment">// 省略去数据库查询的代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(K key, V value)</span>&#123;</span><br><span class="line">        wLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            wLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读写锁的升级与降级"><a href="#读写锁的升级与降级" class="headerlink" title="读写锁的升级与降级"></a>读写锁的升级与降级</h3><blockquote>
<p>升级：就是指，在已经获取到读锁的情况下，继续获取写锁</p>
<p>降级：就是指，在已经获取到写锁的情况下，或许读锁</p>
</blockquote>
<p><code>ReentrantReadWriteLock</code><strong>只支持锁的降级，不支持锁的升级</strong></p>
<p>意思是，在已经获取到读锁后，获取写锁，是不可以的！会导致写锁永久等待，而且相关线程都会被阻塞</p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>JDK1.8提出的新锁，提供了三种模式：<strong>写锁、悲观读锁、乐观读锁</strong></p>
<p>在<code>ReentrantReadWriteLock</code>中，提供的读锁，是悲观读的，即在读的过程中，不允许写操作</p>
<p>而<code>StampedLock</code>支持乐观读操作，乐观读就是认为自己读的时候不会发生写的锁，其实就是没有上锁的状态</p>
<p><strong>核心API：</strong></p>
<ul>
<li><code>writeLock() readLock()</code>：获取写锁、读锁（如果加了try代表非阻塞的尝试获取锁），均会返回一个 <strong>stamp</strong>（邮戳）</li>
<li><code>tryOptimisticRead()</code>：获取乐观读锁，返回stamp；如果当前有写锁占用，那么会返回0</li>
<li><code>validate(long stamp)</code>：需要传入stamp，如果当前没有写锁占用，会返回true</li>
<li><code>tryConvertToWriteLock(long stamp)</code>：尝试<strong>锁升级</strong><ul>
<li>如果当前为写锁，返回它的<code>stamp</code></li>
<li>如果当前为悲观读，写锁可用，那么释放读锁，返回写锁的<code>stamp</code></li>
<li>如果当前为乐观读，仅仅只有写锁当前立即可用的时候，才会返回写锁的<code>stamp</code></li>
<li>其他情况<code>stamp</code>全部返回 0</li>
</ul>
</li>
</ul>
<h3 id="StampedLock的官方例子"><a href="#StampedLock的官方例子" class="headerlink" title="StampedLock的官方例子"></a>StampedLock的官方例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line">    <span class="comment">// 一个StampedLock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个点进行移动</span></span><br><span class="line">    <span class="comment">// 1、写锁的案例：</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123;</span><br><span class="line">        <span class="comment">// 写锁是一个排他锁</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算与原点的距离</span></span><br><span class="line">    <span class="comment">// 2、乐观读的案例</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取了一个乐观锁</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x, currentY = y;</span><br><span class="line">        <span class="comment">// 把当前的位置复制一份，防止其他线程修改</span></span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">            <span class="comment">// 如果当前锁没有被写，那么validate返回为true</span></span><br><span class="line">            <span class="comment">// 如果进入这个循环，说明point值已经被修改了，所以要重新获得值</span></span><br><span class="line">            stamp = sl.readLock();<span class="comment">// 加悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试锁升级的案例</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">moveIfAtOrigin</span><span class="params">(<span class="type">double</span> newX, <span class="type">double</span> newY)</span> &#123; <span class="comment">// upgrade</span></span><br><span class="line">        <span class="comment">// Could instead start with optimistic, not read mode</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">ws</span> <span class="operator">=</span> sl.tryConvertToWriteLock(stamp);</span><br><span class="line">                <span class="comment">// 进行锁升级</span></span><br><span class="line">                <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="comment">// 不为0，代表锁升级成功</span></span><br><span class="line">                    stamp = ws;</span><br><span class="line">                    <span class="comment">// 如果锁升级成功，要把新的邮戳给了stamp变量，以便后续释放</span></span><br><span class="line">                    x = newX;</span><br><span class="line">                    y = newY;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果没有升级成功，说明当前被写锁占用</span></span><br><span class="line">                    sl.unlockRead(stamp);</span><br><span class="line">                    <span class="comment">// 释放悲观读锁</span></span><br><span class="line">                    stamp = sl.writeLock();</span><br><span class="line">                    <span class="comment">// 尝试获取写锁，进入等待</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlock(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StampedLock的读写模板"><a href="#StampedLock的读写模板" class="headerlink" title="StampedLock的读写模板"></a>StampedLock的读写模板</h3><p>读模板：乐观锁的实现机制，其实就是通过<code>stamp</code>，如果当前被其他线程修改了，<code>stamp</code>的值会变（类似于ABA问题的解决）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"><span class="comment">// 乐观读</span></span><br><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 读入方法局部变量...</span></span><br><span class="line"><span class="comment">// 校验 stamp</span></span><br><span class="line"><span class="keyword">if</span> (!sl.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 如果当前有写锁修改</span></span><br><span class="line">    <span class="comment">// 升级为悲观读锁</span></span><br><span class="line">    stamp = sl.readLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读入方法局部变量</span></span><br><span class="line">        .....</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放悲观读锁</span></span><br><span class="line">        sl.unlockRead(stamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法局部变量执行业务操作</span></span><br></pre></td></tr></table></figure>

<p>写模板：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写共享变量</span></span><br><span class="line">    ......</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    sl.unlockWrite(stamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StampedLock对比ReentrantReadWriteLock"><a href="#StampedLock对比ReentrantReadWriteLock" class="headerlink" title="StampedLock对比ReentrantReadWriteLock"></a>StampedLock对比ReentrantReadWriteLock</h3><p><code>StampedLock</code>对比<code>ReentrantReadWriteLock</code>有了如下几点的提升：</p>
<ul>
<li>支持了乐观读</li>
<li>支持锁升级</li>
</ul>
<p>但是<code>StampedLock</code>并不能完全替代<code>ReentrantLock</code>，因为还有以下缺点：</p>
<ul>
<li>不支持<code>Condition</code></li>
<li>不是可重入锁</li>
<li>使用 <code>StampedLock</code> 一定不要调用中断操作，如果需要支持中断功能，一定使用可中断的悲观读锁 <code>readLockInterruptibly() </code>和写锁 <code>writeLockInterruptibly()</code></li>
</ul>
<table>
<thead>
<tr>
<th>对比项</th>
<th><code>StampedLock</code></th>
<th><code>ReentrantReadWriteLock</code></th>
</tr>
</thead>
<tbody><tr>
<td>模式</td>
<td>三种：写、悲观读、乐观读</td>
<td>两种：写、悲观读</td>
</tr>
<tr>
<td>支持<code>Condition</code></td>
<td>不支持</td>
<td>只有写锁支持生成</td>
</tr>
<tr>
<td>是否可重入</td>
<td>不可重入</td>
<td>可重入</td>
</tr>
<tr>
<td>锁升级</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>锁降级</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody></table>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>可以实现让一个线程等待其他线程完成后再执行</p>
<p>假设我们要实现一个<strong>对账系统</strong></p>
<p><img src="http://img.yesmylord.cn//image-20210906194144240.png" alt="对账逻辑"></p>
<p>使用<code>CountDownLatch</code>我们可以很好的实现这个案例</p>
<p>核心API：</p>
<ul>
<li><code>new CountDownLatch(int count)</code>：构造一个要等待几个任务的CountDownLatch</li>
<li><code>countDown()</code>：将count值 -1</li>
<li><code>await()</code>：进入阻塞状态，直到count值变为0，才会允许通过</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Order order; <span class="comment">// 模拟订单类</span></span><br><span class="line">Bill bill; <span class="comment">// 模拟账单类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">while</span>(hasBill())&#123;</span><br><span class="line">        <span class="comment">// 计数器初始化为 2</span></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 查询未对账订单</span></span><br><span class="line">        executor.execute(()-&gt; &#123;</span><br><span class="line">            bill = getUnCheckedBill();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 查询派送单</span></span><br><span class="line">        executor.execute(()-&gt; &#123;</span><br><span class="line">            order = getOrder();</span><br><span class="line">            latch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 等待两个查询操作结束</span></span><br><span class="line">        latch.await();</span><br><span class="line">        <span class="comment">// 执行对账操作</span></span><br><span class="line">        <span class="type">Diff</span> <span class="variable">diff</span> <span class="operator">=</span> check(order, bill);</span><br><span class="line">        <span class="comment">// 差异写入差异库</span></span><br><span class="line">        save(diff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不用CountDownLatch我们怎么实现这个案例？</p>
</blockquote>
<p>可以使用两个线程分别执行查订单，查账单的事情，然后调用<code>join()</code>方法，让主线程等待两个线程完成后再继续执行</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>类似于CountDownLatch，为了解决其不能重复使用的问题而提出的</p>
<p>构造方法特别重要，两个参数：第一个就是等待的值，第二个是希望完成后执行的内容（是一个Runnable接口）</p>
<p>有两个核心API：</p>
<ul>
<li><code>await()</code>：执行完成自动将值减去1</li>
<li><code>reset()</code>：不用我们自己调用</li>
</ul>
<h3 id="任务加载Demo"><a href="#任务加载Demo" class="headerlink" title="任务加载Demo"></a>任务加载Demo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">PreTaskThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String task;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">PreTaskThread</span><span class="params">(String task, CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">            <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 假设总共三个关卡</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                    Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(String.format(<span class="string">&quot;关卡%d的任务%s完成&quot;</span>, i, task));</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//cyclicBarrier.reset();// 重置屏障，不需要我们自己调用，await会自己-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本关卡所有前置任务完成，开始游戏...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PreTaskThread</span>(<span class="string">&quot;加载地图数据&quot;</span>, cyclicBarrier)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PreTaskThread</span>(<span class="string">&quot;加载人物模型&quot;</span>, cyclicBarrier)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">PreTaskThread</span>(<span class="string">&quot;加载背景音乐&quot;</span>, cyclicBarrier)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><p>之前说到过，实现<code>Callable</code>接口，实现<code>call</code>方法调用，就可以实现一个有返回值的线程，这个返回值就是一个<code>Future</code>接口对象</p>
<hr>
<p>先来介绍<code>Future</code>接口：<code>Future</code>接口有五个方法</p>
<ul>
<li><code>get()</code>：获取值，如果获取时，线程还没有执行完成，那么会进入阻塞状态</li>
<li><code>get(timeout, timeunit)</code>：设置阻塞的超时时间</li>
<li><code>cancel()</code>：可以取消任务执行</li>
<li><code>isCanceled()</code>：判断任务是否取消</li>
<li><code>isDone()</code>：判断任务是否执行结束</li>
</ul>
<p>而<code>FutureTask</code>就是一个工具类，实现了<code>Future</code>接口，使用看Demo吧</p>
<h3 id="泡茶Demo"><a href="#泡茶Demo" class="headerlink" title="泡茶Demo"></a>泡茶Demo</h3><p><img src="http://img.yesmylord.cn//image-20210911164234074.png" alt="分工图"></p>
<p>最优烧开水程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现烧开水程序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">No09FutureTask</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> FutureTask&lt;String&gt; ft1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">T1Task</span>());</span><br><span class="line">    <span class="keyword">static</span> FutureTask&lt;String&gt; ft2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">T2Task</span>());</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft1);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        System.out.println(ft1.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T1Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1：洗水壶&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;T1：烧开水&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">tea</span> <span class="operator">=</span> ft2.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;T1：拿到茶叶&quot;</span>+ tea);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上茶&quot;</span>+tea;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">T2Task</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T2：洗茶壶&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;T2：洗茶杯&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;T2：拿茶叶&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;普洱&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JUC/" rel="tag"><i class="fa fa-tag"></i> JUC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/02/MySQL/Mysql%E4%B8%8Elimit/" rel="prev" title="MySQL的特殊查询">
                  <i class="fa fa-chevron-left"></i> MySQL的特殊查询
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/05/MySQL/Mysql%E5%AE%9E%E6%88%98/" rel="next" title="Mysql实战">
                  Mysql实战 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备 - 20007839号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hynis</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">19:38</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
