<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32X32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/16X16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic%7CZCOOL+XiaoWei:300,300italic,400,400italic,700,700italic%7CNoto+Serif+SC:300,300italic,400,400italic,700,700italic%7CSource+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/orange/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="引言:   JVM GC部分">
<meta property="og:type" content="article">
<meta property="og:title" content="深入Java虚拟机GC篇">
<meta property="og:url" content="http://yoursite.com/2021/07/26/JVM/%E6%B7%B1%E5%85%A5Java%E8%99%9A%E6%8B%9F%E6%9C%BAGC%E7%AF%87/index.html">
<meta property="og:site_name" content="Hynis">
<meta property="og:description" content="引言:   JVM GC部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210724182434833.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726105210999.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726111603958.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726112559521.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726113814951.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726115023516.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726124053697.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726130334252.png">
<meta property="og:image" content="http://img.yesmylord.cn//image-20210726131443680.png">
<meta property="og:image" content="https://img.yesmylord.cn//image-20240803113159804.png">
<meta property="article:published_time" content="2021-07-26T11:36:12.000Z">
<meta property="article:modified_time" content="2025-07-31T18:09:08.581Z">
<meta property="article:author" content="Hynis">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="GC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.yesmylord.cn//image-20210724182434833.png">


<link rel="canonical" href="http://yoursite.com/2021/07/26/JVM/%E6%B7%B1%E5%85%A5Java%E8%99%9A%E6%8B%9F%E6%9C%BAGC%E7%AF%87/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://yoursite.com/2021/07/26/JVM/%E6%B7%B1%E5%85%A5Java%E8%99%9A%E6%8B%9F%E6%9C%BAGC%E7%AF%87/","path":"2021/07/26/JVM/深入Java虚拟机GC篇/","title":"深入Java虚拟机GC篇"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>深入Java虚拟机GC篇 | Hynis</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hynis</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">156</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">91</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">213</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">

<!-- 网易云外链-->
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1439739102&auto=1&height=66"></iframe>
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>



      <div class="sidebar-panel-container">

        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5Java%E8%99%9A%E6%8B%9F%E6%9C%BAGC%E7%AF%87"><span class="nav-number">1.</span> <span class="nav-text">深入Java虚拟机GC篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GC-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">GC 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFGC%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是垃圾？什么是GC？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">GC相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">标记阶段算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E8%A1%A5%E5%85%85%EF%BC%9Afinalization%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.2.</span> <span class="nav-text">标记阶段的补充：finalization机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize-%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">finalize()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">对象的三种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">对象是否可以回收</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.</span> <span class="nav-text">清除阶段算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">标记-压缩算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">三种清除算法的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">分代收集算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">增量收集算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.7.</span> <span class="nav-text">分区算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.3.8.</span> <span class="nav-text">三色标记算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.</span> <span class="nav-text">GC相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#System-gc-%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">System.gc()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">1.3.2.</span> <span class="nav-text">内存溢出与内存泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.3.3.</span> <span class="nav-text">可能的内存泄漏的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stop-The-World"><span class="nav-number">1.3.4.</span> <span class="nav-text">Stop The World</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">1.3.5.</span> <span class="nav-text">垃圾回收的并行与并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="nav-number">1.3.6.</span> <span class="nav-text">安全点与安全区域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E5%85%A5%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.7.</span> <span class="nav-text">深入引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">GC回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.4.1.</span> <span class="nav-text">垃圾回收器基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8Fvs%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="nav-number">1.4.2.</span> <span class="nav-text">吞吐量vs暂停时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.3.</span> <span class="nav-text">不同的垃圾回收器概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Serial-GC%E2%80%94%E2%80%94%E4%B8%B2%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">1.4.4.</span> <span class="nav-text">Serial GC——串行回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ParNew%E2%80%94%E2%80%94%E5%B9%B6%E8%A1%8C%E5%9B%9E%E6%94%B6"><span class="nav-number">1.4.5.</span> <span class="nav-text">ParNew——并行回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Parallel%E2%80%94%E2%80%94%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="nav-number">1.4.6.</span> <span class="nav-text">Parallel——吞吐量优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS%E2%80%94%E2%80%94%E4%BD%8E%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.4.7.</span> <span class="nav-text">CMS——低延迟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">CMS特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">CMS工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS%E4%BC%98%E4%B8%8E%E5%8A%A3"><span class="nav-number">1.4.7.3.</span> <span class="nav-text">CMS优与劣</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%E2%80%94%E2%80%94%E5%8C%BA%E5%9F%9F%E5%8C%96%E5%88%86%E4%BB%A3%E5%BC%8F"><span class="nav-number">1.4.8.</span> <span class="nav-text">G1——区域化分代式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E5%9F%BA%E6%9C%AC%E4%BA%86%E8%A7%A3"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">G1基本了解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">G1的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Region%EF%BC%9A%E5%8C%96%E6%95%B4%E4%B8%BA%E9%9B%B6"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">Region：化整为零</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.8.4.</span> <span class="nav-text">G1的垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3GC"><span class="nav-number">1.4.8.4.1.</span> <span class="nav-text">一、年轻代GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E3%80%81-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0-YGC"><span class="nav-number">1.4.8.4.2.</span> <span class="nav-text">二、 并发标记+YGC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6"><span class="nav-number">1.4.8.4.3.</span> <span class="nav-text">三、混合回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%81-Full-GC"><span class="nav-number">1.4.8.4.4.</span> <span class="nav-text">四、 Full GC</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E4%B8%8EG1%E7%9A%84%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">CMS与G1的跨代引用问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G1%E7%9A%84%E6%B8%85%E7%90%86%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.6.</span> <span class="nav-text">G1的清理步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E5%AF%B9%E6%AF%94G1"><span class="nav-number">1.7.</span> <span class="nav-text">CMS对比G1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E7%AB%A0%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5"><span class="nav-number">1.8.</span> <span class="nav-text">文章相关链接</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hynis"
      src="http://img.yesmylord.cn//1644852537960.jpg">
  <p class="site-author-name" itemprop="name">Hynis</p>
  <div class="site-description" itemprop="description">A blog about IT knowledge</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">213</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">91</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/YesYourHighness" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YesYourHighness" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1046467756@qq.com" title="E-Mail → mailto:1046467756@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://zouper.cn/" title="https:&#x2F;&#x2F;zouper.cn" rel="noopener" target="_blank">一杯好茶</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.klenkiven.xyz/" title="https:&#x2F;&#x2F;www.klenkiven.xyz&#x2F;" rel="noopener" target="_blank">KlenKiven</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://hourunmeng.github.io/" title="https:&#x2F;&#x2F;hourunmeng.github.io&#x2F;" rel="noopener" target="_blank">润萌</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://flashxin.github.io/" title="https:&#x2F;&#x2F;flashxin.github.io&#x2F;" rel="noopener" target="_blank">flashxin</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/YesYourHighness" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/26/JVM/%E6%B7%B1%E5%85%A5Java%E8%99%9A%E6%8B%9F%E6%9C%BAGC%E7%AF%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.yesmylord.cn//1644852537960.jpg">
      <meta itemprop="name" content="Hynis">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hynis">
      <meta itemprop="description" content="A blog about IT knowledge">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="深入Java虚拟机GC篇 | Hynis">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          深入Java虚拟机GC篇
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-26 19:36:12" itemprop="dateCreated datePublished" datetime="2021-07-26T19:36:12+08:00">2021-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-01 02:09:08" itemprop="dateModified" datetime="2025-08-01T02:09:08+08:00">2025-08-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/JVM/GC/" itemprop="url" rel="index"><span itemprop="name">GC</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <center>
  引言:
  JVM GC部分
</center>

<span id="more"></span>

<h1 id="深入Java虚拟机GC篇"><a href="#深入Java虚拟机GC篇" class="headerlink" title="深入Java虚拟机GC篇"></a>深入Java虚拟机GC篇</h1><h2 id="GC-概述"><a href="#GC-概述" class="headerlink" title="GC 概述"></a>GC 概述</h2><h3 id="什么是垃圾？什么是GC？"><a href="#什么是垃圾？什么是GC？" class="headerlink" title="什么是垃圾？什么是GC？"></a>什么是垃圾？什么是GC？</h3><p>（&gt;_&lt;我是垃圾）</p>
<blockquote>
<p>垃圾：运行程序没有任何指针指向的对象（游离的对象）</p>
</blockquote>
<p>​        GC（Garbage Collection）垃圾回收，程序运行会产生很多垃圾，所以我们需要时不时对垃圾进行回收，回收他们的内存分配给其他对象使用。</p>
<p>​        相较于传统的C/C++，GC也是Java语言的优势，程序员不必再去考虑内存的释放，加快开发效率。</p>
<p>​        对于JVM的运行时数据区，<strong>GC的主战场是堆和方法区</strong>，对于PC、Stack、本地方法栈都没有GC。</p>
<h2 id="GC相关算法"><a href="#GC相关算法" class="headerlink" title="GC相关算法"></a>GC相关算法</h2><p>GC可以分为两个阶段：</p>
<ol>
<li><strong>标记阶段</strong>：标记出垃圾</li>
<li><strong>清除阶段</strong>：对1中标记的垃圾进行清除</li>
</ol>
<h3 id="标记阶段算法"><a href="#标记阶段算法" class="headerlink" title="标记阶段算法"></a>标记阶段算法</h3><p>标记阶段主要讲两个算法：</p>
<ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><blockquote>
<p>引用计数算法：对每一个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。</p>
</blockquote>
<p>一个对象被一个指针引用，那么就会使引用计数器+1，如果去除了这个指针，就会-1，为0时则GC就知道，这个对象可以被清理了。</p>
<p><strong>优点</strong>：实现简单，垃圾对象便于分别；判定效率高，回收没有延迟性</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>需要额外的字段存储计数器，增加了存储空间的开销</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，增大了时间开销</li>
<li>最严重的问题：<strong>无法处理循环引用的情况</strong>，这个缺陷直接<strong>导致JVM没有选择这种算法</strong></li>
</ul>
<p>循环引用，如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; A -&gt; B -&gt; C</span><br><span class="line">     ↑________|</span><br></pre></td></tr></table></figure>

<p>如果我们将<code>P-&gt;null</code>，你会发现ABC的引用计数器还是1，这样GC就永远也不会去去除他们三个。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><blockquote>
<p>可达性分析算法（也叫根搜索算法、追踪性垃圾收集）</p>
</blockquote>
<p>思想：</p>
<ul>
<li><p>以<strong>根集合对象（GC Roots）</strong>为起始点，<strong>从上至下</strong>的方式搜索被根对象集合所连接的目标对象是否可达</p>
<blockquote>
<p>根集合对象GC Roots：一组必须活跃的引用</p>
</blockquote>
</li>
<li><p>存活的对象都会被根节点直接或间接的连接（这条连接的路径叫<strong>引用链</strong>）</p>
</li>
<li><p>如果对象没有被任何引用链连接，则不可达；不可达，则可以回收</p>
</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210724182434833.png" alt="可达性分析算法图示"></p>
<p>目前，此算法是Java、C#语言所选择的GC标记算法</p>
<hr>
<blockquote>
<p>GC Roots可以是哪些元素？</p>
</blockquote>
<ul>
<li>JVM Stack中引用的对象：<strong>方法中使用的参数、局部变量等</strong></li>
<li>JNI（本地方法栈）引用的对象</li>
<li>方法区中类静态属性引用的对象：<strong>静态变量</strong></li>
<li>方法区中常量引用的对象：<strong>字符串常量池的引用</strong></li>
<li>所有被同步锁<code>synchronized</code>持有的对象</li>
<li>JVM内部的引用：基本数据类型对应的Class对象、常驻的异常对象（<code>NullPointException</code>、<code>OutOfMemoryError</code>）、系统类加载器</li>
<li>反应JVM内部情况的JMXBean，JVMTI中注册的回调、本地代码缓存等</li>
<li>除了这些外，<strong>根据用户选用的GC不同、当前回收的内存区域不同，还可能有其他对象“临时性”的加入</strong>，共同构成完整的GC Roots集合。比如<strong>分代收集和局部回收（<code>Partial GC</code>）</strong><ul>
<li>即：如果是对新生代的回收，那么老年代中有的对象也可以成为GCRoots的元素</li>
</ul>
</li>
</ul>
<p><strong>技巧：</strong></p>
<p>​        如果一个指针，指向堆内的对象，但是自己又不在堆内，那么这就是一个GC Root的元素</p>
<p><strong>注意：</strong></p>
<ul>
<li>使用可达性分析算法，<strong>分析工作必须在一个可以保障一致性的快照中进行</strong></li>
<li>这点也是GC时必须<strong>STW</strong>的原因（即使是CMS收集器（号称不会发生停顿的收集器），在枚举根节点时也是要STW的）</li>
</ul>
<h3 id="标记阶段的补充：finalization机制"><a href="#标记阶段的补充：finalization机制" class="headerlink" title="标记阶段的补充：finalization机制"></a>标记阶段的补充：<code>finalization</code>机制</h3><h4 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a><code>finalize()</code>方法</h4><p>Java给对象提供了<code>finalization</code>来让开发人员可以进行对象销毁之前的处理</p>
<p>当GC回收器发现一个对象可以被回收时，会先去调用<code>fianlize()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法可以被重写，用于在对象被回收前进行资源释放</p>
<p><strong>但是注意</strong>永远不要主动调用<code>finalize()</code>方法：</p>
<ul>
<li><code>finalize()</code>方法有可能导致对象复活</li>
<li><code>finalize()</code>方法执行时间没有保障，完全由GC线程决定，极端情况下如果不发生GC，那么<code>finalize()</code>方法就没有执行的机会</li>
<li>一个糟糕的<code>finalize()</code>方法会严重影响GC性能（没错，就是说你写的<code>finalize</code>方法）</li>
</ul>
<p><code>finalize()</code>可能与C++析构函数相似，但是他们有本质的区别，<code>finalize()</code>方法是基于垃圾回收器的<strong>自动内存管理机制</strong>，不需要主动调用</p>
<h4 id="对象的三种状态"><a href="#对象的三种状态" class="headerlink" title="对象的三种状态"></a>对象的三种状态</h4><p>由于<code>finalize()</code>方法的存在，导致对象有三种状态：</p>
<ul>
<li>可触及的：从根节点开始，这个对象可达，就是可触及的</li>
<li>可复活的：对象已经不可达，但是有可能在<code>finalize()</code>中复活</li>
<li>不可触及的：对象的<code>finalize()</code>被调用并且没有复活，就进入此状态；此状态的对象不可能复活，因为<code>finalize()</code>只会调用一次</li>
</ul>
<p>注意只有不可触及状态的对象，才会被回收！</p>
<h4 id="对象是否可以回收"><a href="#对象是否可以回收" class="headerlink" title="对象是否可以回收"></a>对象是否可以回收</h4><p>因为存在三种状态，所以我们要<strong>判断一个对象是否可回收</strong>，要经历<strong>两次标记过程</strong>：</p>
<ol>
<li>是否可达，<strong>第一次标记</strong></li>
<li>是否有必要执行<code>finalize()</code>方法<ul>
<li>没有重写此方法或此方法已调用过：判定为不可触及</li>
<li>重写了此方法且还未执行：此对象会被插入到<code>F-Queue</code>队列中，由一个虚拟机自动创建的、低优先级的<code>Finalizer</code>线程触发其<code>finalize()</code>方法</li>
<li><code>finalize()</code>方法是最后逃离被回收的机会。稍后GC会对<code>F-Queue</code>的对象进行<strong>第二次标记</strong>。如果<code>finalize()</code>方法中，此对象建立了引用，那么在第二次标记时，这个对象会被移除出即将回收的集合；如果这个对象之后<strong>再次</strong>出现不可达的情况，那么会<strong>直接变为不可触及状态</strong>；（<code>finalize()</code>方法<strong>只会被调用一次</strong>）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RebackObject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RebackObject object; <span class="comment">// 类变量，属于GCroot</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 只会调用一次</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        object = <span class="built_in">this</span>; <span class="comment">// 重新建立引用链</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            object = <span class="keyword">new</span> <span class="title class_">RebackObject</span>(); <span class="comment">// 建立引用链</span></span><br><span class="line">            object = <span class="literal">null</span>; <span class="comment">// 失去引用链</span></span><br><span class="line">            System.gc(); <span class="comment">// 调用GC</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第一次 GC&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 等待 finalizer 线程调用finalize方法</span></span><br><span class="line">            <span class="keyword">if</span>(object == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;object is dead&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;object still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// --------------------------------------------</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第二次GC&quot;</span>);</span><br><span class="line">            object = <span class="literal">null</span>; <span class="comment">// 再次失去引用链</span></span><br><span class="line">            System.gc();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span>(object == <span class="literal">null</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;object is dead&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;object still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第一次 GC</span><br><span class="line">object still alive</span><br><span class="line">第二次GC</span><br><span class="line">object is dead</span><br></pre></td></tr></table></figure>

<h3 id="清除阶段算法"><a href="#清除阶段算法" class="headerlink" title="清除阶段算法"></a>清除阶段算法</h3><p>JVM常见的三种垃圾回收算法：</p>
<ul>
<li>标记-清除算法（Mark-Sweep）</li>
<li>复制算法（Copying）</li>
<li>标记-压缩算法（Mark-Compact）</li>
</ul>
<p>还有一些其他的算法：</p>
<ul>
<li>增量收集算法</li>
<li>分区算法</li>
</ul>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><blockquote>
<p>一种基础常见的垃圾收集算法。</p>
<p>提出者——J.McCarthy，应用于Lisp语言</p>
</blockquote>
<p>执行过程：</p>
<p>当有效内存空间（available memory）被耗尽的时候，就会<strong>STW</strong>，然后进行两项工作：</p>
<ol>
<li>标记：回收器从根节点开始遍历，<strong>标记所有被引用的对象</strong>（注意：<strong>标记的是可达对象</strong>）</li>
<li>清除：回收器对堆内存从头到尾进行线性遍历，如果发现某个对象在其<code>Header</code>（对象头）中没有标记为可达对象，则将其回收。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ul>
<li>效率不高</li>
<li>GC时需要STW，用户体验差</li>
<li>清理出的空间内存不连续，产生<strong>内存碎片</strong>，需要维护一个空闲列表</li>
</ul>
<p><strong>注意：</strong></p>
<p>清除不需要置空，只需要标记为空闲即可。下次使用直接覆盖。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>算法思想：</p>
<p>将活着的内存空间<strong>分为两块</strong>：每次只使用一块，在GC时将正在使用的内存中存活对象<strong>复制</strong>到未被使用的内存块中，之后清除正在使用内存块中的<strong>所有对象</strong>，交换两个内存的角色，最后完成回收。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>没有标记和清除的过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，<strong>不会出现碎片问题</strong></li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>需要两倍的内存空间</strong></li>
<li>对于G1这种分拆成为大量rigion的GC回收器，复制而不是移动，意味着GC需要维护<code>region</code>之间对象引用关系，内存占用大，时间开销也大</li>
<li>不利于非垃圾对象多的情况</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>在<strong>新生代</strong>中，有<code>from</code>区和<code>to</code>区，就应用了这种算法；</p>
<p>新生代大部分都是垃圾对象，而且新生代也不大，完美的契合这种算法。</p>
<h4 id="标记-压缩算法"><a href="#标记-压缩算法" class="headerlink" title="标记-压缩算法"></a>标记-压缩算法</h4><p>复制算法利于新生代，但对于老年代这种大内存，需要使用其他算法。</p>
<p>但是标记清除算法效率低下还会产生内存碎片，所以对其进行了改进。</p>
<p><strong>过程：</strong></p>
<ol>
<li>标记（同标记-清除算法）</li>
<li>将所有存活的对象，<strong>压缩到内存的一端并按顺序排放</strong>，之后清理边界外所有的空间。</li>
</ol>
<p>也可以称为<strong>标记-清除-压缩</strong>算法，他与标记-清除算法的区别是：是否对对象进行了移动。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>内存连续（对比标记-清除算法）</li>
<li>内存不需要加倍（对比复制算法）</li>
</ul>
<p>缺点：</p>
<ul>
<li>效率低于复制算法</li>
<li>移动对象时，如果对象被其他对象引用，还需要调整引用的地址</li>
<li>移动过程需要STW</li>
</ul>
<h4 id="三种清除算法的对比"><a href="#三种清除算法的对比" class="headerlink" title="三种清除算法的对比"></a>三种清除算法的对比</h4><table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody><tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（有内存碎片）</td>
<td>少</td>
<td>两倍大小</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><blockquote>
<p>所谓分代收集算法，就是按照不同的代，使用不同的算法。</p>
</blockquote>
<p>目前几乎所有的GC都使用了分代收集算法</p>
<ul>
<li>年轻代<ul>
<li>较小、回收频繁、垃圾多</li>
<li>适用复制算法</li>
</ul>
</li>
<li>老年代<ul>
<li>较大、回收次数少、垃圾少</li>
<li>一般<strong>由标记-清除算法和标记-压缩算法混合实现</strong></li>
</ul>
</li>
</ul>
<p>在Hotspot Vm中，<strong>CMS回收器采用Mark-Sweep算法</strong>，回收效率高。</p>
<p>对于内存碎片问题，CMS采用Mark-Compact算法的<strong>Serial Old回收器</strong>作为补偿：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old 执行Full GC以达到对老年代内存的整理</p>
<h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述所有的清除算法，都会出现STW状态，而长时间的STW严重影响用户体验。</p>
<p>增量收集算法就是为解决STW而提出的一种算法。</p>
<p><strong>基本思想</strong>：</p>
<p>​        一次性清理所有垃圾，需要长时间的STW，那么可以让垃圾收集线程和应用程序线程<strong>交替执行</strong></p>
<p>​        每次，垃圾收集线程<strong>只收集一小片区域</strong>的内存空间，接着就切换到应用程序线程，依次反复，直到垃圾收集完成。</p>
<p>本质上此算法的基础依旧是标记清除算法和复制算法，但是此算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>线程切换和上下文转换的消耗大</strong>，导致垃圾回收的总成本上升，造成系统吞吐量下降。</li>
</ul>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>​        一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。</p>
<p>​        为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。<br>​        分代算法将按照对象的生命周期长短划分成两个部分，<strong>分区算法将整个堆空间划分成连续的不同小区间</strong>。<br>​        每一个<strong>小区间都独立使用，独立回收</strong>。这种算法的好处是可以控制一次回收多少个小区间。</p>
<h4 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h4><p>分为<strong>白、黑、灰</strong>三色，分别标记不可达对象、可达对象、尚未遍历完成的对象</p>
<ol>
<li>初始时，将所有对象标记为白色</li>
<li>将所有GC roots直接关联的对象标记为灰色</li>
<li>遍历这些直接关联的对象，如果一个对象没有子引用对象，就标为黑色；如果有子引用对象，标为灰色</li>
<li>重复第3步</li>
</ol>
<p>可能会有 <strong>浮动垃圾</strong> 和 <strong>漏标</strong>的问题：</p>
<blockquote>
<p>浮动垃圾：标记前不是垃圾，标记后变为垃圾，导致没有GC掉</p>
<p>漏标：标记前是垃圾，但是标记后不是垃圾了，导致被错误的GC掉</p>
</blockquote>
<h2 id="GC相关概念"><a href="#GC相关概念" class="headerlink" title="GC相关概念"></a>GC相关概念</h2><h3 id="System-gc-方法"><a href="#System-gc-方法" class="headerlink" title="System.gc()方法"></a><code>System.gc()</code>方法</h3><ul>
<li>程序员可以使用<code>System.gc()</code>来显示的触发<code>Full GC</code></li>
<li>这个方法相当于调用<code>Runtime.getRuntime().gc()</code>，实际上<code>System.gc()</code>底层也是这么写的</li>
<li>只是提醒，无法保证对垃圾回收器的调用</li>
</ul>
<p>demo如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">GCTest</span>();</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了finalize方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结束，也不会打出“调用了finalize方法！”</p>
<p>因为重写<code>finalize</code>会被另一个低优先度的线程，以此证明<code>System.gc()</code>方法只是提醒JVM进行GC，但是GC回收器的选择还是由JVM来操作。</p>
<p>另外JVM有方法<code>System.runFinalization()</code>强制调用失去引用的<code>finalize()</code>方法</p>
<hr>
<p>还有一些关于GC的demo，便于深入理解GC的时刻</p>
<p>先来两个简单的demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">    <span class="comment">//5MB; 注意这里设置太大，有可能直接分配到老年代，然后会被GC掉</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//[GC (System.gc()) [PSYoungGen: 10375K-&gt;5864K(76288K)]</span></span><br><span class="line">    <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 5864K-&gt;0K(76288K)] ParOldGen: 8K-&gt;5727K(175104K)] 5872K-&gt;5727K(251392K)</span></span><br><span class="line">    <span class="comment">//可以看出： young GC 没有回收掉buffer，而是Full GC时，将数据放到了老年代（老年代8K-&gt;5727K，变大了）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarGC2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">    buffer = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//[GC (System.gc()) [PSYoungGen: 7741K-&gt;128K(76288K)]</span></span><br><span class="line">    <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 128K-&gt;0K(76288K)] [ParOldGen: 5727K-&gt;629K(175104K)]</span></span><br><span class="line">    <span class="comment">// 可以看出 不可达对象 直接就被YGC了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，正常情况下，有引用链的对象，在Full GC后，会被转移到老年代；而没有引用链的对象，就直接被回收了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">localVarGC3</span><span class="params">()</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//[GC (System.gc()) [PSYoungGen: 10375K-&gt;5896K(76288K)]</span></span><br><span class="line">    <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 5896K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;5728K(175104K)]</span></span><br><span class="line">    <span class="comment">// 注意：没有被回收，放在了老年代！是因为buffer还占用着局部变量表的slot槽</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">localVarGC4</span><span class="params">()</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 把槽占用掉</span></span><br><span class="line">    System.gc();</span><br><span class="line">    <span class="comment">//[GC (System.gc()) [PSYoungGen: 7741K-&gt;224K(76288K)]</span></span><br><span class="line">    <span class="comment">//[Full GC (System.gc()) [PSYoungGen: 224K-&gt;0K(76288K)] [ParOldGen: 5728K-&gt;629K(175104K)]</span></span><br><span class="line">    <span class="comment">// 这里就被YGC回收掉了！因为槽被占用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>localVarGC3()</code>方法中的对象，在<code>&#123;&#125;</code>中，按理来说应该被回收，但其实没有，因为<code>buffer</code>变量还占用着局部变量表的slot槽；下面的例子将槽复用后，这个对象就被回收掉了</p>
<h3 id="内存溢出与内存泄露"><a href="#内存溢出与内存泄露" class="headerlink" title="内存溢出与内存泄露"></a>内存溢出与内存泄露</h3><blockquote>
<p>内存溢出OOM：</p>
<p>没有足够的内存使用（即使GC后内存也不够）</p>
</blockquote>
<p>造成OOM的原因有两种：</p>
<ul>
<li>JVM堆内存设置大小不够<ul>
<li>可能存在内存泄露；也可能堆设置的太小了</li>
</ul>
</li>
<li>创建了大量大对象，并且GC收集不了</li>
</ul>
<p>报OOM之前，<strong>通常会执行GC</strong></p>
<ul>
<li><p>如果内存不够，会自动触发一次GC，如果还不够则会报出OOM异常；</p>
</li>
<li><p>如果想创建一个超大的对象，这个对象的内存大小直接<strong>超过了堆大小</strong>，那么JVM不会去触发GC，而是直接OOM</p>
</li>
</ul>
<hr>
<blockquote>
<p>内存泄露（Memory Leak）：</p>
<p>​        <strong>严格来说</strong>，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄露。</p>
<p>​        实际情况中，一些不太好的实践<strong>导致对象的生命周期变长甚至OOM</strong>，也算宽泛意义上的“内存泄漏”。</p>
</blockquote>
<p>​         内存泄露不会立即引起程序崩溃，但是一旦发生内存泄露，程序中的可用内存就会被进一步蚕食，直至耗尽所有内存，最终出现OOM异常（内存泄露有可能导致OOM，但并不一定）</p>
<p><strong>内存泄露的例子</strong>：</p>
<ol>
<li>单例模式：单例的生命周期和应用程序一样长，所以单例程序中，如果用一个单例的对象关联外部对象的引用的话，那么这个外部对象是不能被回收的，会导致内存泄漏的产生。</li>
<li>一些提供close的资源未关闭导致内存泄露：数据库连接、网络连接、io连接等必须手动close，否则是不能被回收的。</li>
</ol>
<h3 id="可能的内存泄漏的原因"><a href="#可能的内存泄漏的原因" class="headerlink" title="可能的内存泄漏的原因"></a>可能的内存泄漏的原因</h3><ol>
<li>静态的集合类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>类的变量的生命周期很长，类信息被回收的条件比较苛刻，需要满足三个条件：1、没有任何实例。2、子类也没有任何实例。3、加载该类的类加载器已被回收</p>
<p>注意：类的静态常量一般属于常量池，其实际的位置在堆中，是可以方便回收的。</p>
<ol start="2">
<li>单例对象</li>
</ol>
<p>单例对象一般是static修饰的，如果其含有外部引用，那么也不会被回收。</p>
<ol start="3">
<li>数据库连接、IO、Socket没有关闭</li>
</ol>
<p>连接如果没有调用<code>close</code>方法关闭，是不会被回收的。</p>
<ol start="4">
<li>hash值发生变化</li>
</ol>
<p>使用HashMap等容器，如果存入之后，对象的hash值发生变化，那么也就找不到对应的对象了，也就无法回收。</p>
<p>（这也是为什么String被设计为不可变类型的原因）</p>
<ol start="5">
<li>ThreadLocal使用不当</li>
</ol>
<p>ThreadLocalMap的Entry是弱引用的，弱引用会在每一次GC时被回收，但是如果创建该线程仍然存活，value还是处于被引用的状态，就不会被回收</p>
<h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><blockquote>
<p>STW：指GC事件中，整个应用线程被暂停，没有响应的状态。</p>
</blockquote>
<ul>
<li>所有的GC回收器都有STW事件</li>
<li>STW由JVM在后台自动发起和自动完成，用户不可见。</li>
</ul>
<h3 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h3><p>操作系统的并发并行：</p>
<ul>
<li>并发：同一个时间段发生；互相抢占资源</li>
<li>并行：同一个时间点发生；不互相抢占资源</li>
</ul>
<p>垃圾回收的并行和并发：</p>
<ul>
<li>并行：多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态<ul>
<li>如：ParNew、Parallel、Scavenge、Parallel Old</li>
</ul>
</li>
<li>并发：用户线程和垃圾收集线程同时进行（注意是一个时间段内，这个时间段内，可能用户线程和垃圾收集线程是来回交替的）<ul>
<li>如：CMS、G1</li>
</ul>
</li>
</ul>
<h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p>程序运行过程，<strong>不是所有的时间点都可以停下进行GC</strong></p>
<blockquote>
<p>安全点（Safe Point）：可以停顿下来进行GC的位置</p>
</blockquote>
<p>安全点的选择很重要：</p>
<ul>
<li>太少，GC等待时间太长</li>
<li>太多，运行时太卡</li>
</ul>
<p>通常会根据 <strong>是否具有让程序长时间执行的特征</strong> 为标准选择安全点。</p>
<p>例如：选择一些执行时间较长的指令，方法调用、循环跳转、异常跳转等</p>
<blockquote>
<p>如何确保GC时所有线程都进入安全点了呢？</p>
</blockquote>
<p>有两种方法：</p>
<ul>
<li><strong>抢先式中断</strong>：（目前没有虚拟机采用）<ul>
<li>首先<strong>中断所有</strong>线程，如果线程不再安全点，<strong>恢复其线程</strong>，让其运行至安全点</li>
</ul>
</li>
<li><strong>主动式中断</strong>：<ul>
<li>设置一个中断标志，各个线程运行到<code>safe point</code>就<strong>主动轮询</strong>这个标志，如果中断标志位真，就将自己进行中断挂起</li>
</ul>
</li>
</ul>
<hr>
<p>如果线程处于<code>Sleep</code>状态或是<code>Blocked</code>状态，也就无法进入到安全区域</p>
<blockquote>
<p>安全区域：</p>
<p>​        一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。</p>
</blockquote>
<p>我们可以把安全区域看作是被扩展了的安全点</p>
<ol>
<li>当线程运行到<code>safe Region</code>的代码时，首先**标识已经进入了<code>Safe Region</code>**，如果这段时间内发生GC，JVM会忽略标识为<code>Safe Region</code>状态的线程</li>
<li>当线程即将离开<code>Safe Region</code>时，会检查JVM是否已经完成GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开<code>Safe Region</code>的信号为止</li>
</ol>
<h3 id="深入引用"><a href="#深入引用" class="headerlink" title="深入引用"></a>深入引用</h3><p>JDK1.2后，引用进行了扩展，分为了四种，其强度依次递减</p>
<ul>
<li>强引用（StrongReference）：强引用下，<strong>不会被GC回收</strong>；会造成内存泄漏</li>
<li>软引用（SoftReference）：系统<strong>将要发生OOM溢出之前</strong>，会将软引用回收，如果回收后依然没有足够的内存，才会抛出OOM</li>
<li>弱引用（WeakReference）：弱引用关联的对象只能生存到下一次GC之前，<strong>无论内存是否充足都会回收弱引用</strong>。</li>
<li>虚引用（PhantomReference）：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。<strong>虚引用的唯一目的是为了在这个对象被GC时收到一个系统通知</strong></li>
</ul>
<p>只有<strong>强可触及对象</strong>不会被GC，<strong>软可触及、弱可触及、虚可触及都可以被回收掉</strong></p>
<p><code>java.lang.ref</code>包下，有四个引用类对象，还有一个是<strong>终结器引用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java:</span><br><span class="line">	lang:</span><br><span class="line">		ref:</span><br><span class="line">			SoftReference</span><br><span class="line">			WeakReference</span><br><span class="line">			PhantomReference</span><br><span class="line">			FinalReference（终结器引用）</span><br></pre></td></tr></table></figure>

<p>而且终结器引用是包内可见，其他全为<code>public</code></p>
<p>下面具体介绍这几个引用：</p>
<hr>
<ol>
<li><strong>强引用</strong>——永不回收</li>
</ol>
<p>特点：</p>
<ul>
<li>强引用可以直接访问对象</li>
<li>强引用指向的对象永远不会被GC，JVM即使抛出OOM，也不会回收强引用对象</li>
<li>强引用很可能导致<strong>内存泄漏</strong></li>
</ul>
<ol start="2">
<li><strong>软引用</strong>——不足才回收</li>
</ol>
<p>特点：</p>
<ul>
<li>用来描述一些还有用但是非必须的对象</li>
<li>只有在即将OOM之前，JVM才会回收这些对象（即使主动调用GC，如果内存还有空闲，就不会清除）</li>
<li>清理软引用时，可以将引用存放到一个引用队列（可选）</li>
</ul>
<p>应用：</p>
<ul>
<li>通常来实现内存敏感的缓存，高速缓存就用到了软引用</li>
</ul>
<p>可以使用<code>java.lang.ref.SoftReference</code>来实现软引用</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;nihao1&quot;</span>);</span><br><span class="line"><span class="comment">// 软引用</span></span><br><span class="line">SoftReference&lt;String&gt; soft = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(str);</span><br><span class="line"><span class="comment">// 销毁强引用</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者直接一行完成</span></span><br><span class="line">SoftReference&lt;String&gt; soft = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;nihao1&quot;</span>));</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>弱引用</strong>——发现即回收</li>
</ol>
<p>特点：</p>
<ul>
<li>只被弱引用关联的对象<strong>只能生存到下一次GC发生为止</strong>（无论内存是否足够）</li>
<li>由于垃圾回收线程的优先级很低，所以不一定很快被回收掉；这种情况可以存活较长时间</li>
</ul>
<p>demo：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line"><span class="comment">// 弱引用</span></span><br><span class="line">WeakReference&lt;String&gt; weak = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(str);</span><br><span class="line"><span class="comment">// 销毁强引用</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>虚引用</strong>——对象回收跟踪</li>
</ol>
<p>特点：</p>
<ul>
<li>也称为幽灵引用、幻影引用</li>
<li>设置虚引用的<strong>唯一目的</strong>：<strong>跟踪垃圾回收进程，在被回收前收到一个系统通知</strong></li>
<li>虚引用<strong>对对象的生命周期没有丝毫影响</strong>：一个对象如果只有虚引用，那么和没有引用一样</li>
<li>虚引用<code>get()</code>方法得不到对象，返回的是一个<code>null</code></li>
<li>使用时<strong>必须和引用队列一起使用</strong>，GC工作时，如果发现对象还有虚引用，那么他会在回收对象后，将这个虚引用加入引用队列，以通知对象回收情况</li>
<li>虚引用可以跟踪对象回收时间，因此可以将一些资源释放操作放置在虚引用中执行和记录</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;nihao&quot;</span>);</span><br><span class="line"><span class="comment">// 虚引用</span></span><br><span class="line">ReferenceQueue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 必须配合引用队列</span></span><br><span class="line">PhantomReference&lt;String&gt; pf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(str, queue);</span><br><span class="line"><span class="comment">// 销毁强引用</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>终结器引用</strong></li>
</ol>
<ul>
<li>用以实现对象的<code>finalize()</code>方法</li>
<li>无需手动编码，内部配合引用队列使用</li>
<li>GC时，终结器引用入队。由<code>Finalize</code>线程通过<strong>终结器引用</strong>找到被引用的对象并调用他的<code>finalize()</code>方法，第二次GC时才回收该对象。</li>
</ul>
<h2 id="GC回收器"><a href="#GC回收器" class="headerlink" title="GC回收器"></a>GC回收器</h2><p>垃圾收集器没有进行太多规范，不同的厂商有不同的定制</p>
<h3 id="垃圾回收器基本概念"><a href="#垃圾回收器基本概念" class="headerlink" title="垃圾回收器基本概念"></a>垃圾回收器基本概念</h3><p>垃圾回收器的分类：</p>
<ul>
<li><p>按照线程数分</p>
<ul>
<li>串行垃圾回收器</li>
<li>并行垃圾回收器</li>
</ul>
</li>
<li><p>按工作模式分</p>
<ul>
<li>并发式垃圾回收器</li>
<li>独占式垃圾回收器</li>
</ul>
</li>
<li><p>按碎片处理方式分</p>
<ul>
<li>压缩式垃圾回收器</li>
<li>非压缩式垃圾回收器</li>
</ul>
</li>
<li><p>按工作内存区间分</p>
<ul>
<li>年轻代垃圾回收器</li>
<li>老年代垃圾回收器</li>
</ul>
</li>
</ul>
<p>性能评价指标：（加粗为重点参考指标）</p>
<ul>
<li><strong>吞吐量</strong>：运行用户代码的时间与总运行时间的比例<ul>
<li>T总运行 = T程序 + T内存回收</li>
</ul>
</li>
<li>垃圾收集开销：吞吐量的补数，垃圾回收时间与总运行时间的比例</li>
<li><strong>暂停时间</strong>：执行GC时，工作线程被暂停的时间</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li><strong>内存占用</strong>：Java堆区占用的内存大小</li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>
</ul>
<h3 id="吞吐量vs暂停时间"><a href="#吞吐量vs暂停时间" class="headerlink" title="吞吐量vs暂停时间"></a>吞吐量vs暂停时间</h3><p>吞吐量大，程序更多时间处于生产状态；暂停时间短，会让用户感觉交互性好，延迟低。</p>
<p>但是吞吐量和暂停时间是<strong>负相关</strong>的，如果以低延迟为优先，那么就要暂停时间短，就要减少GC的时间，但是GC次数更加频繁，从而吞吐量下降；如果以高吞吐量为优先，那么一次GC的时间就会变长，暂停时间就会变大。</p>
<p>现在的标准：<strong>在保证最大吞吐量优先的情况下，降低停顿时间</strong></p>
<h3 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h3><p>经典款：</p>
<ul>
<li>串行回收器：Serial（第一款GC）、Serial Old</li>
<li>并行回收器：ParNew（Serial的并行版本）、<strong>Parallel Scavenge（JDK8）、Parallel Old（JDK8）</strong></li>
<li>并发回收器：CMS、G1（JDK9默认GC）</li>
</ul>
<p>最新款：</p>
<ul>
<li>ZGC、shenandoah GC</li>
</ul>
<p>本节主要对经典款GC做介绍：</p>
<ul>
<li> 新生代收集器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代收集器：Serial Old、Parallel Old、<strong>CMS</strong></li>
<li>整堆收集器：<strong>G1</strong></li>
</ul>
<p>垃圾回收器的配合情况：</p>
<p><img src="http://img.yesmylord.cn//image-20210726105210999.png" alt="垃圾回收器的配合"></p>
<p>关于图的解释：</p>
<ul>
<li>为什么CMS与Serial Old有连接？<ul>
<li>CMS收集时 可能失败，需要Serial Old做后备方案</li>
</ul>
</li>
<li>虚线代表最新版本（截止JDK14）取消的组合；<ul>
<li><strong>红线代表JDK9取消的组合；</strong></li>
<li><strong>绿线代表JDK14取消的组合</strong></li>
</ul>
</li>
<li>CMS用虚线框，代表最新版本JDK14中删除了</li>
</ul>
<p>查看默认的GC：</p>
<ul>
<li><code>-XX:PrintCommandLineFlags</code>查看命令行相关参数，包括使用的GC是什么</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=266429440 -XX:MaxHeapSize=4262871040 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC &lt;- JDK8运行：这里写着使用ParallelGC</span><br></pre></td></tr></table></figure>

<ul>
<li><code>jinfo -flag 相关垃圾回收器参数 进程ID</code></li>
</ul>
<h3 id="Serial-GC——串行回收"><a href="#Serial-GC——串行回收" class="headerlink" title="Serial GC——串行回收"></a>Serial GC——串行回收</h3><blockquote>
<p>Serial 与 Serial Old</p>
</blockquote>
<p>第一款GC收集器，JDK1.3之前新生代的唯一选择</p>
<p>Serial特点：</p>
<ul>
<li>是Hotspot中client模式下的默认<strong>新生代GC</strong></li>
<li>采用<strong>复制算法</strong>、串行回收、STW机制</li>
<li>与Serial Old搭配使用</li>
</ul>
<p>Serial Old特点：</p>
<ul>
<li>Serial Old同样是client模式下的默认老年代GC</li>
<li>使用<strong>标记压缩算法</strong>、串行回收、STW机制</li>
<li>应用有两个：<ul>
<li>与Serial搭配使用</li>
<li>作为CMS的后备垃圾收集方案</li>
</ul>
</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210726111603958.png" alt="Serial与Serial Old"></p>
<p><strong>优势</strong>：</p>
<ul>
<li>简单而高效：单线程的GC王</li>
<li>适用于低配机器：单核CPU机器</li>
</ul>
<h3 id="ParNew——并行回收"><a href="#ParNew——并行回收" class="headerlink" title="ParNew——并行回收"></a>ParNew——并行回收</h3><blockquote>
<p>Serial的多线程版本，Par代表Parallel，New代表只能处理新生代</p>
</blockquote>
<p>特点：</p>
<ul>
<li>复制算法、<strong>并行回收</strong>、STW机制</li>
<li>能与CMS、Serial Old进行组合</li>
</ul>
<p>与Serial Old搭配：</p>
<p><img src="http://img.yesmylord.cn//image-20210726112559521.png" alt="ParNew与Serial Old"></p>
<p>新生代GC频繁，使用并发；老年代GC次数少，用串行节省资源</p>
<blockquote>
<p>ParNew一定比Serial性能高吗？</p>
</blockquote>
<p>如果CPU多核、那么是一定的；如果CPU只有一个核，Serial反而发挥更好。</p>
<h3 id="Parallel——吞吐量优先"><a href="#Parallel——吞吐量优先" class="headerlink" title="Parallel——吞吐量优先"></a>Parallel——吞吐量优先</h3><blockquote>
<p>Parallel Scavenge与Parallel Old：JDK 8 默认GC</p>
</blockquote>
<p>Parallel Scavenge：</p>
<ul>
<li>复制算法、并行回收、STW机制</li>
<li>可以与Serial Old、Parallel Old搭配使用</li>
<li><strong>吞吐量优先</strong></li>
<li><strong>自适应策略</strong>：<ul>
<li>运行过程会对年轻代大小、Eden与Survivor的比例、晋升老年代对象年龄进行调整</li>
</ul>
</li>
</ul>
<p>Parallel Old：</p>
<ul>
<li>标记压缩算法、并行回收、STW机制</li>
</ul>
<blockquote>
<p>与ParNew机制一样？是否多此一举？</p>
</blockquote>
<ul>
<li><p>与ParNew不同，Parallel Scavenge目标是为了达到一个<strong>可控制的吞吐量</strong>，被称为吞吐量优先的垃圾回收器。</p>
</li>
<li><p>而且区别与ParNew，Parallel Scavenge还有<strong>自适应调节策略</strong></p>
</li>
</ul>
<p>Parallel与ParNew对比：</p>
<table>
<thead>
<tr>
<th>GC</th>
<th>ParNew</th>
<th>Parallel</th>
</tr>
</thead>
<tbody><tr>
<td>内存占用</td>
<td>小</td>
<td>较大</td>
</tr>
<tr>
<td>吞吐量</td>
<td>较小</td>
<td>高</td>
</tr>
</tbody></table>
<p>因为高吞吐量的优势，所以Parallel Scavenge适<strong>合执行交互不多的后台计算任务</strong></p>
<p><img src="http://img.yesmylord.cn//image-20210726113814951.png" alt="Parallel Scavenge与Parallel Old"></p>
<h3 id="CMS——低延迟"><a href="#CMS——低延迟" class="headerlink" title="CMS——低延迟"></a>CMS——低延迟</h3><h4 id="CMS特点"><a href="#CMS特点" class="headerlink" title="CMS特点"></a>CMS特点</h4><blockquote>
<p>CMS：Concurrent Mark Sweep JDK1.5推出的强交互GC，也是第一款并发GC</p>
</blockquote>
<ul>
<li><strong>并发GC</strong>：用户线程与垃圾收集线程并发执行</li>
<li><strong>标记清除算法</strong>、<strong>STW机制</strong></li>
<li>目的是<strong>减少暂停时间</strong>，提高交互性</li>
<li>运行在老年代</li>
<li>可以与Serial、ParNew进行搭配</li>
<li>Serial Old是CMS的备选方案</li>
</ul>
<blockquote>
<p>为什么不能与Parallel进行搭配？</p>
</blockquote>
<p>由于使用的框架不同，导致不能搭配使用</p>
<hr>
<h4 id="CMS工作原理"><a href="#CMS工作原理" class="headerlink" title="CMS工作原理"></a>CMS工作原理</h4><p><img src="http://img.yesmylord.cn//image-20210726115023516.png" alt="CMS工作原理"></p>
<p>CMS的工作主要分为四个阶段：</p>
<ul>
<li>初始标记（Initial Mark）：<strong>短暂</strong>的STW，仅仅只标记出GC Roots能<strong>直接关联到的对象</strong></li>
<li>并发标记（Concurrent-Mark）：从第一步找到的直接关联的对象开始，遍历整个对象图，<strong>是整个过程中耗时时间最长的阶段</strong>，但是不需要STW</li>
<li>重新标记（Remark）：确认并发标记期间不能确定是否是垃圾的对象，这部分也<strong>需要STW</strong></li>
<li>并发清除（Concurrent-Sweep）：清除标记阶段判断的依据死亡的对象，释放内存空间</li>
<li>提前GC：达到阈值就开始GC（JDK6+默认阈值为92%）</li>
</ul>
<p>注意：</p>
<ol>
<li><p><strong>即使是CMS，也有STW</strong>，STW发生在初始标记和重新标记两个阶段</p>
</li>
<li><p>另外，由于CMS回收过程中，用户进程依旧在运行，所以要保证有足够的空间使用，因此CMS不能等到老年代满才进行手机，而是<strong>达到一定阈值就开始进行回收</strong>;</p>
<p>如果CMS运行期间预留的内存无法满足程序需要，就会出现<strong>Concurrent Mode Failure</strong>，此时JVM会<strong>采用后备方案</strong>，<strong>临时启用Serial Old收集器来进行老年代的收集</strong></p>
</li>
<li><p>因为CMS为了低延迟与并发，采用标记清除算法，所以会产生内零头（内存碎片），所以CMS只能使用<strong>空闲列表</strong>的方式进行内存分配，不能使用指针碰撞</p>
</li>
</ol>
<blockquote>
<p>为什么CMS采用标记清除算法而不是标记压缩算法？</p>
</blockquote>
<p>CMS主打低延迟与并发，所以如果使用标记压缩算法，除了运行时间会稍长外，最致命的是不能进行并发操作；如果要进行压缩，势必要让对象进行移动，那用户线程就必然不能执行了</p>
<h4 id="CMS优与劣"><a href="#CMS优与劣" class="headerlink" title="CMS优与劣"></a>CMS优与劣</h4><p>优势：并发收集、低延迟</p>
<p>弊端：</p>
<ol>
<li><p>产生<strong>内存碎片</strong>，无法分配大对象时只能进行Full GC</p>
</li>
<li><p><strong>对CPU资源敏感</strong>，会因为用户线程占用CPU资源而导致吞吐量降低</p>
</li>
<li><p>CMS<strong>无法处理浮动垃圾</strong>，而且有可能回收失败</p>
<blockquote>
<p>浮动垃圾：在并发标记阶段，用户线程产生的新的垃圾对象</p>
<p><strong>注意：</strong></p>
<p>并发标记阶段，有不能确认的对象（这里成为怀疑对象），重新标记阶段就是最终确认怀疑对象是否是垃圾</p>
<p>而<strong>浮动垃圾是并发标记阶段前不是垃圾，而后变为垃圾的垃圾</strong></p>
</blockquote>
</li>
</ol>
<h3 id="G1——区域化分代式"><a href="#G1——区域化分代式" class="headerlink" title="G1——区域化分代式"></a>G1——区域化分代式</h3><p>产生背景：</p>
<p>为了进一步的提高吞吐量、降低暂停时间；</p>
<h4 id="G1基本了解"><a href="#G1基本了解" class="headerlink" title="G1基本了解"></a>G1基本了解</h4><blockquote>
<p>G1 （Garbage First）：JDK7引入，JDK9作为默认GC</p>
</blockquote>
<p>Region：</p>
<p>在G1中，把堆分为一个一个Region，而Region进一步的去组成Eden、Survivor、老年代</p>
<p>G1可以跟踪每个Region内<strong>垃圾堆积的价值</strong>（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间，优先回收价值最大的Regin（G1因此得名）</p>
<p><img src="http://img.yesmylord.cn//image-20210726124053697.png" alt="Region构成新生代、老年代"></p>
<p>可见新生代、老年代不再是连续的了</p>
<h4 id="G1的特点"><a href="#G1的特点" class="headerlink" title="G1的特点"></a>G1的特点</h4><ul>
<li>采用<strong>分区算法</strong>，分为一个一个Region，回收的单位是Region<ul>
<li><strong>Region级别是复制算法</strong></li>
<li><strong>整体可以看做标记压缩算法</strong></li>
</ul>
</li>
<li>兼顾并行与并发<ul>
<li>并行：G1回收期间可以和多个GC线程同时工作（此时STW）</li>
<li>并发：G1也可以与用户线程交替执行，部分工作可以和应用线程同时执行</li>
</ul>
</li>
<li>兼顾老年代与年轻代</li>
<li><strong>可预测的停顿时间模型</strong><ul>
<li>相较于CMS的一大优势：除了追求低停顿，还能明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</li>
<li>不需要全局停顿，只需要回收价值最高的Region</li>
</ul>
</li>
<li>对比CMS，<strong>G1还不具有压倒性优势</strong><ul>
<li>有更大的内存占用和额外的负载</li>
</ul>
</li>
<li>提供<strong>三种垃圾回收模式</strong>：YoungGC、Mixed GC、Full GC</li>
</ul>
<h4 id="Region：化整为零"><a href="#Region：化整为零" class="headerlink" title="Region：化整为零"></a>Region：化整为零</h4><p><strong>G1将Java堆划分成越2048个大小相同的独立Region块；每个Region的大小由实际情况而定，整体控制在1MB-32MB之间，且为2的幂次</strong></p>
<p><strong>所有Region的大小是相同的，并且在JVM生命周期内不变</strong></p>
<p>新生代和老年代由Region组成，但不再是物理隔离的了</p>
<p>G1中有四种角色，<strong>一个Region只能属于一个角色</strong>（<strong>角色是可以变化的</strong>）</p>
<p><img src="http://img.yesmylord.cn//image-20210726130334252.png" alt="Region四种角色"></p>
<p>对于H角色我们要详细说明：H其实是Old区的一种，如果要存入的对象大于一个Region的一半，就视为一个H区，JVM对待H区等同于Old</p>
<p>图中Humongous代表矩形对象，是G1新增的内存区域，用来<strong>存储大对象</strong>，如果超过1.5个Region就存放到H中，如果一个H不够，会去找<strong>连续的H</strong>进行存储（<strong>如果没有连续的H，会触发Full GC</strong>）</p>
<p><strong>原因：</strong>在原有的JVM设计下，对于堆中超过新生代的大对象，会直接存放到老年代，但是如果是一个短期的大对象，这样处理显然是不好的，因此划分了H区，H的很多行为都被当做老年代来看待。</p>
<h4 id="G1的垃圾回收机制"><a href="#G1的垃圾回收机制" class="headerlink" title="G1的垃圾回收机制"></a>G1的垃圾回收机制</h4><p>垃圾回收过程主要包括三个环节（最后一个环节作为保护方案）：</p>
<ul>
<li>年轻代GC（Young GC）</li>
<li>老年代并发标记过程（Concurrent Marking）</li>
<li>混合回收（Mixed GC）</li>
<li>Full GC（GC评估失败后的保护机制）</li>
</ul>
<p><img src="http://img.yesmylord.cn//image-20210726131443680.png" alt="G1的垃圾回收过程"></p>
<p>在开始细细阐述每一步之前，先来了解一个概念：</p>
<p>每一个Region不是孤立的，一个Region中的对象很可能被其他任意类型的Region引用。</p>
<p>那么问题来了：如果一个新生代Region只被一个老年代Region引用，我们是不是得花大力气去遍历所有老年代Region？</p>
<p>这样太麻烦了，STW时间会很长很长，因此提出了<strong>记忆集</strong>的概念</p>
<blockquote>
<p><strong>Remembered Set（Rset）：记忆集</strong></p>
</blockquote>
<ul>
<li><strong>每一个Region都有一个Remembered Set</strong></li>
<li>每次Reference类型数据写操作时，都会产生一个<code>Write Barrier</code><strong>写屏障</strong>暂时中断操作，检查将要写入的引用指向的对象<strong>是否和该Reference类型数据在不同的Region</strong><ul>
<li>如果不同，<strong>通过<code>CardTable</code>把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</strong>（CardTable是记忆集的具体实现）</li>
</ul>
</li>
<li>G1垃圾回收器的记忆集的实现实际上是<strong>基于哈希表的</strong>，<strong>key代表的是其他region的起始地址，value是一集合</strong>，<strong>里面存放了对应区域的卡表的索引</strong>，因此G1的region能够通过记忆集知道，当前是哪个region有引用指向了它，并且能知道是哪块区域存在指针指向。（其他GC的收集器就是一个byte数组，只能知道一个区域是否有指针指向，而不能知道是谁指向）</li>
</ul>
<p>因此当进行垃圾收集时，加入Remember Set就可以保证不进行全局扫描也不会有遗漏</p>
<hr>
<p>垃圾回收机制，有四种：</p>
<h5 id="一、年轻代GC"><a href="#一、年轻代GC" class="headerlink" title="一、年轻代GC"></a>一、年轻代GC</h5><p>当Eden区空间耗尽时，G1会启动一次YGC</p>
<p>首先STW，G1创建<strong>回收集</strong>（Collection Set）</p>
<blockquote>
<p>回收集是指需要被回收的内存分段的集合</p>
<p>年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段</p>
</blockquote>
<p>回收过程：</p>
<ol>
<li><p>扫描根</p>
<ul>
<li>根引用连同RSet记录的外部引用作为扫描存活节点的入口</li>
</ul>
</li>
<li><p>更新RSet</p>
<ul>
<li><p>处理<code>dirty card queue</code>中的card，更新RSet</p>
</li>
<li><p>更新完成后，RSet可以准确反映老年代对当前所在内存分段中对象的引用</p>
<blockquote>
<p>脏卡表队列：</p>
<p>对于引用赋值语句，类似于<code>Object obj = object</code>，JVM会在执行这条语句的之前和之后再脏卡表队列中入队一个保存了对象引用信息的Card</p>
<p>在G1 YGC时，G1会对脏卡表队列中所有的card进行处理，更新RSet</p>
<blockquote>
<p>为什么不在引用赋值语句直接更新Rset？</p>
</blockquote>
<p>如果着这样做，RSet处理需要考虑线程同步，复杂而且开销大</p>
</blockquote>
</li>
</ul>
</li>
<li><p>处理RSet</p>
<ul>
<li>识别其中指向<code>Eden</code>的对象</li>
</ul>
</li>
<li><p>复制对象</p>
<ul>
<li>使用复制算法，将存活对象复制到<code>Survivor</code>区的空的内存分段</li>
<li>如果达到年龄阈值，复制到<code>Old</code>区</li>
<li>如果<code>Survivor</code>空间不够，直接晋升至老年代</li>
</ul>
</li>
<li><p>处理引用</p>
<ul>
<li>处理软、虚、最终引用、JNI Weak等各种引用</li>
<li>清空Eden空间</li>
</ul>
</li>
</ol>
<h5 id="二、-并发标记-YGC"><a href="#二、-并发标记-YGC" class="headerlink" title="二、 并发标记+YGC"></a>二、 并发标记+YGC</h5><ol>
<li>初始标记阶段<ul>
<li><strong>STW</strong>，标记从根<strong>直接的可达对象</strong>；</li>
<li><strong>并触发一次YGC</strong></li>
</ul>
</li>
<li>根区域扫描<ul>
<li>标记Survivor区直接可达的老年代区域对象，并标记</li>
<li>必须在YGC之前完成</li>
</ul>
</li>
<li>并发标记<ul>
<li>可以与应用线程同时执行</li>
<li>可能被YGC打断</li>
<li><strong>如果发现一个Region全是垃圾，那这个Region会被立即回收</strong></li>
<li>计算每个Region的<strong>对象活性</strong>（存活对象的比例）</li>
</ul>
</li>
<li>再次标记<ul>
<li><strong>STW</strong>：修正并发标记期间的标记结果（同CMS）</li>
<li>采用比CMS更快的<strong>初始快照算法</strong>（snapshot-at-the-beginning SATB）</li>
</ul>
</li>
<li>独占清理<ul>
<li><strong>STW</strong>；计算每个区域的存活对象和GC的回收比例，进行<strong>排序</strong>，识别可以混合回收的区域</li>
<li><strong>并不会实际去做垃圾的收集</strong></li>
</ul>
</li>
<li>并发清理<ul>
<li>识别并清理完全空闲的区域</li>
</ul>
</li>
</ol>
<h5 id="三、混合回收"><a href="#三、混合回收" class="headerlink" title="三、混合回收"></a>三、混合回收</h5><p>​        当越来越多的对象晋升到<code>old region</code>时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器即Mixed GC（该算法并不是old Gc）</p>
<p>​        除了回收整个<code>Young Region</code>，还会回收一部分的<code>old Region</code>。</p>
<p>注意：<strong>回收是一部分老年代，而不是全部老年代</strong></p>
<p>​        由于前一个阶段，对老年代的垃圾回收价值进行了排序，所以排序越靠前，越会被先回收</p>
<p>​        回收分默认分8次进行（不一定要完全8次，允许一个Region对内存浪费10%），并且只有垃圾占65%时才会对一个Region进行回收</p>
<h5 id="四、-Full-GC"><a href="#四、-Full-GC" class="headerlink" title="四、 Full GC"></a>四、 Full GC</h5><ul>
<li><p>Full GC是一个可能会被触发的过程，并不是一定会有的过程</p>
</li>
<li><p>是一个单线程过程，运行很慢，STW时间很长</p>
</li>
</ul>
<p>导致G1 进行Full GC的原因可能有三个：</p>
<ol>
<li><code>Evacuation</code>时没有足够的<code>to</code>区存放晋升的对象</li>
<li>并发处理过程完成之前空间耗尽</li>
<li>最大GC停顿时间太短，导致在规定的时间间隔内无法完成垃圾回收，也会导致<code>Full GC</code></li>
</ol>
<h2 id="CMS与G1的跨代引用问题"><a href="#CMS与G1的跨代引用问题" class="headerlink" title="CMS与G1的跨代引用问题"></a>CMS与G1的跨代引用问题</h2><blockquote>
<p>跨代引用问题：加入有<strong>老年代执行新生代的引用</strong>，GC时是否需要遍历所有的老年代对象呢？这就是跨代引用问题</p>
</blockquote>
<p>首先需要了解几个结构：卡表、写屏障。</p>
<blockquote>
<p><strong>卡表</strong>：一个字节数组，每一个字节代表一个<strong>卡页</strong>，卡页是一段内存区域（HotSpot实现中一个卡页代表512字节的内存范围），如果卡的范围内存在至少一个外部引用，那么就会置为为1，表示脏页</p>
</blockquote>
<blockquote>
<p><strong>记忆集</strong>：记忆集是专门为了解决跨代引用问题提出的一种理想化的结构，卡表是记忆集的一种具体实现（类似于HashMap与Map的关系）</p>
</blockquote>
<blockquote>
<p><strong>写屏障</strong>：是对象引用在被修改时执行的一段代码。（可以理解为一个机器码级别的AOP，会在对象引用发生变化的时候执行，更改卡表为脏）</p>
</blockquote>
<ul>
<li>CMS中的卡表是一个字节数组，每一个字节代表一段512字节的区域，如果该区域至少存在一个对象存在外部的引用（CMS只会记录老年代指向新生代），就将该位置的卡表置位1,<code>card_table[this_addr &gt;&gt; 9] = 1</code>（当前地址右移9位，代表地址除以512，就是对应卡表的索引位置）</li>
<li>G1的卡表是一个hashMap，key存储了外部region的起始地址，value是一个记录卡表索引号的集合，因此G1的这种结构可以找到哪个Region指向了我。</li>
</ul>
<p><img src="https://img.yesmylord.cn//image-20240803113159804.png" alt="G1的卡表"></p>
<blockquote>
<p>问题：假设没有记忆集这个结构，该如何进行一次YGC呢？</p>
</blockquote>
<p>为了防止年轻代的对象含有老年代的引用，我们需要遍历老年代的所有对象。（成本很大）</p>
<h2 id="G1的清理步骤"><a href="#G1的清理步骤" class="headerlink" title="G1的清理步骤"></a>G1的清理步骤</h2><ul>
<li>初始标记（STW）：标记GCRoots可以直接关联的对象</li>
<li>并发标记：GC线程可以与用户线程同时执行，使用SATB（原始快照算法）扫描的更少</li>
<li>最终标记（STW）：标记遗留的少部分STAB记录</li>
<li>筛选回收（STW）：将各个region按可回收价值排序，选择任意个Region组成回收集合，将依然可以存活的对象复制到新的Region，然后清空对应的Region。</li>
</ul>
<p>与CMS不同的是，G1筛选回收的阶段也需要STW</p>
<blockquote>
<p>问题：并发标记阶段，如何保证用户线程和GC线程互不干扰？</p>
</blockquote>
<p>CMS使用增量更新的方式，G1使用STAB算法</p>
<p>G1每一个Region有两个指针TAMS（Top at Mark Start），两个指针之间的空间用来担任回收期间的新对象分配</p>
<h2 id="CMS对比G1"><a href="#CMS对比G1" class="headerlink" title="CMS对比G1"></a>CMS对比G1</h2><ul>
<li>回收算法：<ul>
<li>CMS是标记清除算法；</li>
<li>G1宏观上是标记压缩算法，微观上是标记复制算法</li>
</ul>
</li>
<li>卡表的设计：<ul>
<li>CMS是一个简单的字节数组（为什么不是bit数组？操作系统最小的取值单位是字节，bit还需要移位操作，会慢一点），只管老年代指向新生代的跨代引用，对于新生代对老年代的引用，在极端情况下需要遍历所有新生代的对象。</li>
<li>G1是一个hashmap，key是其他region的起始地址，value是对应卡表的索引，因此G1可以实现双向的指向</li>
</ul>
</li>
<li>卡表的大小：<ul>
<li>CMS的卡表全局唯一，且只负责老年代指向新生代的引用</li>
<li>G1每一个Region有一个卡表</li>
</ul>
</li>
<li>内存、CPU占用：<ul>
<li>CMS相较于G1要少一些，G1需要额外10%<del>20%的内存来维持GC，这大约需要6</del>8G的堆大小才能安全工作，小内存下，CMS的效果更好</li>
<li>CMS的额外负载要少于G1</li>
</ul>
</li>
<li>STW：<ul>
<li>CMS只有初始标记、重新标记需要STW</li>
<li>G1在初始标记、最终标记、筛选回收都需要STW</li>
</ul>
</li>
<li>其他特性：<ul>
<li>G1可以实现指定时间内的GC</li>
<li>G1可以同时完成新生代与老年代的回收，CMS只可以完成老年代的回收。</li>
<li>G1使用的STAB算法比CMS更快，扫描的内容更少</li>
</ul>
</li>
</ul>
<h2 id="文章相关链接"><a href="#文章相关链接" class="headerlink" title="文章相关链接"></a>文章相关链接</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PJ411n7xZ">尚硅谷JVM教程</a>：强推，最强JVM视频教程</li>
<li><a target="_blank" rel="noopener" href="https://github.com/TangBean/understanding-the-jvm">《深入理解Java虚拟机》阅读笔记</a>：省下看书的时间</li>
<li>《深入理解Java虚拟机》：书还是要看的</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JVM/" rel="tag"><i class="fa fa-tag"></i> JVM</a>
              <a href="/tags/GC/" rel="tag"><i class="fa fa-tag"></i> GC</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/07/24/JVM/%E6%B7%B1%E5%85%A5Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E7%AF%87/" rel="prev" title="深入Java虚拟机内存结构篇">
                  <i class="fa fa-chevron-left"></i> 深入Java虚拟机内存结构篇
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/04/Java/Java%E8%BF%9B%E9%98%B6/" rel="next" title="Java进阶">
                  Java进阶 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">晋ICP备 - 20007839号-1 </a>
  </div>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hynis</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">1.3m</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">18:59</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
