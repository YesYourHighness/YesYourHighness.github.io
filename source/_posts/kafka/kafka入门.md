---
title: kafka入门
date: 2021-10-16 09:00:12
tags:
- kafka
- 消息队列
categories:
- kafka

---

<center>
  引言:
  Kafka入门
</center>

<!-- more -->

# Kafka

可以从其他很多知识中，串联到kafka中，很多设计思想都是相同的。

## 前置知识

### Kafka是什么

Kafka是一款 开源的**消息引擎系统**

> 那么消息引擎是什么？

消息引擎是**一组规范**，可以利用这组规范在不同系统之间传递消息。

说人话即：系统A发送消息给消息引擎系统，系统B从消息引擎系统中读取A发送的消息

![image-20211016091852120](http://img.yesmylord.cn//image-20211016091852120.png)



### 传递消息的步骤

消息引擎主要的作用就是发送消息，消息的格式如何以及如何发送消息是消息引擎的主要设计的内容，也是核心

1. **消息格式**：
   - 可以使用JSON、CSV、XML格式等
   - 也可以直接使用开源序列化框架：Protocol Buffer等
2. **传输模型**：一般来说主要有两种传输模型
   - **点对点模型 (Peer to Peer)**：指的是A发送的消息只可以传输给B（不能有其他系统染指）
   - **发布订阅模型 (Pub / Sub)**：发布订阅机制，有一个**主题**的概念，发送方（发布者）与接收方（订阅者）可以关注同一个主题，相同的主题下接收方可以接收到发送方发送的消息

> **Kafka的选择**

kafka提供两种传输模型，但是其消息格式有一些特殊：

**kafka传输的是纯二进制的字节序列**

（消息是结构化的，但是使用之前要转化为二进制的字节序列）

### 为什么要使用消息引擎

两个原因：

1、为了信息传输的**松耦合**

​		松耦合好理解，系统A发系统B，系统C发系统D，如果不使用消息引擎，直接发送，那么会构成一张复杂的通信图，但是如果使用消息引擎，发送端与接收端就解耦了

2、**削峰填谷**（这也是**根本原因**）

> 何为**削峰填谷**？

​		**上游的服务一般会由很多下游的服务提供**，如果上游的请求量在一瞬间达到了很大的程度，那么很有可能冲垮下游的服务，导致**雪崩**（类似于Redis缓存雪崩的概念）

​		**削峰填谷**就是要将上游的流量以一种**平滑的方式**将数据传输给下游

### 一个上下游例子

>  场景：一个订单系统，它的下级会有很多，比如支付系统、验证登录信息的接口，此时有很多请求突然请求订单系统

- 不使用消息引擎：

​		如果订单系统与下游直接对接，可能就会导致上游突然激增的TPS（每秒事务请求数）压垮下游的支付系统、登录验证接口，进而导致整个系统崩溃等

- 使用消息引擎：

​		而引入Kafka 能够将瞬时增加的订单流量全部**以消息形式保存在对应的主题中**，既不影响上游服务 的 TPS，同时也给下游子服务留出了充足的时间去消费它们

### JMS与Kafka的关系

​		**Java消息服务**(Java Message Service，JMS)是**一组API**，不止Kafka，还有很多消息引擎都实现了这一套API

## kafka基本结构

### Kafka术语

- **主题(Topic)**：发布订阅模型有一个概念**主题**，它存放一类的消息
- 主题划分为多个**分区(Partition)**：每个分区都是一组**有序的消息日志**
  - 生产者生产的消息**只会被发送到一个分区中**（如果一个Topic有2个Partition，只会被发到其中一个中，不在partition0就在partition1）
- **生产者**：即向主题发送消息的客户端
- **消费者**：从主题接收消息的客户端
- **客户端**：统称生产者与消费者
- **Broker**：主题的服务器端（英文的意思是代理；经纪商；代理人），他有两个主要的作用
  1. **接收和处理**客户端发送来的**请求**
  2. 对消息进行**持久化**

### Kafka的物理结构

- 很多PC通过Zookeeper搭建kafka集群
- 一台PC可以有多个Broker
- 一个Broker可以有多个Topic（不同Broker的Topic是一样的）

如图示：（一定要好好看这个图！）

![物理结构](http://img.yesmylord.cn//image-20211016153442425.png)

> 副本与分区的关系：

一个主题有多个分区，一个分区可以有多个副本，如图示，**他们可以不在同一个Broker**

（所以我们如果分析工作原理，完全可以抛开Broker不谈，因为它属于物理结构）

### Kafka工作的三层结构

如图示：

![工作三层结构](http://img.yesmylord.cn//image-20211016144948106.png)

总共有三层：

- 【第一层：**主题层**】
  - 每个主题可以配置M个分区
  - 每个分区又可以配置N个副本
- 【第二层：**分区层**】
  - 每个分区可以有多个副本
  - 但只能有**一个领导者副本**，其他全为追随者副本

- 【第三层：消息层】
  - 分区是一个有序的消息队列，消息的位移从0开始

### Kafka的消费者

> Kafka的Consumer为什么是一组一组的Consumer group？

为了实现P2P模型，前面说到，kafka不仅提供了发布订阅这种模型，而且支持P2P这种方式，因此引入了**消费者组**

一个消费者组中的消费者都是消费相同主题的消费者

这样做也可以**提高整个消费者端的吞吐量**

## Kafka的高可用

Kafka提供高可用的手段主要有两个：

1. **kafka集群**
2. **备份机制**

### kafka集群

即将：Broker进程分配在不同PC上，每台PC都可以运行很多Broker进程，通过Zookeeper将不同的PC联系起来，这样就构建成了kafka集群

> 为什么要这么做？

Broker是可以全部到一台机器上的，但是通常都会分配到不同的机器上

这样可以避免一个PC宕机的时候，其他的PC还能正常工作，依然可以继续对外提供服务

### 备份机制

类似于hadoop、redis、mysql，很多都有备份机制来保证高可用

在Kafka中，每一个主题有很多分区，每一个分区可以配置N个副本

（还是此图）

![物理结构](http://img.yesmylord.cn//image-20211016153442425.png)

在这些副本中，分为两类：

- **领导者副本**（Leader Replica）：负责提供与客户端（消费者与生产者）的服务
- **追随者副本**（Follower Replica）：负责跟进领导者的副本（不提供服务）

（在Redis、Mysql中，从库是可以对外提供读服务的）

（在以前这也被称为master、slave体系（主从体系）但是由于漂亮国某些政治正确的原因，改为Leader Follower这种体系）

> 为什么kafka的主题要分区？

为了解决**伸缩性问题**，即如果leader副本积累了太多的数据，以至于一台Broker都无法存储了

分区就是为了解决伸缩性问题的

> 为什么kafka的追随者副本不设计为可以对外提供读服务呢？（就和redis、mysql一样）

两个原因：

1. 首先mysql是为了负载均衡，平衡主库压力（主库需要负责读写操作），才设计从库来负责读，尽量分摊主库压力；而kafka中，每个Broker分布在不同的PC上，本来就进行了负载均衡
2. 消费者组读取数据，有一个消费者位移，如果follower也要提供读服务的话，那么设计实现会比较复杂（涉及到一致性问题，需要同步leader与follower的进度）

## kafka数据的持久化

> kafka如何持久化数据？

kafka使用**消息日志（log）**来持久化数据，而且是**追加写**（类似于Mysql的bin log）

> 追加写满了怎么办？

kafka将日志又细分为多个**日志段**（Log segment），消息被追加写到最新的日志段中

- 写满后，kafka会**自动切分出**一个新的日志段，并将老的日志段封存起来

- kafka在后台还有**定时任务**会定期的检查老的日志段是否能被删除回收











