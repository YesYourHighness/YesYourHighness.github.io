---
title: Hyperledger Fabric
date: 2022-11-22 10:32:23
tags:
- 区块链
- 超级账本
categories:
- 区块链
---

<center>
引言：Hyperledger Fabric：一个私有的需要许可的区块链
</center>
<!--more-->

# Hyperledger Fabric

Hyperledger是Linux基金会的一个开源项目，负责**超级账本**项目，而Hyperledger fabric（以下简称fabric）是其中之一。

- [Hyperledger Fabric官方文档](https://hyperledger-fabric.readthedocs.io/en/latest/)
- [区块链技术指南](https://yeasy.gitbook.io/blockchain_guide/09_fabric_deploy/intro)

## Fabric特性

- 支持**模块化**：项目的各个细节都可以进行不同的实现（包括共识协议、身份认证、秘钥管理协议等）
- 需要**许可**：与比特币和以太坊不同，需要认证许可（意味着Fabric需要成员之间有基本的信任）
- **CFT**共识协议：不一定要实现BFT，CFT也是可以的
- 智能合约支持的语言：Java、Go、NodeJS

## 关键概念

### 成员服务提供者MSP

> fabric提供了一个**成员服务提供者MSP**来注册新的成员

fabric是一个**私有**的链：意思是不能像比特币或是以太坊那样允许任何节点加入，fabric需要**基本的信任**，因此fabric其实是一个私有的区块链

**MSP用来匹配CA与组织**（下一节网络模型会细说）

### 共享账本

fabric账本子系统包括两个组件：

- **世界状态**：记录给定时间点的账本状态（世界状态就是**账本数据库**）
- **交易日志**：记录产生当前世界状态的所有交易

世界状态+交易日志才能组成完整的账本；**世界状态其实是一个键值数据库**（可以使用任何想使用的KV数据库）；**交易日志不可更换**，因为它只是简单记录世界状态的值

### 资产与账本

**资产**表示所有有形的资产（房产）和无形的资产（古董、知识产权），在fabric中资产是**KV集合**

**账本**是所有状态转变的有序的、防篡改的记录（每一笔交易都会导致状态转变），在fabric中是一条**区块链**，而且对于不同的**通道Channel**有不同的账本

### 链码

> 链码是定义一项或多项资产的软件，以及修改资产的交易指令

fabric中链码其实就是**智能合约**，智能合约即区块链网络外部与内部账本交流的接口；

fabric中的链码可以使用Go、Java、Node实现；

### 通道

**账本的基本单位是通道**（Channel），每个通道内的成员可以共享账本，不同通道内账本则彼此隔离

## fabric网络模型

官网示例了一个基础的网络，这里介绍一下这个网络模型

![network.structure](http://img.yesmylord.cn//network.diagram.1.png)

### 网络的成员

- **组织**：R1、R2、R3、R4表示不同的组织，比如三家银行与一个政府单位
- **CA机构**：CA1、CA2、CA3、CA4每个组织一个，不同组件使用证书表示自己来自于哪一个组织（通过**MSP**匹配CA与组织）
- **节点**：P1、P2、P3，网络中的实际运行者
- **通道**：C1、C2，需要相互交流的组织就分入同一个通道，通道由配置CC1、CC2进行配置
- **账本的副本**：L1、L2每个通道一个账本，存储在对应节点上
- **排序服务**：O4，很多分布式解决一致性的方案就是收集所有节点各自的操作然后统一进行排序，这里也一样
- **网络配置**：NC4，图中只有一个最初的网络配置
- **成员服务提供者MSP**：Membership Service Provider，匹配CA与组织
- **智能合约**：S5、S6
- **客户端应用程序**：A1、A2、A3

### 一、初始化

现在有R1、R2、R3、R4想要搭建一个HyperLedger fabric网络N，其中R4确定为**网络初始者**，**有权利设置网络的初始版本**

![network.creation](http://img.yesmylord.cn//network.diagram.2.png)

如图所示，NC4是初始的网络配置，R4负责管理；网络初始时只提供最基础的排序服务O4；

### 二、添加网络管理员

现在给网络添加管理员R1，帮助R4一起管理网络

![network.admins](http://img.yesmylord.cn//network.diagram.2.1.png)

如图所示，R4添加管理员R1，此时R1和R4都有管理NC4更新网络的权利

### 三、定义联盟

> **联盟**：具有着共同命运的一个群组，一个联盟内的组织需要进行交流或是交易

一般将拥有共同目标的组织归为一个联盟

![network.consortium](http://img.yesmylord.cn//network.diagram.3.png)

管理员可以定义联盟，如图，网络管理员（R1或是R4）将R1与R2归为一个联盟，这个**配置存储在NC4中**，如图中的**X1**

### 四、为联盟创建通道

> 联盟内通过通道进行交流；通道是一个主要的通信机制，通过它联盟的成员可以彼此通信。

![network.channel](http://img.yesmylord.cn//network.diagram.4.png)

如图所示，NC4定义了联盟X1，现在为X1建立通道，R1和R2通过配置文件CC1管理和控制C1

注意排序服务O1也连接到了C1，之后连接到C1的节点都可以与O4通信

通道C1保证了R1与R2之间相互共享信息，但是对R3与R4保密

### 五、添加节点与账本

给网络中的C1通道添加节点P1，并且在P1上保存账本的副本L1

![network.peersledger](http://img.yesmylord.cn//network.diagram.5.png)

**节点是保存区块链账本副本的网络组件**。账本L1物理在P1节点上，但是逻辑上来说他是C1的，因为通道与账本是一一对应的，而节点可以有很多个

CA1给P1颁发证书，标识其为组织R1的组件

### 六、安装与运行智能合约

![network.appsmartcontract](http://img.yesmylord.cn//network.diagram.6.png)

> 智能合约定义了对账本的所有通用的访问模式（就是定义了一组方法），比如A1可以通过调用S5的方法来查询账本的内容

安装运行需要如下几步：

1. **安装**：管理员R1许可，将智能合约S5安装到P1节点上
2. **实例化**：在C1通道上**实例化**S5（因为此时连接到通道C1的组件（除了P1）并不知道S5的存在）实例化后，通道内的所有组件就都知道S5的存在
3. **调用**：此时客户端应用程序A1可以使用智能合约S5通过节点P1访问账本L1

注意以下几点：

- **不需要在每个节点上都安装智能合约**：当一个组织在一个通道中有多个 Peer 节点时，它可以选择哪个节点可以安装智能合约
- 虽然同样都在C1通道上，但是智能合约S5的逻辑（即代码）只能被P1看到，而O4与A1都只能看到S5的输出与输出（**实例化的是智能合约接口，而不是智能合约的实现**）这也可以表明**智能合约逻辑上在通道上，而物理上在节点上**
- 实例化需要附加信息：**背书策略**，只有在R1或R2背书的情况下，交易才能被接受并存储到账本L1上。
- **调用**：客户端应用程序A1通过向智能合约背书策略指定的组织R1、R2所属的节点发送**交易提案**来实现。
- 智能合约：
  - 输入：交易提案
  - 输出：经过背书的交易响应

在调用完成后，交易响应与交易提案打包在一起，形成一个**完整背书的交易**，他们会被分发到整个网络

### 七、完善联盟网络结构

联盟X1中，R2还没添加到网络中，现在为R2添加节点P2，并且在P2中备份账本L1并且安装合约S5，但是**不需要再实例化了**，**实例化只需要发生一次**（这也表示了合约逻辑上在通道上）

![network.grow](http://img.yesmylord.cn//network.diagram.7.png)

现在A1和A2都可以使用节点P1或P2在C1上调用 S5，此时我们就完成了一个基本的网络结构，现在离我们最开始的图就差另外一个通道C2了，过程与此一致

![network.structure](http://img.yesmylord.cn//network.diagram.1.png)

### 节点类型

上面的示例网络中有几种节点类型：

- **记账节点**：每个节点都是记账节点，维护账本
- **背书节点**：每一个**带有智能合约的节点**都可以作为一个背书节点（没有安装），负责对应用的请求进行背书
- **排序节点**：排序节点负责对网络中所有交易进行排序处理，且整理为区块结构
- **证书节点**：提供标准的PKI服务，负责对网络中的所有证书进行管理（签发+撤销）

- 领导节点：如果一个组织在一个通道有多个节点，那么会有一个领导节点，负责将交易从排序节点分发到该组织中的其他记账节点
- 锚节点：如果一个节点需要同另外一个组织的一个节点进行通信的话，那么它可以使用对方组织的通道配置中定义的锚节点



# Hyperledeger Fabric实践

## 环境安装

[前置需求](https://hyperledger-fabric.readthedocs.io/en/latest/prereqs.html#linux-ubuntu-debian-based-distro)：git、go、docker、docker-compose

下载`https://bit.ly/2ysbOFE`脚本，在linux下运行

## 运行测试网络

[参考官方文档](https://hyperledger-fabric.readthedocs.io/en/release-2.3/test_network.html)

运行：

```sh
# 进入test-network文件目录
cd fabric-samples/test-network
# 查看帮助
./network.sh -h 
```

直接运行，注意查看你是否有docker的权限，如果没有记得加`sudo`

```sh
# 删除先前运行的所有容器或工程
./network.sh down
# 启动网络（不会创建channel）
./network.sh up
# 创建通道
./network.sh createChannel [-c 指定名称 默认为mychannel]
```

此时我们就创建了一个Fabric网络：有两个peer节点 + 一个排序节点orderer

然后我们在这个网络上启动一个**链码**（智能合约）

```sh
# -ccn 指定链码名称
# -ccp 指定文件路径
# -ccl 指定编码的语言：go, java, javascript, typescript
./network.sh deployCC -ccn basic -ccp ../asset-transfer-basic/chaincode-go -ccl go
```

**但是**直接运行上面的命令会报错，我们需要去对应的链码路径下安装其依赖

```sh
cd ../asset-transfer-basic/chaincode-go/
go mod vendor
```

[运行链码出错，你可能需要改一下测试文件对应位置的go.mod内的go版本1.14为1.13](https://stackoverflow.com/questions/64315723/hyperledger-fabric-chaincode-installation-on-peer0-org1-has-failed)

然后配置几个与网络交互的环境

```sh
# 1 ${PWD}表示pwd 当前路径位置
export PATH=${PWD}/../bin:$PATH
# 2
export FABRIC_CFG_PATH=$PWD/../config/
```

添加组织1：

```sh
export CORE_PEER_TLS_ENABLED=true
export CORE_PEER_LOCALMSPID="Org1MSP"
export CORE_PEER_TLS_ROOTCERT_FILE=${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt
export CORE_PEER_MSPCONFIGPATH=${PWD}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp
export CORE_PEER_ADDRESS=localhost:7051
# ----分割线---
# 其中 CORE_PEER_TLS_ROOTCERT_FILE与CORE_PEER_MSPCONFIGPATH
# 指向组织1 organizations文件夹中的加密材料
```

初始化账本：

```sh
peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile ${PWD}/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses localhost:9051 --tlsRootCertFiles ${PWD}/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt -c '{"function":"InitLedger","Args":[]}'
```

查询账本内容：

```sh
peer chaincode query -C mychannel -n basic -c '{"Args":["GetAllAssets"]}'
```

输出：

```sh
[{"ID":"asset1","color":"blue","size":5,"owner":"Tomoko","appraisedValue":300},
{"ID":"asset2","color":"red","size":5,"owner":"Brad","appraisedValue":400},{"ID":"asset3","color":"green","size":10,"owner":"Jin Soo","appraisedValue":500},
{"ID":"asset4","color":"yellow","size":10,"owner":"Max","appraisedValue":600},
{"ID":"asset5","color":"black","size":15,"owner":"Adriana","appraisedValue":700},
{"ID":"asset6","color":"white","size":15,"owner":"Christopher","appraisedValue":800}]
```

## 实现一个链码

详见下面两个link，本节不再赘述：

- [链码开发指南见阿里云文档](https://help.aliyun.com/document_detail/141380.html)
- 相关[JavaAPI](https://help.aliyun.com/document_detail/141372.htm?spm=a2c4g.11186623.0.0.281c7727Kau41w#topic-2137073)

以Java代码为例：

一个链码由两个方法组成：`init`与`invoke`方法

```java
public interface Chaincode {
    // 链码在初始化和升级时调用此接口，初始化相关的数据。
    public Response init(ChaincodeStub stub);
    // 主要用于实现链码的内部业务逻辑，您可以在该方法中实现相关的业务
    public Response invoke(ChaincodeStub stub);
}
```

## 如何将应用、链码、Fabric联系在一起

> 如何理解应用、链码、Fabric之间的关系？

链码其实就是Fabric提供的接口，使得应用可以通过链码查询账本，对账本进行增删操作。









