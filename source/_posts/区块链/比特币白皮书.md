---
title: 比特币白皮书
date: 2022-11-01 08:53:23
tags: 
- 区块链
- 比特币
categories: 
- 区块链

---

<center>
引言：中本聪——比特币白皮书
</center>
<!--more-->

# 比特币：一种点对点的电子现金系统

内容参考：

- 中本聪比特币paper

- [区块链技术指南](https://yeasy.gitbook.io/blockchain_guide)

## Abstract

> 比特币：一种纯粹的**点对点peer2peer**的**无需金融机构**介入的**电子现金系统 electronic payments**

本文提出一种使用**p2p网络**解决**双重支出**问题的解决方案，从而避免第三方机构的介入。

> **双重支付double spending**：即一份钱花了两次甚至多次（这是**数字货币**存在的问题，因为数字货币就是一串数字，通常的避免方式是用第三方金融机构，比如银行来鉴定这个数字货币的真伪）

手段：使用p2p网络将事务hash散列在一个不断增长的以**工作量证明proof-of-work**的链上，工作量证明的最长的链一定在CPU算力高的区域，如果攻击者不能完全控制这片高算力池，那么原本的最长链会不断发展，超过攻击者。

## Introduction

传统的解决双重支付的手段是让第三方机构进行校验，这样存在几个问题：

- 限制了小型的交易
- 无法对**不可逆的服务**提供**完全不可逆的交易 Completely non-reversible transactions**

（理解：仲裁机构有着绝对的话语权，如果买卖双方发生纠纷，一定会去寻找仲裁。仲裁调解本身也需要成本，也就导致小型的交易骗局只能让买卖有一方吃亏（限制了小型交易）；对于较为大型的交易，也必须有一个双方都信任的机构，比如碰到老赖，我们只能去法院打官司，如果法官被收买，我们也只能吃亏）

> 即：原本的交易系统是**依赖于信任**的，现有的交易需要政府提供的公信力

比特币的解决措施：解决信任问题，即提供一种基于**密码证明cryptographic proof**而不是信任的电子支付系统（使用密码学替代信任）

## Transactions

> 定义：将一枚**电子硬币electronic coin**定义为一个**数字签名链 digital signatures**

（[图片来自](https://github.com/xiaolai/bitcoin-whitepaper-chinese-translation/blob/master/Bitcoin-Whitepaper-EN-CN.pdf)）

![交易机制](http://img.yesmylord.cn//image-20221101103152433.png)

当所有者1想把一枚货币转给所有者2时（交易），需要在数字签名链的末尾附加上**数字签名**（如图所示）

数字签名的构成：

- 上一笔交易的hash值 
- 新的所有者的公钥

收款人可以验证签名去验证数字签名链的所有权

---

这种方式依然有double spending的问题，解决方式两种：

- 中心化：比如银行、铸币厂，拥有所有交易的记录，可以验证此交易是否存在过
- 去中心化：将所有的交易记录公开，维护一个可以让参与者认同唯一的一个交易历史的系统；若大多数节点可以认同这比交易，那么交易就是正常的

## Timestamp server

这种解决方案起步于一种**时间戳服务器**

> 时间戳服务器的工作方式：为一组记录（一个block）的hash打上时间戳，然后将hash广播出去。每个hash包含着之前的时间戳，形成一个链，如图所示：

![时间戳服务器](http://img.yesmylord.cn//image-20221101110255983.png)

## Proof of Work

> 区块如何避免双重支付？PoW

先了解一下散列函数：

> 散列函数`y=hash(x)`：对于相同的x返回相同的y，但是几乎无法从y反推x
>
> 如果x1与x2差距很小，其y1与y2值差距会相当大（雪崩效应）
>
> 比如sha256：他可以指定前导0，前导0越多，计算量将指数级增加

工作量证明：不断的在区块增加**随机数Nonce**，直到一个满足条件的数值被找到（什么条件？我们指定前缀0的个数）CPU耗费算力得到的结果就是工作量证明，一旦得到工作量证明，这个区块将不能再被更改

![工作量证明](http://img.yesmylord.cn//image-20221101111605900.png)

（从图中我们可以看到，一个区块包含多个交易）

以CPU算力为基础的工作量证明解决了“谁能代表大多数”的问题：如果是基于IP的话，很容易被拥有IP多的人操纵

如果大多数的CPU算力是**诚实honest**的，那么这个诚实链就会发展的很快，如果想要篡改一个已经证明的区块：

- 重新完成那一个区块的证明
- 完成那个区块之后的所有区块链的证明、
- 追上并超过其他的诚实节点

这些条件是极其苛刻的，并且链越长越难以篡改

## Network

网络中的工作步骤：

1. 新的交易向所有node**广播**
2. 每个node将新交易打包到一个**区块block**
3. 每个node计算**工作量证明PoW**
4. 当有一个node找到了PoW，它广播给其他nodes
5. nodes接受这个block当且仅当：其中所有交易有效&&没有double spend
6. nodes向网络中表达接受，在创建下一个block时，将把被接受区块的hash作为新区块的hash

> 当两个node同时完成了PoW时：
>
> 每一个node都始终认为**最长的链**是正确的
>
> 一部分node会接受A，一部分node会接受B（但他们同时会保存另外一个链，产生一个branch）
>
> 当下一个block加入后，更长的链会被认为是正确的，将分支取消掉

> 新的交易不一定要广播到所有node，只要广播到足够多的node，就可以打包一个block

> 如果广播的消息没有发送到某个node，这个node可能会少一个block，不过下一个区块他就会意识到缺失了，并且发出请求去补充区块

## Incentive

奖励机制：为了保证我们有足够多的node的算力的支持，系统内需要提供一定的奖励机制

- **每个block的第一笔交易**：每个block包含很多个交易，但第一个交易比较特殊，它会生成一个新币，被生成者所有。
- **交易费用的差值**：如果一笔交易的输入小于它的输出，那么产生的差值奖励给将此交易打包到block的node

奖励机制也保证，有足够能力的攻击者（即拥有比honest node更多算力的用户）顺从规则比改变规则带来的收益要更多。

## Reclaiming Disk Space

> Merkle树（也称为哈希树）：[链接](https://yeasy.gitbook.io/blockchain_guide/05_crypto/merkle_trie)
>
> ![Merkle树](http://img.yesmylord.cn//image-20221102211057693.png)
>
> 树的特点：
>
> - 叶子结点存储数据或hash值
> - 非叶子节点是其两个子节点内容的hash值
>
> Merkle树的性质：
>
> - 底层数据的任何变动都会逐渐影响到根节点
>
> Merkle树的主要使用场景：（详细内容check链接）
>
> - 证明集合是否存在某个元素
> - 快速比较大量数据
> - 快速定位修改
> - 零知识证明

区块链的存储如图所示：某笔交易之前的交易记录可以丢弃以节省空间，如图删除了Tx2节点（注意到hash2并没有删除！），之前的Tx0，Tx1都被删除

![coin的存储结构](http://img.yesmylord.cn//image-20221101153204589.png)

## Simplified Payment Verification

上面介绍到了Merkle树的结构，就能知道快速的验证交易是否存在很简单。

## Combining and Splitting Value

价值的组合与分割：意思是一个交易可能包含一个或多个输入和最多两个输出

输入：

- 情况1：单笔相对较大的输入
- 情况2：多个小金额的输入

输出：

- 输出到收款方
- 输出到找零方（可能没有这一个输出）

## Privacy

交易使用**公钥匿名**。公众可以看到某某向某某转账，但是没有却不能知道交易双方是谁（像是股票，可以看到时间和交易的金额）

交易者每一笔交易都使用一对新的公司要，以便于他人无法追溯（如果公钥所有者被曝光，那么他的相关交易都会被曝光）







