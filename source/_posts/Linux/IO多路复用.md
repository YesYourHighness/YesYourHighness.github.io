---
title: Unix下的五种IO模型
date: 2022-07-23 18:34:12
tags: 
- Linux
categories: 
- Linux
---

<center>
引言：Unix下的五种IO模型；详细介绍select、poll函数
</center>

<!--more-->

# Unix下的五种IO模型

## Unix下的五种IO模型

对于类Unix操作系统，有五种IO模型

- 阻塞式I/O；
- 非阻塞式I/O；
- I/O复用（`select` 和`poll` ）
- 信号驱动式I/O（`SIGIO` ）
- 异步I/O（POSIX的`aio_` 系列函数）

以UNIX网络编程书上的例子，这里来细说一下各个模型

### 阻塞式IO

所谓阻塞，就是线程一直在等待某个操作的完成，如图所示。

![阻塞式IO](http://img.yesmylord.cn//NeatReader-1658573469148.png)

（此处`recvfrom`理解为一个系统调用即可，它会从内核读取某个数据。而且此处的网络模型为UDP，对比TCP，UDP更易于我们理解IO模型）

1. 进程运行中，发出`recvfrom`调用操作
2. 数据正在从网卡（可能是网卡、声卡、U盘等等地方）复制到内核，没有准备好，进入**阻塞状态**
3. 数据正在从内核复制到用户控件，**阻塞状态**
4. 复制完成，返回数据

阻塞会使一个线程一直处于等待状态，大大限制了我们对线程的使用率

### 非阻塞式IO

如何使线程非阻塞，**轮询 Polling**就是第一种办法

![非阻塞式IO](http://img.yesmylord.cn//NeatReader-1658574008291.png)

所谓轮询如图所示，数据没有准备好，就再次进行系统调用，直到数据准备完成。

1. 进程进行系统调用
2. 数据没有准备好，返回`EWOULDBLOCK`异常（我们无需关心这个异常是什么，只要知道会有信息传递给进程就好）
3. 反复进行调用，直到数据从网卡传递到内核
4. 数据从内核复制到用户空间（这个过程处于**阻塞状态**）
5. 复制完成，返回数据

我们发现这种IO模型有几个特点：

- 依然存在阻塞状态（数据从内核复制到用户空间）
- 虽然避免了阻塞，但是反复进行系统调用，依然占用着CPU，如果每个进程都这么轮询，那么CPU的负载也会很大

### IO多路复用

如何避免轮询占用CPU？我们可以使用一个线程来不断轮询多个进程（这就是所谓**复用**）

![IO多路复用](http://img.yesmylord.cn//NeatReader-1658574013825.png)

类Unix操作系统提供了`select`与`poll`函数（下面会详细介绍这两个函数，此处略带解释）

我们可以想象有这么一个集合，他存放了当前所有处于准备状态的**文件描述符fd**，比如fd1、fd2、fd3等等，然后我们会对这个集合进行不断的遍历（线性遍历）

如果数据1的数据准备好了，那么fd1会被返回，这样对应的进程就会得到执行

1. `select`不断轮询
2. 有一个数据准备完成，变为可读，返回其文件描述符
3. 进程进行系统调用（注意：此时进程才开始第一次系统调用）
4. 数据从内核复制到用户空间（这个过程处于**阻塞状态**）
5. 复制完成，返回数据

总结一下：I/O多路复用技术通过**把多个I/O的阻塞复用到同一个`select`的阻塞上**，从而使得系统在**单线程的情况下可以同时处理多个客户端请求**

### 信号驱动式IO

另一种解决阻塞的方式，就是使用**信号机制**，让内核在描述符就绪时发送`SIGIO` 信号通知我们

![信号驱动式IO](http://img.yesmylord.cn//NeatReader-1658574018409.png)

1. 进程调用`sigaction `系统调用安装一个**信号处理函数**，这个系统调用将会立即返回，并不会使进程阻塞
2. 数据从网卡复制到内核，复制完成后，信号处理函数会返回信号`SIGIO`
3. 进程进行系统调用
4. 数据从内核复制到用户空间（这个过程处于**阻塞状态**）
5. 复制完成，返回数据

### 异步IO

POSIX规范中定义的异步为：告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们

![异步IO](http://img.yesmylord.cn//NeatReader-1658574023111.png)

如图所示，`sio_read`就是一个实现了异步操作的函数，我们给内核传递**文件描述符、缓冲区指针、缓冲区大小**（与`read`相同的三个参数）和文件偏移（与`lseek` 类似），并告诉内核当整个操作完成时**如何通知我们**

1. 进程调用系统调用，异步读取数据，立即返回
2. 等到所有过程完成后，告诉进程

信号驱动式IO和异步IO的区别：

- 信号驱动I/O由内核通知我们**何时开始**一个I/O操作
- 异步I/O模型由内核通知我们I/O操作**何时已经完成**

## 五种IO模型对比

### 阻塞与非阻塞

其实我们仔细看，其实前四种IO模型，在数据从内核copy到内存空间的过程中都是阻塞的

但是我们讨论的一个IO模型是否阻塞，看的是他的数据在从网卡调入到内核的过程

随着时代的进步，慢慢的出现了**零拷贝**的概念，因此从内核copy到内存空间这个过程我们不做讨论

关于零拷贝可以看：[此篇blog](https://www.yesmylord.cn/2021/09/18/Netty/NIO/#%E9%9B%B6%E6%8B%B7%E8%B4%9D)

### 同步与异步

- **同步** I/O**操作** （synchronous I/O opetation）导致请求进程阻塞，直到I/O操作完成
- **异步** I/O**操作** （asynchronous I/O opetation）不导致请求进程阻塞

因此，上面介绍的五种中，前四种是同步的操作，只有最后一种是异步操作。

## select、pselect、poll、epoll函数

### 为什么要仔细介绍IO多路复用的函数？

我们看了五种IO模型，会发现，多路复用不是最完美的IO模型，他还是有一个线程处于轮询状态，如果只有一个线程的话，它的性能甚至还不如非阻塞式IO，那么为什么要大力气介绍多路复用呢？

- 一个线程就可以处理很多个连接，在并发情况下，性能很好
- 适配广泛（对于信号机制来说，如果硬件没有实现这个功能，那么我们是不可能在软件部分实现的），`select`非常适合绝大部分计算机
- 著名的Java通信框架Netty就是基于这种实现

### select函数

`select`函数有五个参数，函数原型如下

```c
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfdp1,
           fd_set *readset,
           fd_set *writeset,
           fd_set *exceptset,
　　　　　　const struct timeval *timeout
);
//返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1
```

头文件`<sys/select.h>` 中定义了`FD_SETSIZE` 常值是数据类型`fd_set` 中的描述符总数，其值通常是1024，**因此`select`函数遍历的函数是有上限的**

这五个参数的作用是：

- `maxfdp1`：指定**待轮询的文件描述符的个数**
- `readset writeset exceptset`：指定我们要让内核询问的读、写和异常条件的描述符集合，如果我们对某一个的条件不感兴趣，就可以把它设为空指针。（顺便提一下：如果这三个指针均为空，我们就有了一个比Unix的`sleep`函数更为精确的定时器（`sleep` 睡眠以秒为最小单位））
- `timeout`：这是一个结构体，如下所示，设置不同的值代表不同的意思
  - 设置为`null`：永远等待下去，直到有一个文件描述符准备好才返回
  - 设置为一个固定时间：在有一个描述符准备好I/O时返回，但不超过设置的时间
  - 设置为0：即轮询，检查描述符后立即返回

```c
struct timeval {
  long   tv_sec;　　/* 秒 */
  long   tv_usec;　　/* 微秒 */
};
```

### pselect函数

`pselect`函数原型和`select`差不多

```c
#include <sys/select.h>
#include <signal.h>
#include <time.h>

int pselect(int maxfdp1,
            fd_set *readset,
            fd_set *writeset,
            fd_set *exceptset,
　　　　　　 const struct timespec *timeout,
            const sigset_t *sigmask
); 
```

`pselect`函数有六个参数：

- `timeout`是一个新的结构体，如下，会发现，它的精度更加准确，**精确到纳秒级别**

```c
struct timespec {
　　time_t tv_sec;/* 秒 */
　　long   tv_nsec;/* 纳秒 */
};
```

- `sigmask`：这是一个指向信号掩码的指针（该参数允许程序先禁止递交某些信号，再询问由这些当前被禁止信号的信号处理函数设置的全局变量，然后调用`pselect` ，告诉它重新设置信号掩码）

第二个参数可能难以理解，有一种场景下，`select`可能会丢失信号，而`pselect`不会，具体可以参看UNIX网络编程卷一

**总的来说**：`pselect`是一个精度更高，更安全可靠的`select`

### poll函数

`poll`函数原型：

```c
#include <poll.h>
int poll(struct pollfd *fdarray,
         unsigned long nfds,
         int timeout
); 
// 返回：若有就绪描述符则为其数目，若超时则为0，若出错则为-1
```

`poll` 将数据分成了三种：**普通**数据（normal）、**优先级带**数据（priority band）和**高优先级**数据（high priority）

划分的条件也有些复杂，这里简单提几种：

- **正规TCP数据**和**所有UDP数据**都被认为是普通数据
- TCP的**带外数据**被认为是优先级带数据（带外数据就是一些通信协议所支持的可选功能）

三个参数如下：

- `fdarray`：这是一个结构体，结构体如下

```c
struct pollfd {
　　int    fd; // 要轮询的文件描述符fd
　　short  events; // 关心的fd事件
　　short  revents;// fd上发生的事件
};
```

`events`是输入，表示关心哪些事件的发生（事件有：普通数据可读、优先级带数据可读等等）

`revents`是输出，表示发生了哪些事件

（关于`events`和`revents`具体的值，参考书籍，这里简单提及）

- `nfds`：决定结构数组中元素的个数
- `timeout`：指定`poll` 函数返回前等待多长时间。它是一个指定应等待毫秒数的正值
  - `INFTIM`：永远等待
  - `0`：立即返回，不阻塞进程
  - `>0`：等待指定数目的毫秒数

总的来说：`poll`与`select`差不多，但是对流设备能提供额外的信息

POSIX对`select` 和`poll` 都有需要，不过前者（`select`）使用得更为频繁

### epoll函数

这里简单说一下`epoll`函数相比于`select`函数的优点，不再详细介绍：

- **支持一个进程打开的socket描述符（FD）不受限制**
- **I/O效率不会随着FD数目的增加而线性下降。**
- **使用mmap加速内核与用户空间的消息传递**

## 参考资料

- UNIX网络编程卷一
- Netty权威指南





