---
title: 网络协议
date: 2020-01-09 17:55:45
tags: 
- 计算机网络
categories: 
- 计算机网络
---

<center>
    引言：【需要更改！TCP见另一篇blog】
    <br>内容有Tcp与Udp的区别，TCP的三次握手四次挥手，及Http的响应头请求头


</center>

<!--more-->

# 基本知识

## 通信要素
1. 连接双方
2. 联系
3. 通信的信息
4. 通信的格式

## 通信分类
1. 单工协议：单向传输，例如：电视机，广播
2. 双工协议：双向传输
   - 半双工：同一时刻只能有单向通信，例如：对讲机
   - 全双工：允许双方通信，例如：手机通话

![image](https://github.com/YesYourHighness/MyPicStore/raw/master/pic1/TcpIp02.jpg)

## 传输方式
1. 单播：目的地址是单一目标，一对一(整个TCP协议)
2. 组播：一定区域内
3. 广播：通知到局域网内所有人


## 协议分类
1. 参考模型OSI：7层，只作参考
2. TCP/IP协议：5层->四层
    - 数据链路层
    - 网络层：IP协议
    - 传输层：TCP-UDP 协议
    - 应用层：HTTP:80，HTTPS:443，ssh:22，FTP:21

![image](https://github.com/YesYourHighness/MyPicStore/raw/master/pic1/TcpIp03.png)
## 传输层中TCP与UDP的区别
### TCP: 稳定，安全，效率低
**TCP是一个全双工**
#### 三次握手：
1. 客户端向服务器端发送连接申请，服务器端确认
2. 服务器端回应可以
3. 客户端确认连接请求

#### 四次挥手：
1. 客户端发送一个结束请求，用来关闭客户到服务器的数据传输。
   
    意思是通俗点是：我客户端没有东西要发给你了，但是你要还有数据没全给我发完，可以继续发，不着急断连接
2. 服务器端接收到结束的请求，先发送确认收到信息的要求

    意思是：客户端你的关闭请求我收到了，但是我还没发完，请你再等等我

3. 服务器端确定发送完成，向客户端发送完成的响应

    意思是：客户端我给你发完了，准备关闭连接了
4. 客户端收到关闭连接的响应，再发送确认。此时服务器端如果没有收到这个确认信息可以重传。收到后，服务器端断开连接，客户端等待后发现没有回复，说明断开连接正常，客户端也断开连接

    意思是：客户端还是不相信网络，再问一句：服务器端你快关闭吧。服务器端关闭，客户端等了一会儿，发现没有回应，服务器端确实关闭了，客户端也关闭了。


### UDP: 不稳定，不安全，效率高
**UDP也是全双工**

不建立连接，知道地址直接发送信息，但是
1. 不保证能发送成功
2. 不保证发送完整
3. 不保证发送内容有顺序


## HTTP协议
是一个半双工

### 请求 
1. 请求行
2. 请求头
3. 请求空行
4. 请求体
```
GET /a.html HTTP/1.1
content-type:application/json
cokkie:uid=100213;jessionid=hdasdklkaj

xxxxxx
```

### 响应
1. 响应行
2. 响应头
3. 空行
4. 响应体

```
HTTP/1.1 200 ok
set-cookie:a=1;
content-type:text/html;
content-length:131563152

<html>
    dskdlasd
</html>
```


# 小demo

运行后在网页输入 `http://127.0.0.1:4000/index.html`,运行成功

```java
package server;

import java.io.*;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class fileServer {
    public static void main(String[] args) throws IOException {
        int port = 4000; // 端口号
        String address = "0.0.0.0";// 地址
        /*
        一个非常特殊的IP地址：0.0.0.0
            这个IP相当于java中的this，代表当前设备的IP。
            1、所有不清楚的主机和目的网络。这里的“不清楚”是指在本机的路由表里没有特定条目指明如何到达。
        　　2、对本机来说，它就是一个“收容所”，所有不认识的“三无”人员，一律送进去。
        　　3、如果在网络设置中设置了缺省网关，那么Windows系统会自动产生一个目的地址为0.0.0.0的缺省路由
        */
        ServerSocket socket = new ServerSocket();
        socket.bind(new InetSocketAddress(address, port));

        for (; ; ) {//死循环
            Socket accept = socket.accept();
            BufferedReader br = new BufferedReader(new InputStreamReader(accept.getInputStream()));
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream()));
            //读取请求行
            String s = br.readLine();
            //获取路径
            String[] str = s.split(" ");
            String path = str[1];
            System.out.println(path);

            //基地址：代表本服务器可以访问的区域，这里存放着我桌面上的一个文件夹，内部有html文件等
            String basePath = "C:/Users/BlackKnight/Desktop/test";
            //从父路径名字符串和子路径名字符串创建新的 File实例
            File file = new File(basePath, path);

            if (!file.exists()) {
                bw.write("HTTP/1.1 404 notfound\r\n");
                bw.write("content-length:9\r\n");
                bw.write("\r\n");
                bw.write("not found");
                bw.flush();
            } else {
                //响应行
                bw.write("HTTP/1.1 200 OK\r\n");
                //响应头
                bw.write("content-length:" + file.length() + "\r\n");
                //响应空行
                bw.write("\r\n");
                bw.flush();
                //响应体
                InputStream is = new FileInputStream(file);
                byte[] buffer = new byte[1024];
                int len;
                while ((len = is.read(buffer)) != -1) {
                    accept.getOutputStream().write(buffer, 0, len);
                }
                accept.getOutputStream().flush();
            }
            accept.close();
            System.out.println("请求完成");
        }

    }
}


```