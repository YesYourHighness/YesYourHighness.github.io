---
title: 进程
date: 2020-12-9 17:55:35
tags:
- 操作系统
- 进程
categories:
- 操作系统
---

<center>
    引言：操作系统中的进程
</center>

<!-- more -->

# 进程

## 进程的基本概念

### 为什么要引入进程？

引入进程是为了更好的**并发**执行任务

> 并发：一定时间内物理机器上有两个或两个以上的程序**同处于开始运行但尚未结束**的状态，并且运行次序不确定



你可能还是不知道为什么要引入进程，别急，慢慢向下看



我们先来看程序顺序执行时的特点：

​	程序顺序执行时的特征：

- **顺序性：**一个程序的各个部分的执行，严格地按照某种先后次序执行；
- **封闭性：**即程序运行时独占全部系统资源

- **可再现性：**当程序重复执行时，都将获得相同的结果。

对比程序顺序执行的状态，程序并发执行有如下特点：

​	程序并发执行时的特征：

- **间断性**：共享系统资源，以及为完成同一项任务而相互合作，形成了相互制约的关系。导致程序会”运行——中断——运行“
- **失去封闭性**：共享资源状态将由多个程序来改变
- **结果不可再现性**：破坏了资源的封闭性，进而导致结果不可再现

![image-20201005190344347](http://img.yesmylord.cn//image-20201005190344347.png)

​		（注意：B中的两段代码只能是顺序执行，非原子操作中间可被打断，所以会出现第三种情况）



在程序顺序执行的阶段不能更好的利用资源，为了提高资源利用率，我们设计了并发执行，但是程序并发执行，会打破程序顺序执行的三个特性（这三个特性还是挺好的，方便我们理解和使用），因此我们提出了**进程**，来帮助我们更好的实现并发



### 进程是什么

有几种主流的引出进程的说法：（没有专业定义来形容进程这个概念）

1. 进程是运行的程序
2. 进程是资源分配的最小单位
3. 进程是调度的独立单位
4. 进程是CPU中运行的二进制码





#### 进程是运行的程序

进程是运行的程序，那势必要和程序来进行一番对比：

- 进程是动态的，有多种状态；程序是静态的（指令的集合）
- 进程有生命周期，有诞生，有消亡；程序可以永久保存
- 进程可以创建其他进程；程序不能



#### 资源分配的单位

程序会按进程为单位来分配资源（内存空间，CPU运行。。。）



#### 资源是调度的单位

这是传统OS的概念了，在引入**线程**之后，进程不再是调度的单位，所以这一条我们可以勾掉了！



### 进程的特征

1. 动态性：由程序的调度而诞生，由撤销而消亡
2. 并发性：多个进程可以一起执行
3. 独立性：进程可以独立运行，是资源分配和调度的单位
4. 异步性：进程按异步方式运行
5. 结构特征：进程由三部分组成（程序、数据、PCB（后面会详细介绍））

### 进程的创建与终止

（这里先简单了解一下进程的创建与终止，在之后会详细阐述）

一个进程的**创建**：

1. 创建PCB
2. 分配内存
3. 转入**就绪状态**并插入到**就绪队列**



一个进程的**终止**：

1. 转变为终止状态并取消执行资格
2. 表格和其他信息暂时由辅助程序保留，供其他进程进行收集
3. PCB清零
4. 系统回收资源



### 进程的状态

三种基本状态：

1. **就绪状态**：具有了除了CPU外的可以运行的全部资源
2. **执行状态**：被CPU执行
3. **阻塞状态**：由于某些原因（请求IO）的等待状态

![image-20201207170241444](http://img.yesmylord.cn//image-20201207170241444.png)

三个状态发现不能满足需要，便又慢慢的引入了其他状态：

4. **创建状态：**创建了PCB，没有分配资源

   <img src="http://img.yesmylord.cn//image-20201005194207721.png" alt="image-20201005194207721" style="width:33%;" />

5. **终止状态：**PCB清零，但是没有回收资源

   <img src="http://img.yesmylord.cn//image-20201005194235651.png" alt="image-20201005194235651" style="width:33%;" />

6. **静止状态：**为了系统和用户对于系统的进一步掌控和调节，引入了**挂起(Suspend)**操作，在挂起后，进入到**静止状态**；与挂起对应的操作是**激活(Active)**状态

   - **静止就绪**（readys）：在就绪状态或者执行状态被挂起，此时不可以在被执行，**仍然缺少除CPU外的资源（内存等），此时被安置在外存中**
   - **静止阻塞**（suspends）:在阻塞状态被挂起

所以总共有**七种**状态，他们的相互转换如图：

![image-20201207170352207](http://img.yesmylord.cn//image-20201207170352207.png)

## 进程控制块（Process Control Block，PCB）

操作系统为了管理进程，设立的一个专门的数据结构——PCB，是操作系统感知进程存在的**唯一标志**



进程与PCB是一一对应的。当创建一个进程时，就是建立一张PCB表；当撤销一个进程时，就是撤销PCB



### 为什么要引入PCB

之前我们介绍过，进程可以并发执行导致了三个问题：**间断性**、失去封闭性、结果不可再现性



PCB的引入最主要的目的就是为了实现**间断性的调用**，除此之外，也可以方便对进程的控制等



### PCB所含的信息

![image-20201005204222358](http://img.yesmylord.cn//image-20201005204222358.png)

由四个部分组成：

- 进程描述信息：
  - 进程标识符**PID**：唯一标识一个进程，一个进程通常有两个标识符
    - 外部标识符：方便用户对进程进行访问，有字母、数字组成，还设有父进程标识及子进程标识
    - 内部标识符：方便系统对进程的使用，数字标识符
  - 用户标识符**UID**：标识拥有当前进程的用户
- 处理机相关信息：
  - 通用寄存器的值：通用寄存器又称用户可视寄存器，存放运行过程中的数据，PCB中也存放有此值，方便进程切换时保留现场信息以便复原现场
  - 程序计数器**PC**的值：程序计数器也叫指令计数器，存放下一条指令的地址
  - 程序状态字**PSW**的值：含有状态信息，条件码、执行方式、中断屏蔽标识等
  - 用户栈指针的值：每一个用户都有一个或多个栈，存放过程和系统调用参数及调用地址
- 进程调度信息：
  - 进程状态：进程的当前状态
  - 进程优先级
  - 进程调度所需的其他信息：如进程调度算法
  - 事件：引起进程调度的原因
- 进程控制信息：
  - 程序和数据的地址
  - 进程同步和通信机制：存放信号量、消息队列指针等等
  - **资源清单**：列出本进程占有的系统资源
  - 链接指针：指出下一个进程PCB的地址



### PCB的作用

PCB主要有以下的作用：

1. 作为独立运行基本单位的标识：OS通过感知PCB来感知进程的存在
2. 可以**实现间断式运行**：PCB保存运行时的现场信息，满足了多道程序环境下的间断性的运行要求
3. 提供进程管理所需要的信息
4. 提供进程调度所需要的信息
5. 实现与其他进程的同步与通信



### 进程转换中PCB的作用





CPU正在运行A进程

<img src="http://img.yesmylord.cn//image-20201005204757440.png" alt="image-20201005204757440" style="width:50%;" />

此时A要进行I/O设备的请求，I/O设备的请求相比CPU的运行速度是非常慢的，所以CPU不可能等待，它会切换到B进程运行

<img src="http://img.yesmylord.cn//image-20201005204935161.png" alt="image-20201005204935161" style="width:50%;" />

切换过程中，会把A进程的现场信息存入到PCB中，并将B进程PCB中的现场信息调入硬件现场

<img src="http://img.yesmylord.cn//image-20201005205059226.png" alt="image-20201005205059226" style="width:50%;" />

此时就切换完成了！



### PCB的组织形式

有三种PCB的组织形式

- 线性方式
- 链接方式
- 索引方式

#### 线性方式

PCB存放在同一个线性表内，每次查找遍历整个线性表。简单、但是查找耗费时间，适合小型的系统

<img src="http://img.yesmylord.cn//image-20201005205411236.png" alt="image-20201005205411236" style="width:15%;" />



#### 链接方式

按不同的状态（运行队列、就绪队列、等待队列）划分为多个队列进行存储，如图

![image-20201005205518901](http://img.yesmylord.cn//image-20201005205518901.png)



#### 索引方式

![image-20201005205605279](http://img.yesmylord.cn//image-20201005205605279.png)



## 进程的调度

这节主要内容：

- **进程的层次结构**
- **进程图**
- **进程的创建**
- **进程的终止**
- **进程的阻塞与唤醒**
- **进程的挂起与激活**



### 进程的层次结构

理解下面的话：（可以使用c语言中的fork()函数来创建进程，理解这个层次关系）

- 进程可以创建进程，所以有父进程和子进程，父子关系在PCB中被表明
- 子进程会继承父进程所拥有的**资源**（父进程打开的文件、分配给父进程的缓冲区等等）
- 子进程被撤销，归还父进程资源；父进程被撤销，子进程**全部**被撤销
- **进程之间没有层次结构**，所有的进程享有共同的地位。
- 进程之间的相互控制关系，靠一个**句柄**



不是说进程之间平等吗？怎么还有控制关系？

​		例如父进程创建了子进程，此时父进程就会有一个**句柄**来控制子进程，但是并不意味着父进程处于更高的层次，因为父进程可以将句柄**转移**给其他进程



### 进程图

先来了解**前趋图**：

> 前趋图：一个有向无循环图。

进程图用来表示进程间的依赖关系，比如：

<img src="http://img.yesmylord.cn//image-20201006191923526.png" alt="image-20201006191923526" style="width:50%;" />

进程S1就与S2**并发运行**，S3的运行需要完成S1和S2，S3到S4同理



再来了解一下**进程图**：

> 进程图：一棵有向树，结点代表进程。一棵树代表一个家族，根节点为该进程家族的祖先

<img src="http://img.yesmylord.cn//image-20201006192147649.png" alt="image-20201006192147649" style="width:50%;" />



进程图与前趋图的差异：

- 前趋图描述的是任务(或进程)之间的**前趋关系**；只有在前趋进程完成后，其后继进程才能运行；

- 在进程图中，创建者和被创建者可以**并发执行**，也可以父进程等待其所有的子进程结束后再执行，这完全取决于创建原语和创建者的需要。 



### 进程的创建

进程不会无缘无故被创建的，所有创建进程都是来源于**一个事件**，主要有以下四种事件：

1. **用户登录**
2. **作业调度**
3. **提供服务**
4. **应用请求**

其中，前三个都是OS内核创建的进程，第四个是由用户程序创建的进程

---

当系统接收到这种事件时，便会开始创建进程，通过一个**Create原语**

> 原语：指多条命令组成的不可中断的过程。要么全部做，要么全部不做。在执行过程中不允许被中断

创建过程：

1. 申请**空白的PCB**：申请一个唯一的PID，从PCB集合获得一个空白的PCB
2. **分配资源：**如内存、文件、I/O和CPU时间等。（需求要在创建时提前告知OS或者是父进程）
3. **初始化PCB**：
   1. 初始化标识信息：PID以及父进程标识
   2. 初始化处理器状态信息：使PC（程序计数器）指向程序入口地址，并将栈指针指向栈顶
   3. 初始化处理机控制信息：将进程的状态设置为就绪或者默认就绪，默认将该进程的优先级设置为最低
4. **视情况决定是否插入就绪队列**



### 进程的终止

进程会被以下情况终止：

1. 正常结束
2. 异常结束：出现异常（越界、保护、非法指令等等）
3. 外界干预：
   1. 操作员或者OS进行干预
   2. 父进程请求终止子进程
   3. 因父进程终止，而终止子进程

----

终止过程调用**destroy原语**：

1. 根据PID，查找PCB集合，读出对应PCB的状态
2. 如果处于执行状态，立即中止执行，置调度标志位真，指示操作系统重新进行调度
3. 如果有子孙进程，那么杀死子孙进程
4. 归还全部资源给操作系统或者父进程
5. 将PCB从所在队列中移出，等待其他程序收集信息
6. 回收PCB



### 进程的阻塞与唤醒

引起进程阻塞与唤醒的事件：

1. 请求系统服务：例如请求的资源被占用，CPU不会等待该进程，而是切换进程来执行
2. 等待某种操作完成：例如进程请求IO
3. 新数据尚未到达：相互合作的进程，有必要的数据还未传递
4. 无任务可做

---

**阻塞原语Block**：

1. 保留CPU现场，保存在PCB的现场保护区
2. 切换状态为阻塞状态
3. 插入阻塞队列
4. 等待调度



**唤醒原语wakeup**：

1. 从相应队列中获取PCB
2. 设置进程状态为就绪
3. 将PCB插入就绪队列
4. 等待调度



注意：

1. **block必须与wakeup语句成对使用**
2. **阻塞一定会引起进程调度，但是唤醒却不一定会导致进程调度**（有可能当前CPU忙碌，这个进程排到了就绪队列的末尾）



### 进程的挂起与激活



引起挂起的事件：

1. 终端用户的需求
2. 父进程的请求
3. 负荷调节的需求
4. OS的需求

---

**挂起suspend**：

1. 检查被挂起进程的状态：
   - 就绪->静止就绪
   - 阻塞->静止阻塞
2. 将PCB复制到某指定的内存区域，方便考察该进程的运行状况



**唤醒active**：

1. 将进程**从外存调入内存**
2. 检查状态：
   - 静止就绪->就绪
   - 静止阻塞->阻塞



## 进程同步

### 为什么要进程同步？

第一节我们说到了，进程并发会有三个问题：间断性、**失去封闭性**、**结果不可再现**

PCB的使用解决了间断性这一个问题，但是还有两个问题没有解决。

#### 两种形式的制约关系

失去封闭性：是要解决共享资源的问题，进程队友共享的资源只能进行**互斥**的访问，这里也把这种进程的制约关系叫做**间接相互制约关系**



结果不可再现：是要解决进程异步运行的问题，进程之间也会有互相配合实现作业的时候，但是进程是异步运行的，这种制约关系也叫作**直接相互制约关系**



进程同步**通过使进程之间按照一定的规则使用共享资源**，可以解决**失去封闭性**、和**结果不可再现**这两个问题



### 进程同步问题：生产者与消费者问题

> 问题描述：
>
> ​		有一群生产者进程在生产产品，并将这些产品提供给消费者进程去消费。为使生产者进程与消费者进程能并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池（循环缓冲），生产者进程将它所生产的产品放入一个缓冲区中；消费者进程可从一个缓冲区中取走产品去消费。

用伪代码来模拟这个过程：

数据定义：

> 1）item buffer[n]	表示具有n个(0，1，…，n-1)缓冲区的缓冲池。
> 2）输入指针 in:   	   下一个可投放产品的缓冲区。  in= (in+1) % n；
> 3）输出指针 out：	    下一个可从中获取产品的缓冲区  out= (out+1) % n。
> 4）整型变量 counter：生产者和消费者两进程共享,初始值为0; 
> 			生产者进程向缓冲池中投放一个产品后，使counter加1；
> 			消费者进程从中取走一个产品时，使counter减1；
> 5）局部变量 nextp：	存放每次刚生产出来的产品；
> 6）局部变量 nextc：	存放每次要消费的产品。 

生产者进程：

```c
 while (1){
     produce an item in nextp；// 生产产品，放入nextp中
     while (counter==n);	//满足条件代表缓冲池已满，此时死循环，停止生产
     buffer[in]=nextp；		//将产品放入缓冲池中
     in=(in+1)%n;			//重置下一个可以存放的缓冲区		
     counter++;				//将缓冲池+1，表示缓冲池多了一个产品
  }
```

消费者进程：

```c
while (1) {
    while(counter==0) ;		//当缓冲池满时，开始消费
    nextc=buffer[out];		//从缓冲池提取产品到nextc
    out=(out+1)  % n;		//重置下一个缓冲区地址
    counter--;				//缓冲池产品-1
    consumer the item in nextc;//对nextc进行消费
} 
```

此时，我们思考，如果消费者与生产者并发运行，会出现什么情况？

假设编译后的机器指令如下：

```
             A  register1:=counter；     　                           D register2:=counter；
生产者：B  register1:=register1+1；　             消费者:  E register2:=register2-1；
             C counter:=register1；     　                             F counter:=register2； 
```

如果顺序执行，肯定没有问题，但是并发执行时，就会出现问题，例如假设count为5，按以下顺序执行：

```
执行顺序：A -> B -> D -> E -> C -> F
count数： 5      5       5      5      6      4
r1或r2：    5      6       5      4      6      4
```

这样就乱套了，我们发现，生产者与消费者各执行一次，最后count数量少了1，这是肯定不正确的

这里的counter就是共享资源，也叫**临界资源**，需要进行**互斥的访问**！对counter的所有操作我们称这个区域为**临界区（Critical Section）**，进入临界区的区域叫做**进入区**，响应的有**退出区**，剩余的部分称为**剩余区**

```c
while{
    //进入区
    //临界区
    //退出区
    //剩余区
}
```

而源代码中的`while (counter==n);`就保证了生产者与消费者之间是互斥的关系



### 进程同步应该遵循的原则

1. **空闲让进**：共享资源空闲，允许进程访问
2. **忙则等待**：共享资源被占用，要使用该共享资源的进程应该等待

以上是**两个基本原则，是必须要遵循的原则**，以下还有两个原则

3. **让权等待**：进程等待资源时，应调整进程为**阻塞态**，释放其占有的CPU资源，以免进入**忙等**状态
4. **有限等待**：保证等待的时间是有限的，以免陷入**死等**状态



### 锁机制

为了实现进程同步的原则，有很多不同的让进程间互斥的方法，这是其中之一——锁机制



锁机制很简单，分为**上锁**和**开锁**两个操作（以下用伪代码表示）

```c
void lock(L){
    check:
    	if(L == 1)
           		goto check;	//循环检测锁的状态
    	else
            	L = 1; // 上锁
}

void unlock(L){
    L = 0;	//开锁
}
```

两个并发的进程使用临界资源时，执行上述两个操作即可，但是要注意**上锁与开锁必须都是原语操作**，否则有可能在**判断后，改变锁状态前**出现两个进程同时进入了临界区的异常状况



#### 优点：

简单、简单、还有简单

#### 缺点

反复检测锁状态，造成CPU**轮询**（反复的检测锁的状态，导致CPU必须一直检测该资源），CPU资源浪费，不遵循**让权等待原则**，会使CPU的效率大大的降低



### 信号量（Semaphores）机制

信号量（Semaphores[ˈseməfɔːz]）提出者Dijkstra（又是这个人~）

发展：从**经典信号量**、**记录型信号量**、**AND信号量**、最后发展为**信号量集**



#### 信号量

- 信号量是对具体物理资源的抽象
- 不同类的资源用不同名称的信号量代表
- 同类资源的个数用 >0 的信号量值表示。
- 信号量值为 0 或 1 的信号量表示临界资源。



#### 经典（整型）信号量

Dijkstra提出了把整型信号量定义为一个用于**表示资源数目**的整型量S

除初始化外，**仅能通过两个标准的原子操作 wait(S)和signal(S)来访问**，也叫作P（申请资源）、V（释放资源）操作

```c
wait(S){
    while(S <= 0);
    S--;
}

signal(S){
    S++;
}
```

这种方式和消费者生产者问题一样，都是需要CPU进行轮询，不满足**让权等待原则**



#### 记录型信号量

- 满足让权等待原则
- 引入进程阻塞机制
- 在信号量里增加对阻塞进程的纪录。

至于为什么要叫记录型信号量，是因为这种方法定义了一个**新的数据结构**来代替原有的整型信号量

```c
typedef struct{
    int value;			//表示资源数目
    struct process_control_block *list;	//表示等待调用资源的PCB链（阻塞进程PCB队列）
} semaphore;

wait(semaphore *S){	//申请资源P(S)
    S->value--;
    if(S->value < 0)
        block(S->list); //自我阻塞，也是原语操作，实现了让权等待
}; 

signal(semaphore  *S){//释放资源 V(S)
   S->value++;
   if(S->value<=0)	//如果+1后仍然资源仍然小于0，说明阻塞队列中仍有需要该资源的进程，那么就唤醒一个进程
       wakeup(S->list);//自我唤醒，也是原语操作
};

```

如果这个资源数量为1，那么该信号量就转化为互斥信号量，进程之间互斥

**如果S=n,n>0，说明S资源还有n个；**

**如果S=n,n<0，说明等待队列中有-n个进程在阻塞**



记录型信号量的特点：**主动阻塞与被动唤醒**



检测一下：

![image-20201208103432172](http://img.yesmylord.cn//image-20201208103432172.png)

#### AND型信号量

##### 为什么要引入AND型信号量？

之前我们讨论的都是在多个进程共享一个资源的情况，当**一个进程需要两个或多个资源**时，会出现什么状况呢？

假设：有两个临界资源为Q与W，我们使用记录型信号量处理以下两个进程的任务

```
A进程：				B进程：
	P(Q)					P(W)
	P(W)				   	  P(Q)
	V(Q)					V(W)
	V(W)					V(Q)
```

1. 进程A抢到了资源Q
2. 进程B抢到了资源W
3. 进程A想要资源W，没有，进入阻塞状态
4. 进程B想要资源Q，没有，进入阻塞状态

我们发现两个进程都进入了阻塞状态，并且都不会释放他们已有的资源，这种情况叫做**死锁**状态

引入**AND型信号量**就是为了解决死锁问题而提出的



##### AND信号量的机制

**将多次对多个信号量的申请改为一次，用一个原子操作完成。**

即将一个进程所需要的所有资源一次性给了他，当其用完时再一次性全部释放

```c
Swait(S1,S2,S3...,Sn){
    while(true){
        if(S1>=1 && S2>=1 &&....&&Sn>=1 ){//利用短路性质
            for(i=1;i<=n;i++)
                Si--;
            break;
        }//end if
        else{
            //当Si资源不足时，会进入第一个不足的Si的阻塞队列中；并将进程的程序指针PC设到Swait的开头
        }
    }//end while
}

Ssignal(S1,S2,S3...,Sn){
    while(true){
        for(i=1;i<=n;i++){
            Si++;
            //将Si等待队列的第一个等待的进程唤醒
        }//end for
    }//end while
}
```

再引入AND型号量之后，我们发现进程只会有两种情况：

1. 全部资源都申请到
2. 全部资源都没申请



#### 信号量集

##### 为什么要提出信号量集？

之前我们提到的情况都是每个进程申请同一个资源只申请一个，但是有时候进程会对同一个资源要申请多个。

1. 如果使用之前的信号量，那么我们就需要申请多次，这样显然低效。

2. 系统为了保证安全性，对于某些资源，如果低于一定的下限，那么系统就不愿将其分配

信号量集就是为了解决这种问题

##### 信号量集的基本思想

信号量集增加了以下信息

```
Swait(S1,t1,d1,……,Sn,tn,dn)
si：各信号量;
ti：申请下限
ti > 0时，可进行资源预留；
di：申请个数

Ssignal(S1,d1,……,Sn,dn)
```



##### 信号量集的三种特殊情况

1. `Swait(S，d，d)`：此时在信号量集中只有一个信号量S，但允许它每次申请d个资源，当现有资源数少于d时，不予分配。
2. `Swait(S，1，1)`：此时的信号量集已**退化为一般的记录型信号量(S>1时)或互斥信号量(S=1时)**
3. `Swait(S，1，0)`：这是一种**很特殊且很有用**的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。
   - `S>=1`：S值不变，可以进入临界区；
   - `S < 1`：阻塞进程；



#### 信号量实现进程互斥

进程间实现互斥：只需要设置一个**互斥信号量(mutex)**，并**将初值设置为1**，然后将**临界区放在`wait()`与`signal()`操作中间**即可



mutex有三种取值：-1,0,1

- 1：两个进程都没有申请资源
- 0：一个进程正在临界区运行，另一个进程没有请求资源
- -1：一个进程正在临界区运行，另一个进程申请了资源，在阻塞等待

注意：`wait()`与`signal()`必须成对出现



#### 信号量实现前驱关系

假设要实现这样的情况：

```
	S1 -> S2   前驱关系，先进行S1，在进行S2
```

我们可以使用一个**公用信号量，初值设为0**

```
P1:  S1; signal(S);
P2:  wait(S) ; S2
```

这样就可以保证`S1`操作必然执行在`S2`之前



例如：实现下图所示的前趋图

![image-20201208114735507](http://img.yesmylord.cn//image-20201208114735507.png)

```c
p1() {S1; signal(a);signal(b)}
p2() {wait(a); S2; signal(c);signal(d)}
p3() {wait(b); S3; signal(e)}
p4() {wait(c); S4; signal(f)}
p5() {wait(d); S5; signal(g)}
p6() {wait(f);wait(g);wait(e); S6;}

main(){
    semaphore a,b,c,d,e,f;
    a.value = b.value = c.value =0;
    d.value = e.value = 0;
    f.value = g.value = 0;
    cobegin
    	p1();p2();p3();p4();p5();p6;
    coend
}
```



## 进程通信

进程间有时会需要交换信息，协调一致完成一个任务

### 进程通信方式分类

- **低级通信方式**：传送一个字节或几个字节的控制信息。例如锁机制、信号量
- **高级通信方式**：交换大批量的数据。例如消息缓冲机制、信箱机制

本节主要来讲高级通信机制

### 共享存储器系统

#### 基于共享数据结构方式

进程间共用某些数据结构，如生产者消费者交换数据的有界缓冲区，是**低级的通信方式**，**程序员负责**

特点：**OS提供共享存储器，程序员设置缓冲区，负责进程同步；**

缺点：**效率低；只能传输少量数据**

#### 基于共享存储区方式

内存中划出一个专门的内存区域，各个进程可以对这个进程进行读写。**高级通信方式**，**操作系统负责**

特点：

- **数据的形式和位置由进程负责**，而不是OS
- 要通信的进程向系统申请共享存储区的一块分区，附加到自己的地址空间中，便可以向其进行读写



### 消息传递系统（Message passing system）

特点：数据交换以**消息(message)或报文**为单位，利用通信原语实现通信，**高级通信方式**

分为：

- 直接通信方式：直接把消息发给接收进程
- 间接通信方式：分为发送和接收两步，通过中间实体（**信箱**）完成进程之间的通信



#### 消息传递的实现方式

两个通信原语：**send**与**receive**实现信息的发送与接收



#### 直接消息传递系统

实现方式：对于直接通信方式，发送方直接将信息发送给对应进程即可。

**要求：需要双方显示提供标识符**

通信形式:

- 对称形式：适用于一对一通信
- 非对称形式：适用于多对一通信

对称形式通信原语：

```c
Send (Receiver，message)   // 发送一个消息给接收进程
Receive (Sender，message) //接收Sender发来的消息

//例：原语Send(P2，m1)      表示将消息m1发送给接收进程P2；
//       原语Receive(P1，m1)  表示接收由P1发来的消息m1。

```

非对称形式通信原语：

```c
Send (P，message)   // 发送一个消息给P进程
Receive (id，message) //接收消息，id表示发送进程的id或名字
```

#### 消息缓冲队列通信机制（直接通信）

> 消息缓冲通信：是一种直接通信方式，一种可直接**以较高的效率传递较多数据**的信息交换方式，被广泛应用于**本地进程之间的通信**。

要求：

1. 需要设置消息缓冲区（内存中的一个区域）：

```c
typedef  struct message_buffer {
　         int sender;	// 发送者进程标识符
　         int size;          // 消息长度
　　     char *text;      // 消息正文
　　　 struct message_buffer  *next;// 指向下一个消息缓冲区的指针
}; 
```

​	发送进程可以**把消息填写到消息缓冲区中，并把该消息缓冲区插入到接收进程的消息链上**，以待接收进程进行加工处理。

2. 还需要在PCB中设置相应字段

```c
typedef struct processcontrol_block{
    ...
    struct message_buffer *mq; //消息队列头指针，将所有的消息缓冲区链成一个队列，其队头通过在接收进程PCB中设置队首指针mq来指出。
    semaphore mutex;		//消息队列互斥信号量，初值为1，消息队列属于临界资源
    semaphore sm;			//消息队列资源信号量，初值为0，当发送进程发来一个消息，在此信号量上执行signal(sm)；而当接收进程从消息队列上欲取走一个消息时，先对信号量执行wait(sm)
    ...
}
```

过程：

1. 发送方先在自己内存内设置一个**发送区**，向其中填写消息正文、接收进程标识符id，消息长度
2. 调用**发送原语**：把消息**从发送区复制到消息缓冲区**，挂到消息队列末尾。如果接收方在等待消息，则唤醒接收方
3. 接收方调用**接收原语**：查看`sm`获知是否有待处理的消息，无消息则接收进程进入阻塞；有消息则将消息队列第一个消息摘下，**将消息缓冲区信息复制到接收区**



#### 信箱通信（间接通信方式）

可以实现实时通信，也可以实现非实时通信

信箱的数据结构：由**信箱头**和**信箱体**两部分组成

- 信箱头：
  - 信箱标识符
  - 信箱拥有者
  - 信箱口令
  - 已存放的信件数
- 信箱体：由若干个存放消息的信箱格组成，每一个格子可以存放一个信件

![image-20201209174428315](http://img.yesmylord.cn//image-20201209174428315.png)

原语：信箱有创建原语、撤销原语、发送原语、接收原语

信箱的分类：

![image-20201209174633649](http://img.yesmylord.cn//image-20201209174633649.png)

信箱发送与接收对应关系：

![image-20201209175037695](http://img.yesmylord.cn//image-20201209175037695.png)







### 管道（PIPE）通信系统



> 管道：**连接一个读进程与写进程实现他们之间通信的一个共享文件**，又名pipe文件

特点：

- 写进程将数据以**字节流**形式送入管道，读进程从管道中读取数据

要求满足：

1. **互斥**：读进程与写进程互斥对管道进行操作，一方操作时另一方必须等待
2. **同步**：当写入进程写入一定量的数据后，睡眠等待，等到读进程读取完毕后将其唤醒；读进程读空管道也要睡眠等待，等待写进程写入数据
3. **确定对方是否存在**：只有确定了对方已存在才能进行通信



## 线程



### 为什么提出了线程？

在最开始，进程有两个独立性：

1. 资源分配的最小单位
2. 最小的调度单位

但是在不断的计算机发展过程中，发现**进程的切换需要消耗很大的时间与空间的开销**，为了提高系统的效率，决定将进程这两个属性分离开，提出了比进程更轻量级的概念——**线程**



> 操作系统将进程独立性的两个属性分别赋予了两个不同实体:
>
> - 拥有**资源所有权的仍称为进程**
> - **调度的单位称为线程**，或轻量级进程。

### 线程控制块TCB

每个线程也有一个数据结构——线程控制块TCB，记录以下内容：

1. 线程标识符：唯一标识此线程
2. 一组寄存器：PC、状态寄存器、通用寄存器
3. 线程运行状态：线程有三个状态（执行、就绪、阻塞）与进程的三个状态相同
4. 线程专有存储区：存放线程切换时的现场信息等
5. 信号屏蔽：对某些信号进行屏蔽
6. 堆栈指针：保存局部变量和返回地址



### 多线程OS中进程的属性

在拥有线程后，进程的属性有了一些变化：

1. 仍然是资源分配的最小单位
2. 多个线程可以并发执行：进程负责给予线程资源使用（资源还是进程的）
3. 进程不再是可执行的实体：通过管理进程可以相应的管理其进程中的线程。如阻塞一个进程就会阻塞其所有线程



![image-20201209162813291](http://img.yesmylord.cn//image-20201209162813291.png)



### 线程的特点

1. 是进程的一个实体，是**处理器独立调度和分派的基本单位**
2. **不拥有系统资源**，资源是属于进程的
3. 可并发执行
4. 开销小，切换快
5. 线程间通信无需内核介入（**共享同一块地址空间**）



检测：

![image-20201209164110357](http://img.yesmylord.cn//image-20201209164110357.png)

1. 进程的资源在线程面前透明，线程的信息在线程之间互相隐藏
2. 进程是资源分配的最小单位
3. 同一进程中，线程的切换不会引起进程的切换。当从一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。



### 线程的实现方式



#### 内核支持线程KST（Kernel Supported Threads）

无论是用户进程还是系统进程**都是在内核的支持**下实现的

特点：

- **内核支持线程KST**也是在内核的支持下运行的。

- **线程的创建、撤消和切换等也是依靠内核**，在内核空间实现的。内**核空间为每一个内核支持线程设置了一个线程控制块**，内核是根据该控制块而感知某线程的存在，并对其加以控制。

优点： 

- 对多处理器，核心可以同时调度同一进程的多个线程
- **阻塞在线程一级完成**：如果一个线程被阻塞了，内核可以调度该进程中的其它线程或运行其他进程中的线程
- 切换更快：数据结构和堆栈更小
- **调度以线程为单位进行**
- 核心例程是多线程的，提高系统运行速度

缺点：

- **用户的线程切换**必须从用户态切换到核心态进行，开销大



#### 用户级线程ULT（User Level Threads）

ULT是在用户空间实现的

特点：

- **线程的创建、撤销调度都无需内核的参与**，内核不知道该线程的存在
- 调度**以进程为单位进行**

优点：

- 切换不需要调用核心，切换速度快
- 调度是应用程序特定的，可以更换调度算法
- 可以允运行任何操作系统上

缺点：

- 系统调用阻塞进程：大部分的系统调用会阻塞进程，导致所有线程被阻塞
- 纯ULT方式下，内核每次分配给该进程只有一个核心，导致该进程只能有一个线程运行



#### 组合的方式ULT/KST

特点：

- **线程创建在用户空间完成**
- **大量线程调度和同步在用户空间**完成
- 程序员可以调整KST的数量

## 总结

1. 顺序执行的特点：顺序性、封闭性、可再现性
2. 并发执行带来的问题：间断性、失去封闭性、结果不可再现
3. 如何解决并发执行带来的三个问题：PCB（解决间断性）、进程同步（失去封闭性、结果不可再现）
4. 为什么要引入进程？为了更好的执行并发任务，利用进程来执行任务，不仅可以实现并发需求，还便于管理
5. 进程的作用：资源分配的最小单位
6. 进程的状态：三种基本状态：运行、阻塞、就绪
7. 后来引入了新的状态：创建、就绪（静止就绪、活动就绪）、运行、阻塞（静止阻塞、活动阻塞）、销毁
8. 是否是静止状态，就是看他们是不是在内存。
9. 挂起操作会将进程保存到外存中，节省内存资源
10. PCB是什么？进程控制块
11. PCB存放了什么？四方面的内容
    - 进程描述信息：例如PID、UID
    - 进程控制和管理的信息：例如进程当前的状态、进程的优先级、程序的外存地址、进入内存的时间、占用CPU的时间、信号量的使用情况
    - 资源信息：代码段指针、数据段指针、堆栈段指针、文件描述符、鼠标、键盘
    - CPU相关信息：各种寄存器的地址
12. PCB的作用：
    - 作为OS感知进程的数据结构
    - 实现了并发的间断性运行
    - 方便进程管理（操控线程状态，创建、销毁线程）
    - 方便进程调度（比如切换进程，就是将PC中运行的现场信息存放到PCB内）
13. PCB的存储方式：可以是线性表方式、链接方式、索引方式（具体看图，最好记住）
14. 进程的特点：
    - 进程可以创建子进程
    - 子进程拥有父进程的所拥有的资源（比如父进程打开的文件）
    - 子进程被撤销，会将资源归还给父进程
    - 父进程被撤销，子进程会被全部撤销
15. 为什么要进程同步？并发带来了失去封闭性、结果不可再现问题；进程同步可以解决这两个问题
16. 进程同步需要满足的原则：空闲让进、忙则等待、让权等待（等待资源时，进入阻塞状态，释放CPU资源）、有限等待（保证等待时间有限，避免进入死等状态）
17. 进程同步的方法：锁机制、信号量
18. 信号量的发展：
    1. 经典信号量（`wait`与`signal`，轮询，不满足让权等待）
    2. 记录型信号量（有一个阻塞列表，满足让权等待）
    3. AND型信号量（解决死锁问题，同时获取所需的所有资源，要么都获取到，要么都获取不到）
    4. 信号量集（解决进程申请多个资源的问题，资源为1时就是一个互斥信号量）
19. 进程通信（本文的进程通信是从通信方式来分类的，并不详细，所以写了另一篇Blog）



