---
title: 设备管理
date: 2020-12-31 21:13:45
tags:
- 操作系统
- 设备管理
- Spooling技术
- 通道
- 寻道算法
categories:
- 操作系统
---


<center>
  新年到来了！！今年的最后一篇博客 <br/>
  引言：操作系统中的设备是如何管理的？
</center>

<!-- more -->

# 	设备管理

## 外部设备

本节主要讨论外部设备：

> 外部设备：**除CPU与主存外的设备**
>
> 特点：
>
> - 多、杂、乱
> - IO速度慢



设备的分类：

- 按所属关系分类：
  - 系统设备（操作系统生成时已登记于系统中的标准设备。如键盘、打印机、磁盘等）
  - 用户设备（如绘图机、扫描仪）
- 按设备使用特性分类：
  - **存储设备**
  - **输入输出设备**
- 按传输速率分类
  - 低速设备：键盘、鼠标
  - 中速设备：打印机
  - 高速设备：磁带机、磁盘机、光盘机
- 按**信息交换方式**分类
  - 块设备（主存和外设之间的信息交换是**以块为单位**（一块通常是512字节~4K个字节）进行的设备：磁盘、磁带）
  - 字符设备（主存与设备之间的信息交换是**以字符为单位**进行的设备：键盘、显示器）
- 从**资源分配角度**分类
  - 独占设备：一般是低速设备
  - 共享设备
  - 虚拟设备（为提高设备的利用率，通过**Spooling技术**把独占设备改造为共享设备，用来**模拟独占设备的那部分共享设备**称为虚拟设备）



## 设备管理的功能

功能：

- 隐藏物理设备的细节
  - 外部设备多、乱，这些细节不能让用户感受到
- 与设备的无关性
  - 用户可以用抽象命令控制设备，例如read write可以读写不同的设备
- 提高CPU与IO设备的利用率
- 对IO设备进行控制
  - 有四种控制方式
    - 轮询
    - 中断
    - DMA
    - 通道
- 确保对设备的正确共享
  - SPOOLing技术
- 错误处理
  - 持久性错误：必须向上层报告
  - 临时性错误：可以重试解决

## I/O系统的层次结构

I/O软件组织：

1. 硬件
2. **中断处理程序**（负责IO完成时唤醒设备，发起中断）
3. **设备驱动程序**（设置设备寄存器，检查寄存器状态）
4. **设备独立性软件**（映射、保护、分块、缓冲）
5. **用户层IO软件**

IO系统本身也可分为三层：

1. **中断处理程序**
2. **设备驱动程序**
3. **设备独立性软件**



## 设备控制器

一个设备控制器可以控制多个硬件设备

### 设备与设备控制器的关系：

用三条线管理设备：

- 数据信号线
- 状态信号线
- 控制信号线

注意他们的方向

![image-20201230151106792](http://img.yesmylord.cn//image-20201230151106792.png)

### 设备管理器的结构与功能

#### 设备管理器的结构：

三部分组成：

- 与CPU的接口
- 与设备的接口
- IO逻辑

![image-20201230153413428](http://img.yesmylord.cn//image-20201230153413428.png)

IO逻辑用来控制设备：

1. 控制线与处理器交互，发送IO命令、译码
2. 地址信号去选择一个设备接口

控制寄存器：存放CPU发来的指令

状态寄存器：存放设备现在的状态信息



#### 设备管理器的功能：

- **接收和识别命令**

  设置**控制寄存器**接收CPU的命令和参数，译码

- 进行**数据交换**

  ![image-20201230151539129](http://img.yesmylord.cn//image-20201230151539129.png)

- 标识和报告设备的状态：设置**状态寄存器**记录设备状态
- 地址识别：设置**地址译码器**识别所控制的每个设备的地址
- 数据缓冲：设置**缓冲器**缓解IO设备与CPU的速度差异
- 差错控制





## 中断技术

> 中断：CPU对IO设备发来的中断信号的一种响应（外中断）
>
> 陷入（内中断）：由CPU内部所引起的中断
>
> 他们俩的区别主要是中断的**来源不同**

### 中断事件的类型

- 强迫性中断事件
  - 硬件故障中断（停电、读写错误）
  - 程序性中断（数据溢出）
  - 外部中断（键盘输入命令）
  - 输入输出中断（外部设备故障）
- 自愿性中断事件（运行进程所需要的）
  - **访管中断**（执行一条“访管指令”请求系统调用）

> 访管指令（陷入指令）：
>
> ​		当运行的用户进程或系统实用进程欲请求操作系统内核为其服务时，可以安排执行一条陷入指令引起一次特殊异常。**用户态请求内核态服务**



### 中断向量表

通常会为**每一个设备配一个中断处理程序**，并且每一个设备的中断请求申请一个**中断号**

然后把这个中断处理程序的入口地址存放在**中断向量表**中对应的中断号表项下



当IO设备发来中断信号，中断控制器就通过收到中断号去中断向量表中查询中断处理程序的入口地址，进而处理中断

### 中断响应

>  CPU收到中断请求后转相应的中断处理程序的过程称为中断响应

CPU在收到中断后：

1. 发现和识别中断事件：硬件设有中断装置发现和识别中断事件
2. 交换PSW（FLAG寄存器）
   1. 中断码存入PSW寄存器的中断码位
   2. 将旧PSW存到主存
   3. 将新PSW送入PSW寄存器



### 中断处理的原则

- 强迫性中断事件
  - 硬件故障中断：输出事件性质
  - 程序性中断（数据溢出）：输出进程名、程序断点
  - 外部中断（键盘输入命令）：接收外部请求转例子程序
  - 输入输出中断（外部设备故障）
    - 正常情况释放等待进程
    - 异常情况告知信息错误
- 自愿性中断事件（运行进程所需要的）
  - **访管中断**：根据访管指令功能号转对应的系统调用



### 中断优先级

硬件故障中断＞**自愿性中断**＞程序性中断＞外部中断＞输入输出中断



### 中断屏蔽

对于多中断源，一般有两种处理方式：

- 屏蔽中断：屏蔽**所有**中断
- 嵌套中断：
  - 优先响应高优先级的中断
  - 高优先级中断抢占低优先级中断

### 中断处理过程

1. 测定是否有未响应的中断
2. 保存现场信息
   - 通常由硬件自动保存现场信息，保存在**处理机状态字PSW和程序计数器PC**中
3. 转到中断处理程序
   - 通过收到的**中断号**查询**中断向量表**得到中断程序的入口地址
4. 中断处理
   - 根据中断处理原则进行处理
5. 恢复CPU现场
6. 退出中断或者处理下一个中断
   - 取决于选择的中断屏蔽方式：是屏蔽中断还是嵌套中断

## 设备驱动程序

设备驱动程序

> 负责IO进程与设备控制器之间的通信：
>
> ​		接收上层软件发来的**抽象I/O要求**，如read、write命令，在把它转换为**具体要求**后，发送给设备控制器，启动设备去执行。由设备控制器发来的信号传送给上层软件。

### 功能

1. 将设备独立软件发来的**抽象命令转换为具体命令**
2. 检查用户I/O请求的**合法性**，了解I/O设备的状态，传递有关参数，设置设备的工作方式
3. 发出I/O命令（如空闲，则启动I/O，完成指定的I/O 操作，阻塞驱动程序）
4. **及时响应中断请求，并唤醒**（设备发出中断后会被阻塞），根据其中断类型调用相应的中断处理程序进行处理
5. 根据用户的I/O请求，**自动构成通道程序**

功能分为两大块：

- **启动IO设备功能**
- **设备中断处理程序**



### 特点

属于**低级的系统例程**，与一般的应用程序及系统程序有以下区别：

1. **IO进程与设备控制器的一个桥梁**
2. 与硬件紧密相关，甚至一部分必须使用汇编语言编写
3. 允许可重入（一次调用完可能会被再次调用）
4. 不允许系统调用



### 设备处理方式

有三种不同的设备处理方式：

- 为每一类设备设置一个IO进程
- 整个系统设置一个IO进程
- 不专门设立设备处理进程，只为各类设备设置设备驱动程序

## 设备独立性软件

**设备独立性**：用户在编制程序时使用的设备与实际使用的设备无关，用户程序中使用的是**逻辑设备**

即我们使用一台设备，如打印机，我们不会管是什么打印机，惠普打印机还是联想打印机，设备独立性软件就负责把我们使用的逻辑设备变为物理设备



实现了`I/O重定向`

> 即**用于I/O操作的设备可以更换**



### 逻辑设备表LUT（Logic Unit Table）

> 一张联系**逻辑设备名称和物理设备名称的映射表**，实现逻辑设备名到物理设备名映射

| 逻辑设备名   | 物理设备名 | 驱动程序入口地址 |
| ------------ | ---------- | ---------------- |
| /dev/tty     | 3          | 1024             |
| /dev/printer | 5          | 2046             |

当进程用逻辑设备名请求分配I/O设备时，系统为它分配相应的物理设备，并在LUT上建立一个表目



**LUT的设置方式：**

- **整个系统**一张LUT
- **每个用户**一张LUT

### 设备独立性软件

> 为了实现设备独立性，须再在驱动程序之上设置一层软件，称为设备独立性软件

1. 实现所有设备都需要的功能，向用户级软件提供接口
2. 映射设备名
3. 设备保护：系统防止无权存取设备的用户存取设备
4. 掩盖底层有差异性质，提供无差别的服务
5. 缓冲技术





## IO控制方式

**四种IO控制方式**：

- 使用轮询的可编程IO方式
- 使用中断的可编程IO方式
- 直接存储器DMA方式
- IO通道控制方式

### 使用**轮询**的可编程IO方式

CPU必须重复测试外设的状态

- 缺点：
  - CPU利用率低
  - 设备不能并行工作
  - 不支持多道程序

- **中断**驱动IO控制方式：每当设备完成I／O操作时，便向CPU发出中断请求信号

  - 优点：
    - 解放了CPU
    - 使设备与CPU可以并行操作
  - 缺点：
    - 如果传送一个数据都要中断一次，那么会大大的降低CPU的处理速度

  ### **直接存储器**访问DMA

  - 特点：
    - 设备与主存直接传送数据
    - 需要DMA控制器
    - 传输的基本单位是**数据块**
    - 仅在传输数据的开始与结束需要CPU干预
  - DMA控制器的结构：
    - 与主机的接口
    - 与设备的接口
    - IO逻辑
    - 而且必须实现四类寄存器：
      - 命令/状态寄存器CR
      - 内存地址寄存器MAR
      - 数据寄存器DR
      - 数据计数器DC
  - 缺点：
    - 传输的方向、数据长度、内存地址都需要CPU控制
    - 每台设备都配置DMA的话，成本太高

  ### I/O通道控制方式

  > **通道：专门负责I／O控制的处理机**
  >
  > 它接收CPU的委托，独立地执行自己的**通道程序**，管理和控制输入输出操作，实现主存贮器与外围设备之间的成批数据传送。

  通道程序：由通道指令构成的程序

  每条指令包含以下信息：

  1. 操作码：表示本次执行读还是写操作
  2. 内存地址：操作的地址
  3. 计数：本次操作的字节数
  4. 通道程序结束位**P**：**表示通道程序是否结束，`P=1`表示本指令是本通道程序最后一条指令**
  5. 记录结束标志**R**：`R=0`表示本通道指令与下一条指令所处理的数据是**同一个记录**；`R=1`表示是处理本记录的最后一条指令

  例如：下表中列出的是一段简单的通道程序（内含6条指令），在下面的各个选项中叙述不正确的是（     ）

  | 操作  | P    | R    | 计数 | 内存地址 |
  | ----- | ---- | ---- | ---- | -------- |
  | WRITE | 0    | 1    | 90   | 743      |
  | WRITE | 0    | 1    | 100  | 250      |
  | READ  | 0    | 1    | 230  | 1200     |
  | WRITE | 0    | 0    | 120  | 400      |
  | WRITE | 0    | 1    | 120  | 350      |
  | READ  | 1    | 1    | 70   | 2000     |

  A 该段通道程序包括6条、2类通道指令。

  B 这些指令涉及的数据内存地址有相邻接的地方。

  C 该段通道程序共处理了5条记录。

  D 单记录最大为230个字节。

  

  解：我们可以这么看：

  A：P=1代表本通道程序结束；数一数有6条，有WRITE与READ两类指令

  B：例如第五行与第六行

  C、D：

  R=1代表这是该数据的最后一条记录所以可以看出：

  ​		第一行属于一个记录、第二行属于一个记录、第三行属于一个记录、**第四五行属于一个记录**，第六行属于一个记录

  所以选D，最大应该是240字节

  

  - 特点
    - 彻底解放CPU
    - 每次传输一组数据块
  - 通道与一般处理机的区别：
    - 指令类型单一，简单，仅限于IO操作
    - 通道没有自己的内存
  - 通道的瓶颈：
    - 由于通道成本高，所以通道数量很少，通道不足容易造成**瓶颈现象**
    - 可以使用**多通路方式**解决瓶颈问题
  - 类型：
    - 字节多路通道（以字节为单位传输，**连接大量慢速**设备）
    - 数组选择通道（每次选择**一台高速设备**，执行一个通道程序）
    - 数组多路通道（分时轮转同时控制多台设备）



## 设备分配

为了防止进程无序争夺资源，系统必须对资源进行统一分配

### 设备分配所需的数据结构

- 设备控制表DCT（记录设备特性，每个设备一张）
- 系统设备表SDT（记录系统中所有设备的情况，整个系统一张）
- 控制器控制表COCT（每个控制器一张）
- 通道控制表CHCT（每个通道一张）



### 分配策略

考虑不同的设备有不同的分配原则：

按三种设备分类：

- 独占设备
- 共享设备
- 虚拟设备



#### 独占性设备

设备分配给某作业后便由该作业独占，直到该作业完成并释放

- 静态分配：进程运行前分配
  - 缺点：设备利用率低
- 动态分配：运行过程中进程提出请求再给予分配
  - 优点：效率高
  - 缺点：可能会发生死锁

#### 共享设备

可以同时分配给多个进程同时访问，但是**要注意对进程访问设备的先后次序进行合理的调度**



#### 虚拟设备

虚拟设备属于可共享设备，**可以同时分配给多个进程使用**



### 分配算法

- 先来先服务
- 优先权高者优先



### 分配的安全性



1. 安全分配方式
   - 特点：进程发出IO请求便阻塞，直到请求完成被唤醒
   - 缺点：进程推进缓慢，不能并行工作
2. 不安全分配方式
   - 特点：进程发出I/O请求后仍继续运行，需要时又发出第二个I/O请求、第三个I／O请求。**仅当进程所请求的设备己被另一进程占用时**，进程才进入阻塞状态
   - 优点：一个进程可操作多个设备，且可以并行工作
   - 缺点：分配不安全，可能导致死锁
   - 解决方法：使用银行家算法



### 独占设备的分配过程

进程请求IO设备后：

1. 根据进程请求的**逻辑名**，**查LUT表**
2. 获得**物理设备名**，**查SDT，找DCT**
3. 找到该设备的**COCT与CHCT**

整个过程：**分配设备->分配控制器->分配通道**



## 用户层IO软件

### 系统调用与库函数

> 系统调用：
>
> - 不允许运行在用户态的应用程序直接去调用运行核心态的OS进程
> - 某些应用进程必须取得OS进程提供的服务
>
> 为了解决这两点的矛盾，引入了系统调用
>
> **系统调用是应用程序获得OS所有服务的唯一途径**



小部分用户IO软件是由**与用户程序连接在一起的库过程，甚至完全由运行于内核外的程序**构成

用户层软件必须通过一组系统调用来取得操作系统服务，通常由**库过程**实现

注意这里的库过程：**只是将系统调用时所用的参数放在合适的位置，由其它的I/O过程实际实现真正的操作**



### SPOOLing技术



#### 脱机输入、输出技术

为了缓和CPU的高速性与IO设备的低速矛盾

> 脱机输入输出：即在**外围控制机**控制下实现低速的IO设备与高速的磁盘之间进行数据传送

外围机作用下输入和输出可以与主机并行



#### SPOOLing技术

> SPOOLing技术（**假脱机技术**）：多道程序下，使用一个程序来**模拟外围控制机**，实现将数据从磁盘传送到低速的输出设备上，再模拟一台外围控制机，来实现输入，**从而在主机的直接控制下，实现脱机输入与脱机输出**

**可以将一项将独占设备改造成为共享设备的技术**

SPOOLing技术的组成：

- 使用大容量**磁盘**来实现**输入井**与**输出井**（模拟脱机输入输出的磁盘）
- 使用**内存**来实现**输入输出缓冲区**

- 输入进程：将用户输入的数据通过缓冲区送到输入井，当CPU需要输入数据时，直接从输入井读入内存
- 输出进程：将输出的数据**先送出到输出井**，待设备空闲时，将输出井数据经过输出缓冲区送到输出设备
- 井管理程序：控制用户进程和磁盘井之间交换信息

现象：一个资源转换技术，用空间（输入输出井）换取CPU的时间

实质：**利用系统中的外存空间（磁盘）代替独占型的设备**，以便**模拟出一些物理上不存在的设备**供用户使用



例如：假若进程打开打印机特殊文件后几小时内无所事事，其他进程什么都打印不了，那么我们可以使用SPOOLing技术来共享打印机！

1. 输出进程在输出井申请一块空闲区，将要打印的数据输入

2. 输出进程为用户建立一张**IO请求表**，将表挂到**请求打印队列**上

3. 如果有打印机空闲，输出进程从**请求打印队列**的队首取出一张**请求打印表**，根据表中的要求将要打印的数据

   ![image-20201230192858265](http://img.yesmylord.cn//image-20201230192858265.png)

   **输出进程是唯一获准使用打印机特殊文件的进程**，用以打印请求打印队列中的文件。



特点：

- 提高了IO速度
  - 对低速I/O设备进行的I/O操作变为对输入井或输出井的操作
- 设备并没有分配给任何进程
  - 在输入井或输出井中，分配给进程的是一存储区和建立一张I/O请求表
- 实现了虚拟设备功能
  - 多个进程同时使用一独占设备，而对每一进程而言，都认为自己独占这一设备，不过，该设备是逻辑上的设备





## 缓冲技术

### 为什么要引入缓冲技术？

1. **改善CPU速度与IO设备速度不匹配的问题**
2. **减少中断CPU的次数**
3. **减少占用通道的时间**



### 实现思想

> ​		当一个进程执行**写操作**输出数据时，先向系统申请一个主存区域——**缓冲区**，然后，将数据高速送到缓冲区。若为顺序写请求，则不断把数据填到缓冲区，直到它被装满为止。此后，进程可以继续它的计算，同时，系统将缓冲区内容写到I/O设备上。



### 缓冲的类型

1. 硬缓冲：寄存器
2. 软缓冲：在主存中开辟一片区域充当缓冲区，并设置IO指针

根据系统设置缓存区的数目可以分为：

- 单缓冲
- 双缓冲
- 循环缓冲
- 缓冲池

![image-20201230200015404](http://img.yesmylord.cn//image-20201230200015404.png)

### 单缓冲

**T表示把数据从磁盘输入到缓冲区的输入时间，M表示将数据传送到用户区的时间，C表示处理器的计算时间**

系统对每一块数据的处理时间：`Max(C , T) + M`



### 双缓冲

系统对每一块数据的处理时间：`Max(C , T)`



### 循环缓冲

R表示空缓冲区

G表示缓冲区已满

有三个指针：

- `nexti`：表示下次可用的空缓冲区
- `nextg`：表示计算进程下一个使用的缓冲区
- `current`：表示计算进程当前使用缓冲区

![image-20201231201941328](http://img.yesmylord.cn//image-20201231201941328.png)

使用以下两个过程来使用循环缓冲：

- `GetBuf过程`：获得缓冲区
- `Releasebuf过程`：释放缓冲区

同步问题：

- `nexti`追上`nextg`指针：**表示系统受计算限制**
- `nextg`追上`nexti`指针：**系统受I/O限制**



## 总结：资源共享技术

1. **虚拟存储器**

   以CPU时间和外存空间换取昂贵内存空间。

2. **缓冲技术**

   以内存空间来换取CPU与I/O设备速度上匹配。

3. **SPOOLING技术**

   利用系统中的外存空间代替独占型的设备，模拟出一些物理上不存在的设备供用户使用，以解决独占设备资源不足，不能满足用户的使用请求和制约系统运行的瓶颈问题





## 磁盘存储器的性能与调度



### 磁盘存储器的性能和调度

- 为文件分配存储空间
- 合理地组织文件的存储方式，以提高访问速度
- 提高磁盘存储空间地利用率
- 提高磁盘I/O速度，改善文件性能
- 确保文件系统的可靠性（备份）



### 磁盘的类型

- 固定头磁盘：每条磁道一个读写磁头（用于大容量磁盘上）

- 移动头磁盘：每个盘面一个读写磁头（应用于中小型磁盘设备中）



### 磁盘访问时间

1. 寻道时间：指把磁臂(磁头)移动到指定磁道上所经历的时间

```
Ts = m*n +s
```

m常数，与磁盘驱动器速度有关

n表示第几条磁道

s表示启动磁臂的时间



2. 旋转延迟时间Tr：指定扇区移动到磁头下面所经历的时间

不同的磁盘类型中，旋转速度至少相差一个数量级，如软盘为300 r/min，硬盘一般为7200～15 000 r/min，甚至更高



3. 传输时间：把数据从磁盘读出或向磁盘写入数据所经历的时间

```
Tt = b / rN
```

b表示：每次读写的字节数

r表示：旋转速度

N表示一条磁道上的字节数

**可访问时间Ta**表示为

```
Ta = Ts+ 1/2r + b/rN
可访问时间 = 寻道时间 + 旋转延迟 + 传输时间
```



### 磁盘调度算法

考虑的就是使得平均寻道时间最短



例如：假定磁盘有200个磁道，当前有9个访问者（进程）先后提出I/O操作，需要访问的磁道分别为：55，58，39，18，90，160，150，38，184；又假定当前磁头位置为100



#### 先来先服务/先进先出

优点：公平

缺点：未考虑优化寻道，有大量进程访问者竞争一个磁盘，则这种算法的性能接近于随机调度

![image-20201231210345871](http://img.yesmylord.cn//image-20201231210345871.png)

#### 最短寻道时间优先（SSTF）

> 选择使磁头臂**从当前位置开始移动距离最短**的I/O访问者

缺点：**每次选择距离最短者**同时，**忽略了可能由于不断的有新的I/O请求进程加入到队列中，且与当前磁头位置较近**，会使得原请求队列中的距离远的访问者总也得不到调度，**产生所谓“饥饿”现象**

![image-20201231210358414](http://img.yesmylord.cn//image-20201231210358414.png)

#### 扫描算法SCAN

> 考虑了两个方面的问题：
>
> - 方向
> - 与当前磁道号距离最短
>
> 作先由内向外运动，再由外向内运动，或反之。
> 这样就**避免了饥饿现象**。
>
> 由于这种算法使得磁臂移动规律颇似电梯的运动，因而也称为**电梯算法。**

![image-20201231210517911](http://img.yesmylord.cn//image-20201231210517911.png)

缺点：

会导致某些请求会被延迟读写



#### 循环扫描算法CSCAN

> 为了减少这种延迟，**规定磁头单向读/写运动(如只由内向外)**，**完成读写后立即返到最小/大磁道号的位置(构成循环)**，再进行扫描。即CSCAN算法

![image-20201231210933076](http://img.yesmylord.cn//image-20201231210933076.png)





