---
title: 设计模式
date: 2021-08-11 10:01:20
tags:
- 设计模式
- 单例模式
- 原型模式
- 适配器模式
- 工厂模式
- 代理模式
categories:
- 设计模式
---


<center>
    引言：设计模式：单例、原型、工厂、适配器、代理模式
</center>

<!-- more -->

# 设计模式

## 设计模式的概述与分类

1995年，GoF（四人组）合作出版了《设计模式：可复用面向对象软件的基础》，收录了23种设计模式，树立了软件设计领域的里程碑

可以把23种设计模式分为三大类：

- **创建型模式**：
  - **单例模式**、**工厂模式**、抽象工厂模式、建造者模式、**原型模式**
- **结构型模式**：
  - **适配器模式**、桥接模式、装饰模式、组合模式、外观模式、享元模式、**代理模式**
- **行为型模式**：
  - 模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式

## OOP七大原则

- 开闭原则：对扩展开放、对修改关闭
- 里氏替换原则：继承必须确保超类所拥有的性质子类仍成立
- 依赖倒置原则：面向接口编程，不要面向实现编程
- 单一职责原则：控制类的粒度，将对象解耦，提高内聚性
- 接口隔离原则：要为各个类建立它们需要的专用接口
- 迪米特法则：只与直接朋友交谈，不与“陌生人”说话
- 合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系

## 单例模式

> 单例模式：
>
> **一个类只允许创建一个对象**，那这个类就是一个单例类，这种设计模式就叫作单例模式。

作用：单例模式用来**创建全局唯一的对象**

实现方式：饿汉式、懒汉式、双重检测、静态内部类、枚举

### 饿汉式——直接new

```java
// 饿汉式单例模式
public class HungryMan {
    // 私有构造方法
    private HungryMan(){
    }
    
    private final static HungryMan hungryMan = new HungryMan();

    public static HungryMan getInstance(){
        return hungryMan;
    }
}
```

特点：

- 不是动态创建，浪费空间
- 不存在线程安全问题

### 懒汉式——为空new

```java
// 懒汉式单例模式
public class LazyMan {
    private LazyMan(){
    }

    private static LazyMan lazyMan = null;

    public static LazyMan getInstance(){
        if ( lazyMan == null){
            lazyMan =  new LazyMan();
            // 动态创建，不会浪费空间
        }
        return lazyMan;
    }
}
```

单线程下没问题，但是多线程情况下会报错

### 双重检索模式DCL（懒汉式单例）

多线程保证安全，双重判断并加`volatile`

```java
public class LazyMan {
    private LazyMan(){
    }

    private static volatile LazyMan lazyMan = null;
    // 必须加 volatile

    public static LazyMan getInstance(){
        // 双重检验
        if ( lazyMan == null){
            // 第一重检验，防止多个线程在此等待，提高性能
            synchronized (LazyMan.class){
                if(lazyMan == null){
                    // 因为此操作不是原子操作，所以加volatile
                    // 此操作有三步
                    /* 1. 分配内存 2.初始化 3. 指针指向引用
                    CPU判断2与3并无关系，所以可能先执行3 后执行2
                    如果此对象还没有被初始化完成就已经不为null了，那么多个线程会迫不及待的把这个对象抱回家——工作内存，导致发生异常
                    所以要加volatile
                    */
                    lazyMan =  new LazyMan();
                }
            }
        }
        return lazyMan;
    }
}
```

### 静态内部类实现单例

```java
public class Holder {
    private Holder(){
    }
    public static Holder getInstance(){
        return InnerClass.holder;
    }

    public static class InnerClass{
        private static final Holder holder = new Holder();
    }
}
```

特点：

- 外部类加载时不需要立即加载内部类，节省空间
- 线程安全

### 枚举

以上所有的方法，都避免不了被**反射**进行破解，导致单例不再单例。

但是枚举就不怕被反射破解，JDK源码如下：

```java
if ((clazz.getModifiers() & Modifier.ENUM) != 0)
            throw new IllegalArgumentException("Cannot reflectively create enum objects");
```



```java
public enum EnumSingle {
    INSTANCE;

    public EnumSingle getInstance(){
        return INSTANCE;
    }
}
```

可以直接使用`EnumSingle.INSTANCE`使用此对象

## 工厂模式

> 工厂模式：实现了创建者和调用者的分离

细分：

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式（非重点）

如果创建对象的逻辑并不复杂，那我们直接通过new来创建对象就可以了，不需要使用工厂模式。

当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，**将对象的创建和使用相分离**

### 简单工厂模式（静态工厂模式）

工厂模式通常代入一个例子好理解：

例如：程序员张三开车去上班

简单实现就是这样

```java
// 张三开五菱去上班
Car car = new Wulin();
zhangSan.drive(car);
// 后来张三996挣钱了，换成了宝马车
Car car = new BMW();
zhangSan.dirve(car);
// 再后来张三30岁了，被裁员，只能骑共享单车了
Car car = new HaLuo();
zhangSan.dirve(car);
```

如果使用简单工厂模式，张三就不需要再自己去创造车了

```java
zhangSan.drive(CarFactory.getCar("别克"));
```

CarFactory就是一个简单工厂，它的实现可以是这样的：

```java
public class CarFactory{
    public static Car getCar(String carName){
        if(carName == "BMW"){
            return new BMW;
        }else if(...){
            ...
        }
	}
}
```

简单工厂简单的分开了使用者和创造者，但是**不满足开闭原则**，比如我们现在要加入特斯拉，此时我们就要去更改CarFactory的代码。

### 工厂方法模式

更加合理的方式，就是每一个车，都应该有一个车厂，宝马有宝马车厂、特斯拉要有特斯拉工厂

如果加入一个新车，我们也不需要去更改源代码，而是进行扩展，这样就符合了开闭原则

Spring框架的IOC其实就是工厂模式的实现，Spring = 工厂 + 反射 + 配置文件

## 原型模式

> 原型模式：利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。

原型模式有两种实现方法：

- 深拷贝：一份完完全全独立的对象
- 浅拷贝：复制对象中基本数据类型数据和**引用对象的内存地址**，不会递归地复制引用对象，以及引用对象的引用对象

可以通过改写`clone`方法来实现原型模式：

1. 继承`Cloneable`接口
2. 重写`clone`方法

```java
@Data
public class User implements Cloneable{
    private String name;
    private ArrayList list;

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone(); // 浅拷贝
    }
}

public class Test {
    public static void main(String[] args) throws CloneNotSupportedException {
        User fengQiang = new User();
        fengQiang.setName("小明");
        ArrayList<Integer> list = new ArrayList<>();
        list.add(1);
        fengQiang.setList(list);
        // 克隆一份，然后使用克隆的再添加一个元素
        User clone = (User)fengQiang.clone();
        clone.getList().add(2);

        System.out.println(fengQiang);
        System.out.println(clone);
    }
}
// 输出结果为：
//User(name=小明, list=[1, 2])
//User(name=小明, list=[1, 2])
```

浅拷贝，两个对象地址一样

改写`clone`为深拷贝

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    User clone = (User) super.clone();
    clone.setList((ArrayList) clone.list.clone());
    return clone;
}
```

## 适配器模式

> 让原本由于接口不同而不能相互工作的类可以一起工作

有两种实现方式：

- 类适配器：**继承**一个类，来实现，但由于Java是单继承，所以这种方式不太推荐
- 对象适配器：万能的适配器，通过**组合**来实现

适配器模式是一种**事后的补救策略，用来补救设计上的缺陷**。应用这种模式算是“无奈之举”。如果在设计初期，我们就能规避接口不兼容的问题，那这种模式就无用武之地了

## 代理模式

> 代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是**控制访问**，而非加强功能，这是它跟装饰器模式最大的不同

代理模式常用在业务系统中开发一些**非功能性需求**，比如：监控、统计、鉴权、限流、事务、幂等、日志。

分为：

- 静态代理
- 动态代理

### 静态代理模式

静态代理模式中有 **真实对象、代理对象**

- 真实对象与代理对象要**实现同一个接口**
- 代理对象要**代理真实的角色**

优点：

- 静态代理模式可以帮助我们处理一些其他的事情，**真实对象可以专注于做本职任务**
- 如果业务发生扩展，方便集中管理

例如：租客与房东之间，租客需要一个中介（代理对象），中介负责去找房东（真实对象）

在Java中，`Thread`就是一个静态代理的例子，**自定义`Thread`类**要实现`Runnable`接口，而`Thread`类也实现了`Runnable`接口，此时**自定义`Thread`类**就是真实对象，而`Thread`类就是代理对象

除此外，在RPC（远程方法调用）中，客户端与服务端连接，具体的连接过程都由一个代理类来完成，这也是代理模式

### 动态代理

静态代理模式还存在一些问题，需要给每一个类都创建一个代理类，工作量直接翻倍

对于这种情况就出现了**动态代理**

> 其他概念与静态代理相同，只不过代理类是动态生成的，而不是我们直接写好的

- 基于接口的动态代理：JDK Proxy

- 基于类的动态代理：CGLIB
-  字节码实现：Javasist（不是重点，实现在JBoss服务器）

#### JDK Proxy

此动态代理模式用到两个类：`Proxy`与`InvocationHandler`

Proxy主要了解此方法`newProxyInstance`：

```java
public static Object newProxyInstance(ClassLoader loader,// 类加载器， 通常会选择使用动态代理类本身的类加载器
                                      Class<?>[] interfaces,// 通过真实对象可以获取到它所实现的所有接口
                                      InvocationHandler h// 实现动态代理的类本身
                                     )
```

InvocationHandler是一个接口，他有一个方法：

```java
Object invoke(Object proxy,// 生成的代理对象
              Method method,// 调用的方法
              Object[] args)// 方法的参数
       throws Throwable
```

在JDK动态代理中，**真实对象必须实现接口**，代理对象才可以对其进行代理，原理如下面这个demo：

```java
// 接口；在静态代理中，这个就是我们要实现的业务，代理与真实对象都要实现
public interface UserService {
    public void sayHi();
}
// 真实对象
public class UserServiceImpl implements UserService {
    @Override
    public void sayHi() {
        System.out.println("hi");
    }
}
// 动态代理生成处理器
public class ProxyInvocationHandler implements InvocationHandler {
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    // 获得代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(
                this.getClass().getClassLoader(),
                target.getClass().getInterfaces(),// 这个参数注意！其必须要有实现接口
                this
        );
    }

    @Override
    // 处理代理实例，返回对象
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("其他操作...");// 可以进行其他操作，比如记录日志等等
        Object invoke = method.invoke(target, args);// 实现真实对象想要实现的功能
        System.out.println("其他操作...");
        return invoke;
    }
}
public class Test {
    public static void main(String[] args) {
        UserServiceImpl impl = new UserServiceImpl();
        // 创建代理对象
        ProxyInvocationHandler pih = new ProxyInvocationHandler();
        pih.setTarget(impl);
        UserService proxy = (UserService) pih.getProxy();
        // 代理对象通过invoke调用方法
        proxy.sayHi();
    }
}
```

运行结果：

```
其他操作...
hi
其他操作...
```

这也是Spring AOP的实现原理

#### CGLib

JDK动态代理中，被代理的对象必须实现接口，而CGlib就不需要

## 参考链接

1. [知乎](https://www.zhihu.com/search?type=content&q=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)
2. [b站](https://www.bilibili.com/video/BV1mc411h719)